<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 教程及其远程仓库 GitHub</title>
    <url>/2022/06/09/Git-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>Git 是一个开源的分布式版本控制系统，是 Linus Torvalds 为 Linux 内核开发的开放源码的版本控制软件。与其他版本控制工具不同，Git 采用了分布式版本库的方式，同时还是一个内容管理系统，为不同设备和用户间的内容同步提供了便利。Git 目前被广泛运用在 GitHub、GitLab 以及中国的 Gitee 等代码托管和版本控制系统。</p>
<hr>
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#git-安装和配置">Git 安装和配置</a>
<ul>
<li><a href="#安装-git">安装 Git</a></li>
<li><a href="#配置-git">配置 Git</a></li>
</ul></li>
<li><a href="#git-原理">Git 原理</a>
<ul>
<li><a href="#git-基本工作流程">Git 基本工作流程</a></li>
<li><a href="#git-工作区-暂存区和版本库">Git 工作区、暂存区和版本库</a></li>
<li><a href="#深入理解-git">深入理解 Git</a></li>
</ul></li>
<li><a href="#git-常用命令">Git 常用命令</a>
<ul>
<li><a href="#创建和克隆-git-仓库">创建和克隆 Git 仓库</a></li>
<li><a href="#配置-git-1">配置 Git</a></li>
<li><a href="#提交和修改">提交和修改</a></li>
<li><a href="#分支">分支</a></li>
</ul></li>
<li><a href="#github">GitHub</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
<!-- /code_chunk_output -->
<hr>
<h1 id="git-安装和配置">Git 安装和配置</h1>
<h2 id="安装-git">安装 Git</h2>
<p>Git 有良好的跨平台性，目前支持在 Linux、MacOS、FreeBSD 和 Windows 平台上运行。</p>
<p>Windows 上可进入官网下载 Git：<a href="http://git-scm.com/download/win">git download</a>，若无法下载或下载缓慢可使用国内镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/Git%20for%20Windows%202.36.1/">清华大学 git for windows update 镜像</a>，下载并安装成功后将 Git 的 bin 目录加入环境变量。</p>
<p>Linux 上可以直接使用 shell，以 Debian 系为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install git</span><br></pre></td></tr></table></figure>
<p>终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.32.1</span><br></pre></td></tr></table></figure>
<p>若终端输出 Git 的版本号，则证明安装成功。</p>
<h2 id="配置-git">配置 Git</h2>
<p>配置个人信息，终端输入用户名和邮箱地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="git-原理">Git 原理</h1>
<h2 id="git-基本工作流程">Git 基本工作流程</h2>
<ol type="1">
<li>克隆 Git 资源到工作区。</li>
<li>在工作区对资源进行修改。</li>
<li>将工作区的资源提交。</li>
<li>若发现提交的内容有问题，可以撤回提交。</li>
</ol>
<h2 id="git-工作区暂存区和版本库">Git 工作区、暂存区和版本库</h2>
<ul>
<li>工作区：本地的资源目录。</li>
<li>暂存区：位于工作区的 .git/index 文件中。</li>
<li>版本库：位于工作区的 .git 目录。</li>
</ul>
<p><img src="ACA7C7AA-A862-4052-A3D8-CCF726A39110.jpeg" /></p>
<ul>
<li>使用 <code>git init</code> 可使用当前目录作为 Git 仓库，该命令会在当前目录生成一个 <strong>.git</strong> 目录作为版本库。</li>
<li>图中左侧为<strong>工作区</strong>，右侧为<strong>版本库</strong> 即 <strong>.git</strong> 目录，在版本库中有 <strong>index</strong> 文件代表<strong>暂存区</strong>。</li>
<li><strong>HEAD</strong> 为游标文件指向最后一次提交的分支，master 文件中存放着对象库中 master 分支的提交信息。</li>
<li><strong>objects</strong> 文件是 Git 的<strong>对象库</strong>，实际位于 .git/objects 目录，里面包含了文件内容、目录树等对象。</li>
<li>当使用 <code>git add</code> 命令时，即工作区增加或修改文件时，index 会生成新的文件信息和目录树，同时工作区增加或修改的文件内容被写入 objects 中的一个新的对象中。</li>
<li>当执行提交操作 <code>git commit</code> 的时候，index 中的目录树写入 objects 中，并生成一个提交信息，master 中写入这个提交信息，其中含有刚刚提交的目录树等信息。</li>
<li>当执行 <code>git reset HEAD</code> 命令时，index 中的目录树会被重写，被 master 中提交信息的目录树所替换，但工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，只从 index 中删除文件，工作区不受改变。</li>
<li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用 index 中全部或指定的文件替换工作区的文件。这个操作非常危险，会清除工作区中未添加到 index 的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向 master 分支中全部或者部分文件替换 index 以及工作区的文件。这个操作也是极具危险性的，因为不仅会清空工作区中为提交的改动，也会清楚暂存区中未提交的改动。</li>
</ul>
<h2 id="深入理解-git">深入理解 Git</h2>
<p>下面以实际的操作来更深刻地理解 Git：</p>
<ol type="1">
<li>首先生成一个目录 test 作为工作区，并初始化 git：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">test</span> </span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>可查看到初始化后的工作区有一个隐藏目录 .git，查看该目录的内容：</li>
</ol>
<p><img src="2022-05-30-22-48-10.png" /></p>
<p>查看 .git/config 文件，并配置身份信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/config</span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">$ git config user.name <span class="string">&quot;Cohanbb&quot;</span></span><br><span class="line">$ git config user.email <span class="string">&quot;cohanbb777@163.com&quot;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/config</span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">    name = Cohanbb</span><br><span class="line">    email = cohanbb777@163.com</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>新建一个文件 1.txt 添加内容『helloworld』，并使用 <code>git add 1.txt</code>，之后再次查看 .git 目录的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 1.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span> &gt; 1.txt</span><br><span class="line">$ <span class="built_in">cat</span> 1.txt</span><br><span class="line">helloworld</span><br><span class="line">$ git add 1.txt</span><br><span class="line"><span class="comment">#再次查看 .git 目录内容</span></span><br><span class="line">$ <span class="built_in">ls</span> -R .git</span><br></pre></td></tr></table></figure>
<p><img src="2022-05-30-23-08-01.png" /></p>
<p>发现与之前相比多了两个文件：</p>
<ul>
<li>index 文件</li>
<li>objects/31 目录以及目录下的文件 e0fce560e96c8b357f5b8630c7d8fbeb0a3ec8</li>
</ul>
<p>index 文件是暂存区，无法直接查看，objects/31 是新生成的对象，e0fce560e96c8b357f5b8630c7d8fbeb0a3ec8 是以哈希为名的文件，使用 <code>git cat-file -p</code> 可以读取该文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 31e0fce560e96c8b357f5b8630c7d8fbeb0a3ec8</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>在工作区新建文件文件 2.txt 添加内容『1234』，并使用 <code>git add 2.txt</code>，再次查看 .git 目录的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 2.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1234&quot;</span> &gt; 2.txt</span><br><span class="line">$ git add 2.txt</span><br><span class="line">$ <span class="built_in">ls</span> -R .git</span><br></pre></td></tr></table></figure>
<p><img src="16540518361014.jpg" /></p>
<p>发现 object 目录下生成了一个新的对象 81，使用 <code>git cat-file -p 81c545efebe5f57d4cab2ba9ec294c4b0cadf672</code> 进行读取得到 1234。</p>
<ol start="5" type="1">
<li>修改 1.txt 文件的内容，修改为 『1234』，并使用 <code>git add 1.txt</code>，再次查看 .git/objects 目录的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1234&quot;</span> &gt; 1.txt</span><br><span class="line">$ git add 1.txt</span><br><span class="line">$ <span class="built_in">ls</span> -R .git/objects</span><br></pre></td></tr></table></figure>
<p><img src="16540524299481.jpg" /></p>
<p>发现与之前没有任何该改变，故可知 objects 目录里的对象仅仅存储添加/修改的文件内容，与文件的名称无关。</p>
<p>直接查看 index 文件的内容，发现是乱码，但可看到刚刚创建的文件名 1.txt 和 2.txt：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/index</span><br><span class="line">DIRCb���</span><br><span class="line">        ��b���</span><br><span class="line">              ��~3�����E����&#125;L�+��)LK</span><br><span class="line">                                     ��r1.txtb��P<span class="string">&quot;_�b��P&quot;</span>_�~3�����E����&#125;L�+��)LK</span><br><span class="line">                   ��r2.txt0�8��?D.JN��</span><br><span class="line"></span><br><span class="line">                                       u���</span><br></pre></td></tr></table></figure>
<p>实际上 index 文件是虚拟的工作区，但仅仅是一个文件索引，包含了工作区的目录树，目录树上存储了各文件的文件名、文件的最终修改时间、文件的长度、文件的类型以及文件的哈希值。<br />
文件的具体内容并未存储在 index，而是存储在 objects 目录之中。objects 目录中除了 info 和 pack 其他的目录名称都是两个字符构成，这是因为文件的哈希值有 40 位，取前两位作为目录，后 38 位作为目录下的文件名。</p>
<p>在 objects 目录下，存有四种类型的哈希值：blob 型、tree 型、commit 型和 parent 型。</p>
<ul>
<li>blob 型用来存储添加/修改文件的内容</li>
<li>tree 型存储某个目录下的文件信息，包括文件名、文件权限、文件的哈希值</li>
<li>commit 型存储提交的信息</li>
<li>parent 型存储上一次提交产生的 commit</li>
</ul>
<p>到这里仍然觉得一头雾水，再做一个实验来深刻理解他们的运作过程：</p>
<ol type="1">
<li>在刚刚实验的基础上，使用 <code>git commit</code> 命令进行提交，并查看 objects 目录的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;1&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span> -R .git/objects</span><br></pre></td></tr></table></figure>
<p><img src="16540563672772.jpg" /></p>
<p>与之前向比多了哪些内容呢？多了两个新的对象：95 和 da，读取这两条哈希值的类型和内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 953ee820</span><br><span class="line">commit <span class="comment">#commit 型</span></span><br><span class="line">$ git cat-file -t dadc6837</span><br><span class="line">tree <span class="comment">#tree 型</span></span><br><span class="line">$ git cat-file -p 953ee820 </span><br><span class="line"><span class="comment">#commit 型的内容</span></span><br><span class="line">tree dadc6837ad6c06f0a9f21eb90a385f88338a97fa</span><br><span class="line">author Cohanbb &lt;cohanbb777@163.com&gt; 1654056297 +0000</span><br><span class="line">committer Cohanbb &lt;cohanbb777@163.com&gt; 1654056297 +0000</span><br><span class="line"></span><br><span class="line">1 </span><br><span class="line">$ git cat-file -p dadc6837</span><br><span class="line"><span class="comment">#tree 型的内容</span></span><br><span class="line">100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    1.txt</span><br><span class="line">100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    2.txt </span><br></pre></td></tr></table></figure>
<p>可看出 95 对象为 commit 型的哈希值，da 对象为 tree 型的哈希值，commit 里面存储了提交的目录树、作者和提交者的身份信息以及提交的名称。tree 里面存储了提交文件的权限、提交文件的哈希值及其类型、提交的文件名。</p>
<ol start="2" type="1">
<li>创建一个新的文件 3.txt 添加内容『1234』，并使用 <code>git add</code> 以及 <code>git commit</code> 提交：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 3.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1234&quot;</span> &gt; 3.txt</span><br><span class="line">$ git add 3.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="16540575293261.jpg" /></p>
<p>发现新增了 0b 和 93 两个新的对象，依然是读取他们的哈希类型和内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 0b8e2a12</span><br><span class="line">commit</span><br><span class="line">$ git cat-file -t 933c6a92</span><br><span class="line">tree</span><br><span class="line">$ git cat-file -p 0b8e2a12</span><br><span class="line">tree 933c6a92d63f610f450ca5f9fe6003e5b2427a1b</span><br><span class="line">parent 953ee8209f81a27af0bb13d6f8ae8cc1a878056f</span><br><span class="line">author Cohanbb &lt;cohanbb777@163.com&gt; 1654057402 +0000</span><br><span class="line">committer Cohanbb &lt;cohanbb777@163.com&gt; 1654057402 +0000</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">$ git cat-file -p 933c6a92</span><br><span class="line">100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    1.txt</span><br><span class="line">100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    2.txt</span><br><span class="line">100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    3.txt</span><br></pre></td></tr></table></figure>
<p>发现这次的 commit 与上一次有所不同，即多了一个 parent 项，观察发现这一项是上一次提交产生的 commit。tree 里面存储了三个文件的信息。</p>
<p>此时我们来查看一下 HEAD 的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/HEAD </span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>
<p>出现一个文件的路径，查看 refs/heads/master 文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/master</span><br><span class="line">0b8e2a12653a0600b8d0f3bf34d2b32c5218b5d9</span><br><span class="line">$ git cat-file -p 0b8e2a12</span><br><span class="line">tree 933c6a92d63f610f450ca5f9fe6003e5b2427a1b</span><br><span class="line">parent 953ee8209f81a27af0bb13d6f8ae8cc1a878056f</span><br><span class="line">author Cohanbb &lt;cohanbb777@163.com&gt; 1654057402 +0000</span><br><span class="line">committer Cohanbb &lt;cohanbb777@163.com&gt; 1654057402 +0000</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>发现 master 文件中存储着一个哈希值，正是刚刚提交所生成的 commit。</p>
<p><strong>总结</strong><br />
index 是工作区的一个文件索引，存储着各文件各版本的信息，但是并没有存放文件的具体内容，当执行 <code>git add</code> 操作，文件的具体内容被存放在 objects 中的 blob 对象中，当执行 <code>git commit</code> 操作，index 将目录树存入 objects 并生成了 commit 对象，HEAD 指向最后一次提交的分支，master 中存放刚生成的 commit 对象，包含 tree 对象、作者的身份信息等。</p>
<h1 id="git-常用命令">Git 常用命令</h1>
<h2 id="创建和克隆-git-仓库">创建和克隆 Git 仓库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">#初始化仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> &lt;repository&gt; <span class="comment">#克隆仓库到本地</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repository&gt; &lt;directory&gt; <span class="comment">#克隆仓库到指定目录下</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-git-1">配置 Git</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list <span class="comment">#列出 git 配置</span></span><br><span class="line">git config -e <span class="comment">#编辑 git 配置</span></span><br><span class="line">git config -e --global <span class="comment">#编辑全局 git 配置 </span></span><br></pre></td></tr></table></figure>
<h2 id="提交和修改">提交和修改</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;file1&gt; &lt;file2&gt; ... <span class="comment">#添加一个或者多个文件到暂存区</span></span><br><span class="line">git add &lt;<span class="built_in">dir</span>&gt; <span class="comment">#添加指定目录到缓存区</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment">#查看上次提交之后有无对文件进行再次的修改</span></span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; <span class="comment">#显示缓存区和工作区文件的差异</span></span><br><span class="line">git diff --cached &lt;file&gt; <span class="comment">#显示暂存区和上一次提交的差异</span></span><br><span class="line"></span><br><span class="line">git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt; <span class="comment">#提交暂存区的文件到仓库区</span></span><br><span class="line">git commit -a <span class="comment">#不需要 git add 直接提交</span></span><br><span class="line"></span><br><span class="line">git checkout -- &lt;file&gt; <span class="comment">#将文件从暂存区恢复到工作区</span></span><br><span class="line">git checkout HEAD &lt;file&gt; <span class="comment">#将文件从版本库恢复到暂存区和工作区</span></span><br><span class="line"></span><br><span class="line">git reset --mixed &lt;HEAD&gt; <span class="comment">#重置暂存区与上一次提交的保持一致</span></span><br><span class="line">git reset --soft &lt;HEAD&gt; <span class="comment">#退回到某个版本 </span></span><br><span class="line">git reset --hard &lt;HEAD&gt; <span class="comment">#撤销工作区所有未提交的修改内容，将暂存区和工作区都回到上一次的版本，并删除之前的所有信息提交</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">rm</span> -f &lt;file&gt; <span class="comment">#删除暂存区和工作区的文件</span></span><br><span class="line">git <span class="built_in">rm</span> --cached &lt;file&gt; <span class="comment">#仅仅删除暂存区的文件，工作区的文件仍然保留</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">mv</span> &lt;file&gt; &lt;newfile&gt; <span class="comment">#移动或重命名一个文件、目录或软链接</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#查看历史提交记录</span></span><br><span class="line">git blame &lt;file&gt; <span class="comment">#以列表的形式查看指定文件的修改历史</span></span><br><span class="line"></span><br><span class="line">git remote <span class="comment">#操作远程仓库</span></span><br><span class="line">git fetch <span class="comment"># 从远程仓库取代码库</span></span><br><span class="line">git pull <span class="comment">#下载远程代码并合并</span></span><br><span class="line">git push <span class="comment">#上传远程代码并合并</span></span><br></pre></td></tr></table></figure>
<h2 id="分支">分支</h2>
<p>每一种版本控制系统都支持分支，一个分支代表一条独立的开发线，使用分支意味着可以从开发主线上分离开，然后在不影响主线的同时继续工作。</p>
<p>Git 的分支即意味着与 master 分支提交的内容独立，在 master 分支提交的内容不会影响其他分支，在其他分支提交的内容也不会影响 master。</p>
<blockquote>
<p>注意：在任何分支进行提交操作之前，工作区的修改内容在任何分支都可见，一旦有任何分支进行提交操作，则其他分支回到上次提交操作后的状态。</p>
</blockquote>
<p>基本使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment"># 列出分支</span></span><br><span class="line">git branch &lt;branchname&gt; <span class="comment">#创建分支</span></span><br><span class="line">git checkout &lt;branchname&gt; <span class="comment">#切换分支</span></span><br><span class="line">git merge &lt;branchname&gt; <span class="comment">#合并分支</span></span><br><span class="line">git branch -d  &lt;branchname&gt; <span class="comment">#删除分支</span></span><br></pre></td></tr></table></figure>
<h1 id="github">GitHub</h1>
<p>GitHub 是基于 Git 的代码托管和版本控制平台，可以在上面创建仓库或项目。</p>
<p>首先需要注册一个 GitHub 账号，然后在本地创建 SSH KEY：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure>
<p>公钥在 ~/.ssh/id_rsa.pub 中，进入 GitHub 进入 account settings 选择 SSH Keys，Add SSH Key，添加在电脑上生成的公钥。添加后使用下面的命令验证是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>会弹出警告，输入 yes 就行了。然后在本地配置 Git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your email&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>在 GitHub 新建一个仓库（repositry），譬如 mycode，然后即可在本地进行远程仓库操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mycode <span class="comment">#创建本地仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> mycode</span><br><span class="line">$ git init</span><br><span class="line">$ <span class="built_in">touch</span> hello.md</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;this is mycode&quot;</span> &gt; hello.md</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;添加 hello.md&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后添加远程仓库的 SSH 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure>
<p>其中 yourName 是 GitHub 的用户名 yourRepo 是要上传的 GitHub 仓库名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push <span class="comment">#提交给远程仓库</span></span><br><span class="line">$ git pull <span class="comment">#从远程仓库获取代码并与本地的代码库合并</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，GitHub 的默认主分支的名称不再是 master 而是 main，故最好将 Git 的默认主分支名称也改为 main：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure>
<p>其他操作并不影响，上述与 master 有关的所有内容都替换 main 即可。</p>
<h1 id="参考文献">参考文献</h1>
<ul>
<li>菜鸟教程. Git 教程[EB/OL]. <a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li>
<li>菜鸟教程. Github 简明教程[EB/OL]. <a href="https://www.runoob.com/w3cnote/git-guide.html">https://www.runoob.com/w3cnote/git-guide.html</a></li>
<li>VGtime. Git基本原理介绍[EB/OL]. <a href="https://blog.csdn.net/JKR10000/article/details/110453547">https://blog.csdn.net/JKR10000/article/details/110453547</a></li>
<li>raoxiaoya. git深入理解(一)：暂存区(Stage)，索引(index)[EB/OL]. <a href="https://blog.csdn.net/raoxiaoya/article/details/110824019">https://blog.csdn.net/raoxiaoya/article/details/110824019</a></li>
</ul>
]]></content>
      <categories>
        <category>Efficient Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 与 CSS</title>
    <url>/2022/05/16/HTML%20%E4%B8%8E%20CSS/</url>
    <content><![CDATA[<p>前端 HTML 与 CSS 的基础知识整理。<br />
内容包括：<br />
1.HTML 常用标签及其用法<br />
2.CSS 常用属性及其描述</p>
<h1 id="摘要">摘要</h1>
<p>一个 Web 页面是如何在浏览器上展示的？我们在浏览器上查看网页源代码，可看到众多的标签、符号和文字，这就是一个 HTML 文件，而浏览器可以将这个文件解析成一个 Web 页面。一个 Web 页面如何设计样式、呈现出精美的视觉效果？则需要通过 CSS 对 HTML 进行加工美化。</p>
<hr>
<span id="more"></span>
<p><strong>文章索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#html">HTML</a>
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#基本架构">基本架构</a></li>
<li><a href="#html-标签">HTML 标签</a>
<ul>
<li><a href="#基本标签">基本标签</a></li>
<li><a href="#文本格式化">文本格式化</a></li>
<li><a href="#特殊标签">特殊标签</a></li>
</ul></li>
</ul></li>
<li><a href="#css">CSS</a>
<ul>
<li><a href="#简介-1">简介</a></li>
<li><a href="#css-语法">CSS 语法</a>
<ul>
<li><a href="#基本形式">基本形式</a></li>
<li><a href="#文本属性">文本属性</a></li>
<li><a href="#结构属性">结构属性</a></li>
</ul></li>
</ul></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
<!-- /code_chunk_output -->
<hr>
<h1 id="html">HTML</h1>
<h2 id="简介">简介</h2>
<p>HTML (HyperText Markup Language) <strong>超文本标记语言</strong>，何谓超文本？简单来说，超文本指具有超链接功能的文本，即一个超文本可以由若干个超链接构成，最常见的应用场景便是 Web 页面，也用于其他领域，譬如 Markdown 文档是基于 HTML 简化而来。</p>
<h2 id="基本架构">基本架构</h2>
<p><code>&lt;html&gt;</code> 标签：表明是一个 HTML 文档。<br />
<code>&lt;title&gt;</code> 标签：定义文档的标题。<br />
<code>&lt;body&gt;</code> 标签：定义文档的内容主体。<br />
<code>&lt;p&gt;</code> 标签：定义一个段落。<br />
<code>&lt;br /&gt;</code> 标签：换行标签。</p>
<p><strong>注：莫要忘记加上结束标签！</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            Hello World!<span class="tag">&lt;<span class="name">br</span> /&gt;</span>Hello Web! </span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码在浏览器中的效果：</p>
<html>
<title>
demo
</title>
<body>
<p>
Hello World!<br />Hello Web!
</p>
</body>
</html>
<h2 id="html-标签">HTML 标签</h2>
<h3 id="基本标签">基本标签</h3>
<p><code>&lt;html&gt;</code> 标签：表示是一个 HTML 文档。<br />
<code>&lt;title&gt;</code> 标签：定义文档的标题。<br />
<code>&lt;body&gt;</code> 标签：定义文档的内容主体。<br />
<code>&lt;p&gt;</code> 标签：定义一个段落。<br />
<code>&lt;br /&gt;</code> 标签：表示换行。<br />
<code>&lt;h&gt;</code> 标签：定义文本中的标题。<br />
<code>&lt;hr&gt;</code> 标签：表示一条水平分割线。<br />
<code>&lt;!-- --&gt;</code> 标签：定义注释。</p>
<h3 id="文本格式化">文本格式化</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调文字<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>小号文字<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加重视觉效果<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>上标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span>下标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>插入字<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>删除字<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码解析后为：</p>
<p><b>粗体</b><br /> <i>斜体</i><br /> <em>强调文字</em><br /> <small>小号文字</small><br /> <strong>加重视觉效果</strong><br /> <sub>上标</sub><br /> <sup>下标</sup><br /> <ins>插入字</ins><br /> <del>删除字</del><br /></p>
<h3 id="特殊标签">特殊标签</h3>
<p><strong>链接</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://cohanbb.github.io/&quot;</span>&gt;</span>这是一条链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://cohanbb.github.io/">这是一条链接</a></p>
<p><strong>图像</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i-1-lanrentuku.52tup.com/2020/7/10/b87c8e05-344a-48d1-869f-ef6929fc8b17.jpg?imageView2/2/w/1024/&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片加载失败&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-1-lanrentuku.52tup.com/2020/7/10/b87c8e05-344a-48d1-869f-ef6929fc8b17.jpg?imageView2/2/w/1024/" alt="图片加载失败" width="300" height="300"/></p>
<p><strong>预格式文本</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    预格式文本</span><br><span class="line">        文本会保留换行和空格</span><br><span class="line">            文本换为等线体，常用于表示代码块</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre>
    预格式文本
        文本会保留换行和空格
            文本换为等线体，常用于表示代码块
</pre>
<p><strong>代码和代码块</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>printf(&#x27;代码&#x27;)<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">code</span>&gt;</span>printf(&#x27;代码块&#x27;);<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">code</span>&gt;</span>return;<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>printf('代码')</code></p>
<pre>
    <code>printf('代码块');</code>
    <code>return;</code>
</pre>
<p><strong>表格</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table border="1">
<tr>
<th>
标题1
</th>
<th>
标题2
</th>
</tr>
<tr>
<td>
row 1, cell 1
</td>
<td>
row 1, cell 2
</td>
</tr>
<tr>
<td>
row 2, cell 1
</td>
<td>
row 2, cell 2
</td>
</tr>
</table>
<p><strong>列表</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>NO<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>no<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">自定义列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>NO<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>no<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
有序列表
<ol>
<li>
YES
</li>
<li>
NO
</li>
</ol>
无序列表
<ul>
<li>
yes
</li>
<li>
no
</li>
</ul>
自定义列表
<dl>
<dt>
YES
</dt>
<dd>
yes
</dd>
<dt>
NO
</dt>
<dd>
no
</dd>
</dl>
<p><strong>引用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> </span><br><span class="line">    一级引用</span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        二级引用</span><br><span class="line">    <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
一级引用
<blockquote>
二级引用
</blockquote>
</blockquote>
<p><strong>块级元素和内联元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">块级元素<span class="tag">&lt;<span class="name">br</span> /&gt;</span>从新的一行出现以及结束</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2.这是一个<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">内联元素，不会以新行开始</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
1.这是一个
<div>
<p>块级元素<br />从新的一行出现以及结束</p>
</div>
<p>2.这是一个<span> 内联元素，不会以新行开始 </span></p>
<p><strong>表单</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get or post&quot;</span>&gt;</span></span><br><span class="line">    username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    单选框<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span> /&gt;</span>    </span><br><span class="line">    复选框<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    提交表单<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<form action="URL" method="get or post">
username: <input type="text" name="username"><br /> password: <input type="password" name="password"><br /> 单选框<br /> <input type="radio" name="sex" value="male">男<br /> <input type="radio" name="sex" value="female">女<br /><br />
复选框<br /> <input type="checkbox" name="number" value="1">1<br /> <input type="checkbox" name="number" value="2">2<br /> 提交表单<br /> <input type="submit" value="submit"/>
</form>
<p><strong>脚本</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    script code, such <span class="keyword">as</span> <span class="title class_">JavaScript</span>.</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>样式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    css <span class="selector-tag">code</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="css">CSS</h1>
<h2 id="简介-1">简介</h2>
<p>CSS(Cascading Style Sheets) 层叠样式表，用以定义 HTML 中元素的样式，HTML 使用 CSS 的方式有三种： 1. 内联样式：在 HTML 元素标签中使用 "style" 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;font-family:consolas;&quot;</span>&gt;</span></span><br><span class="line">    inline</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>内部样式表：在 HTML 文档 <code>&lt;header&gt;</code> 区域使用 <code>&lt;style&gt;</code> 包含 CSS。</p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    CSS <span class="selector-tag">code</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>外部引用：使用外部 CSS 文件定义样式。</p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="css-语法">CSS 语法</h2>
<h3 id="基本形式">基本形式</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[选择器]</span> &#123;</span><br><span class="line">    <span class="selector-attr">[属性]</span>: [描述];</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择器可以是 HTML 标签，也可以是 id 或 class</p>
<ul>
<li>id 选择器只能定义标有特定 id 的元素的样式，形式为 <code>#[id]</code>。</li>
<li>class 选择器可以定义一类元素的样式，形式为 <code>.[class]</code>。</li>
</ul>
<h3 id="文本属性">文本属性</h3>
<p><strong>background</strong></p>
<ul>
<li><p>background-color:</p>
<blockquote>
<p>三种定义方式：RGB "rgb(x,x,x)"，十六进制 "#H H H"， name "black"。</p>
</blockquote></li>
<li><p>background-image:</p>
<blockquote>
<p>url('pic-url')</p>
</blockquote></li>
<li><p>background-repeat：背景图像在哪个方向重复。</p>
<blockquote>
<p>repeat, repeats-x, repeat-y, no-repeat</p>
</blockquote></li>
<li>background-attachment：背景图像是否跟随页面滚动。</li>
<li><p>background-position：背景图像的位置。</p></li>
</ul>
<p><strong>text</strong></p>
<ul>
<li>color：文本颜色。</li>
<li>direction：文本方向。</li>
<li>letter-spacing：字符间隔。</li>
<li>word-spacing：单词间隔。</li>
<li>line-height：行高。</li>
<li><p>text-align：对齐方式。</p>
<blockquote>
<p>left, right, center, justify, inherit</p>
</blockquote></li>
<li>text-indent：首行缩紧。</li>
<li>text-shadow：文本阴影。</li>
<li>text-decoration：文本画线修饰。</li>
<li><p>white-space：空白元素的处理方式。</p>
<blockquote>
<p>默认 normal，即空白元素会被浏览器忽略。<br />
nowrap 文本不会换行，一直到 <code>&lt;br&gt;</code> 标签。<br />
pre 保留空白，pre-wrap 保留空白，但是正常换行。<br />
pre-line 合并空白元素，但是保留一个空格，正常换行。</p>
</blockquote></li>
<li>word-wrap：单词的换行方式，一般用 break-word。</li>
<li><p>word-break：是否允许单词内断开，若用 break-all，则会在单词内部断开。</p></li>
</ul>
<p><strong>font</strong></p>
<ul>
<li><p>font-family：</p>
<table>
<thead>
<tr class="header">
<th>说明</th>
<th>Generic-family</th>
<th>特定系列</th>
<th>具体字体</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>有衬线体</td>
<td>Serif</td>
<td>Times, Georgia</td>
<td>"Times New Roman", "Geogria", "宋体", "仿宋"</td>
</tr>
<tr class="even">
<td>无衬线体</td>
<td>Sans-serif</td>
<td>Sans-serif</td>
<td>"Arial", "Helvetica", Verdana", "黑体" 等</td>
</tr>
<tr class="odd">
<td>等宽体</td>
<td>Monospace</td>
<td>Consolas</td>
<td>"Courier", "Courier New", "Lucinda Console"等</td>
</tr>
</tbody>
</table></li>
<li><p>font-size：</p>
<blockquote>
CSS 中表示字体大小有多种形式：
<ol type="1">
<li>px 像素值。</li>
<li>pt 磅(= 0.75px)。</li>
<li>em 相对父元素的大小。</li>
<li>rem 相对于 html 标签中 font-size 的大小，默认 1rem = 16px。</li>
<li>percentage 同 em。</li>
<li>使用绝对大小和相对大小值。</li>
</ol>
</blockquote></li>
<li>font-style：斜体样式。</li>
<li><p>font-weight：字体粗细。</p></li>
</ul>
<p><strong>链接</strong></p>
<ul>
<li>a:link：未访问过的链接。</li>
<li>a:visited：已访问过的链接。</li>
<li>a:hover：鼠标放置的链接。</li>
<li>a:active：鼠标点击的链接。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> or visited or hover or active &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:; <span class="comment">/* 链接背景颜色 */</span></span><br><span class="line">    <span class="attribute">color</span>:; <span class="comment">/* 链接字体颜色 */</span></span><br><span class="line">    <span class="attribute">text-decoration</span>:; <span class="comment">/* 链接文本画线修饰 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构属性">结构属性</h3>
<p><strong>盒子模型</strong><br />
所有的 HTML 元素都可以看成一个盒子模型，包括外边距（margin）、边框（border）、内边距（padding）、内容（content），内容指的是文本或图像等。</p>
<p><img src="https://www.runoob.com/images/box-model.gif" /></p>
<p><strong>margin</strong></p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>说明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>margin-top</td>
<td>上边距</td>
<td>auto, length, percentage</td>
</tr>
<tr class="even">
<td>margin-right</td>
<td>右边距</td>
<td>auto, length, percentage</td>
</tr>
<tr class="odd">
<td>margin-bottom</td>
<td>下边距</td>
<td>auto, length, percentage</td>
</tr>
<tr class="even">
<td>margin-left</td>
<td>左边距</td>
<td>auto, length, percentage</td>
</tr>
<tr class="odd">
<td>margin</td>
<td>以上四个可简写为 margin</td>
<td>按个数 4，3，2，1 依次表示：<br /> 上，右，下，左；上，左右，下；上下，左右；全部外边距。</td>
</tr>
</tbody>
</table>
<p><strong>border</strong></p>
<ul>
<li><p>border-width：边框的宽度。</p>
<blockquote>
<ol type="1">
<li>可以用 thin, medium, thick, length, inherit 表示。</li>
<li>按个数 4，3，2，1 依次表示：上，右，下，左；上，左右，下；上下，左右；全部边框的宽度。</li>
</ol>
</blockquote></li>
<li><p>border-color：边框的颜色。</p>
<blockquote>
<ol type="1">
<li>RGB 十六进制 name 三种表示法。</li>
<li>按个数 4，3，2，1 依次表示：上，右，下，左；上，左右，下；上下，左右；全部边框的颜色。</li>
</ol>
</blockquote></li>
<li><p>border-style：边框的风格。</p>
<blockquote>
<ol type="1">
<li>无边框 none，点线边框 dotted，虚线边框 dashed，实线边框 solid，两个实线边框 double，3D沟槽边框 groove，3D脊边框 ridge，3D嵌入边框 inset，3D突出边框 outset。</li>
<li>按个数 4，3，2，1 依次表示： 上，右，下，左；上，左右，下；上下，左右；全部边框的风格。</li>
</ol>
</blockquote></li>
<li><p>border-[none/top/right/bottom/left]：以上三个简写。</p>
<blockquote>
<p>参数依次为：[width],[style],[color]</p>
</blockquote></li>
<li><p>border-radius：设置圆角边框。</p>
<blockquote>
<p>length 或 percentage。</p>
</blockquote></li>
<li><p>border-[top/right/bottom/left]-[width/style/color]：设置某一边的某一个属性。</p></li>
</ul>
<p><strong>padding</strong><br />
使用方法与 margin 类似。</p>
<p><strong>display</strong><br />
典型的块元素：<code>&lt;p&gt;</code> <code>&lt;div&gt;</code> <code>&lt;pre&gt;</code> <code>&lt;h&gt;</code>，典型的内联元素：<code>&lt;a&gt;</code> <code>&lt;span&gt;</code> <code>&lt;code&gt;</code>，display 可以更改元素的显示方式。</p>
<ul>
<li>inline： 内联元素。</li>
<li>block：块元素。</li>
</ul>
<p><strong>overflow</strong></p>
<ul>
<li>visible：默认值，超出的内容会呈现在边框外面。</li>
<li>hidden：溢出内容被修剪，且被隐藏。</li>
<li>scroll：溢出内容被修剪，显示滚动条。</li>
<li>auto：浏览器根据情况自动添加滚动条。</li>
<li>inherit：继承父元素的 overflow 属性值。</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<ul>
<li>菜鸟教程. HTML 教程[EB/OL]. <a href="https://www.runoob.com/html/html-tutorial.html">https://www.runoob.com/html/html-tutorial.html</a></li>
<li>菜鸟教程. CSS 教程[EB/OL]. <a href="https://www.runoob.com/css/css-tutorial.html">https://www.runoob.com/css/css-tutorial.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>Web 前端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP_A Fundamental Perspective</title>
    <url>/2022/05/10/PHP/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>PHP (Hypertext Preprocessor) 超文本预处理器，一种开源的、一般运行在服务器上的开源脚本语言，具有跨平台性、与几乎所有 Web 服务器兼容、与大量的数据库兼容。<br />
PHP 属于类 C 语言，解释器也使用 C 语言编写，大部分语法与 C 语言相通，如果有良好的 C 语言的基础，可以快速地入门 PHP。<br />
PHP 文件可以包含 PHP 代码、HTML 和 JavaScript 代码，在服务端执行，与数据库进行交互后生成 HTML 文件通过 Web 服务器返回给浏览器。</p>
<hr>
<span id="more"></span>
<p><strong>本文索引</strong></p>
<ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#基本形式">基本形式</a></li>
<li><a href="#php-基础语法">PHP 基础语法</a>
<ul>
<li><a href="#常变量和数据类型">常变量和数据类型</a>
<ul>
<li><a href="#php-数据类型">PHP 数据类型</a></li>
<li><a href="#php-常量">PHP 常量</a></li>
<li><a href="#php-变量及全局变量">PHP 变量及全局变量</a></li>
<li><a href="#php-字符串">PHP 字符串</a></li>
<li><a href="#php-数组">PHP 数组</a></li>
</ul></li>
<li><a href="#语句">语句</a>
<ul>
<li><a href="#选择语句">选择语句</a></li>
<li><a href="#循环语句">循环语句</a></li>
</ul></li>
<li><a href="#函数">函数</a></li>
</ul></li>
<li><a href="#php-进阶">PHP 进阶</a>
<ul>
<li><a href="#php-面向对象">PHP 面向对象</a></li>
<li><a href="#php-http">PHP HTTP</a>
<ul>
<li><a href="#http">HTTP</a></li>
<li><a href="#get-和-post">GET 和 POST</a></li>
<li><a href="#cookie-和-session">Cookie 和 Session</a></li>
</ul></li>
<li><a href="#php-操作数据库">PHP 操作数据库</a></li>
<li><a href="#php-文件包含">PHP 文件包含</a></li>
<li><a href="#php-文件读写">PHP 文件读写</a></li>
<li><a href="#php-文件上传">PHP 文件上传</a></li>
<li><a href="#php-命令执行">PHP 命令执行</a></li>
<li><a href="#php-过滤器">PHP 过滤器</a></li>
</ul></li>
</ul>
<hr>
<h1 id="基本形式">基本形式</h1>
<p>一个 PHP 文件通常包含 HTML 和 PHP 脚本，基本形式为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="php-基础语法">PHP 基础语法</h1>
<h2 id="常变量和数据类型">常变量和数据类型</h2>
<h3 id="php-数据类型">PHP 数据类型</h3>
<p>与 C/C++、Java、C#、Go 甚至 Python 这些强类型语言不同，PHP 是一种弱类型语言，PHP 有 8 种数据类型：</p>
<ul>
<li>Integer：整数型</li>
<li>Float：浮点数型</li>
<li>String：字符串型</li>
<li>Boolean：布尔型</li>
<li>Array：数组</li>
<li>Object：对象</li>
<li>Null：空</li>
<li>Resource：资源型</li>
</ul>
<p>各种变量的定义方式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 整型 */</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 浮点型 */</span></span><br><span class="line">    <span class="variable">$b1</span> = <span class="number">1.1</span>;</span><br><span class="line">    <span class="variable">$b2</span> = <span class="number">9.9e-10</span>;</span><br><span class="line">    <span class="variable">$b3</span> = <span class="number">5E-10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 字符串 */</span></span><br><span class="line">    <span class="variable">$c</span> = <span class="string">&quot;PHP&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* bool 型 */</span></span><br><span class="line">    <span class="variable">$d1</span> = <span class="literal">TRUE</span>;</span><br><span class="line">    <span class="variable">$d2</span> = <span class="literal">FALSE</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 数组 */</span></span><br><span class="line">    <span class="variable">$e</span> = <span class="keyword">array</span>(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 类与对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$f</span> = <span class="keyword">new</span> F;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Null */</span></span><br><span class="line">    <span class="variable">$g</span> = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* resource 型 */</span></span><br><span class="line">    <span class="variable">$h1</span> = <span class="title function_ invoke__">mysqli_connect</span>(...);</span><br><span class="line">    <span class="variable">$h2</span> = <span class="title function_ invoke__">fopen</span>(...);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 PHP 是弱类型语言，故 PHP 有两种比较方式：</p>
<ul>
<li>松散比较：使用两个等号 <code>==</code> 进行比较，只比较值，不比较数据类型。</li>
<li>严格比较：使用三个等号 <code>===</code> 进行比较，既比较值，又比较数据类型。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">TRUE</span> == <span class="string">&quot;TRUE&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;相等1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">TRUE</span> === <span class="string">&quot;TRUE&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;相等2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将输出：相等1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="php-常量">PHP 常量</h3>
<p>PHP 常量的定义需要使用 <code>define()</code> 函数，函数用法为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* $name 为常量名，$value 为常量值，$case_insensitive 表示常量名是否大小写不敏感 */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="title function_ invoke__">define</span>(<span class="keyword">string</span> <span class="variable">$name</span>, <span class="keyword">mixed</span> <span class="variable">$value</span> [, <span class="keyword">bool</span> <span class="variable">$case_insensitive</span> = <span class="literal">false</span>])</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">define</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="literal">TRUE</span>);</span><br><span class="line">    <span class="keyword">echo</span> a;</span><br><span class="line">    <span class="keyword">echo</span> A; </span><br><span class="line">    <span class="comment">// 将输出两次 123</span></span><br><span class="line">    <span class="comment">// 若没有设置为大小写不敏感，则 echo a 将报错</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="php-变量及全局变量">PHP 变量及全局变量</h3>
<p>PHP 一个变量需要在变量名前加上符号 <code>$</code>，变量名是区分大小写的，例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$x</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="variable">$y</span> = <span class="number">7.7</span>;</span><br><span class="line">    <span class="variable">$zz</span> = <span class="string">&quot;Hello PHP!&quot;</span>;</span><br><span class="line">    <span class="variable">$ZZ</span> = <span class="string">&quot;Hi PHP!&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PHP 在局部使用全局变量：</p>
<ol type="1">
<li><p>使用 global 关键字声明全局变量，如：</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Maxab</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$a</span>, <span class="variable">$b</span>;  <span class="comment">// 声明使用全局变量 a 和 b</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span> &gt;= <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$a</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$b</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>使用 <code>$GLOBALS</code> 超级全局变量数组直接调用变量，如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Maxab</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$GLOBALS</span>[<span class="string">&quot;a&quot;</span>] &gt;= <span class="variable">$GLOBALS</span>[<span class="string">&quot;b&quot;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$GLOBALS</span>[<span class="string">&quot;a&quot;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$GLOBALS</span>[<span class="string">&quot;b&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>$GLOBALS</code> 是包含了全部变量的数组，除了 <code>$GLOBALS</code> 之外，PHP 还有几个超级全局变量：</p>
<ol type="1">
<li><code>$_SERVER</code>：存储服务器信息和执行环境。</li>
<li><code>$_REQUEST</code>：收集 HTML 表单提交的数据，包括 get 和 post 方式提交的数据以及 cookie。</li>
<li><code>$_POST</code>：收集 HTML 表单使用 post 方式提交的数据。</li>
<li><code>$_GET</code>：收集 HTML 表单使用 get 方式提交的数据，或 URL 提交的数据。</li>
<li><code>$_FILES</code>：存储上传文件的信息。</li>
<li><code>$_ENV</code>：存储服务器的环境变量。</li>
<li><code>$_COOKIE</code>：存储 cookie 信息。</li>
<li><code>$_SESSION</code>：存储 session 信息。</li>
</ol>
<h3 id="php-字符串">PHP 字符串</h3>
<p>PHP 中需掌握三种字符串操作：</p>
<ol type="1">
<li><p>并置运算符 <code>.</code> 用于连接两个字符串，如：</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$str1</span> = <span class="string">&quot;Hel&quot;</span>;</span><br><span class="line">    <span class="variable">$str2</span> = <span class="string">&quot;leo&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$str1</span> . <span class="variable">$str2</span>; <span class="comment">// 将输出 Hello</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><code>strlen()</code> 函数，同 C 语言，返回字符串的长度。</li>
<li><p><code>strpos()</code> 函数，在字符串内查找一段文本，若查找到会返回该文本第一次出现的位置，若未查找到则返回 <code>FALSE</code>，如： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">strpos</span>(<span class="string">&quot;Hello Hello&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>字符串既可以用单引号也可以用双引号，二者的主要区别：</p>
<ol type="1">
<li>双引号可以解释变量，单引号不解释变量。</li>
<li>单引号的解析速度更快。</li>
</ol>
<h3 id="php-数组">PHP 数组</h3>
<p>PHP 中数组类型：</p>
<ol type="1">
<li>数值数组：带有数字键值的数组，键值为从 0 开始的数字。</li>
<li>关联数组：自定义键值的数组。</li>
<li>多维数组：多维度的数组。</li>
</ol>
<p>定义方式如下：</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">     <span class="comment">/* 数值数组 */</span></span><br><span class="line">     <span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">     <span class="keyword">echo</span> a[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">echo</span> a[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">echo</span> a[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">foreach</span> (<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">         <span class="keyword">echo</span> <span class="variable">$value</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关联数组 */</span></span><br><span class="line">    <span class="variable">$b</span> = <span class="keyword">array</span>(<span class="string">&quot;a&quot;</span> =&gt; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;b&quot;</span> =&gt; <span class="string">&quot;2&quot;</span>, <span class="string">&quot;c&quot;</span> =&gt; <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> b[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">echo</span> b[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">    <span class="keyword">echo</span> b[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$b</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$x_value</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$x</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$x_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 多维数组 */</span></span><br><span class="line">    <span class="variable">$c</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&quot;c1&quot;</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="keyword">array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>),</span><br><span class="line">            <span class="keyword">array</span>(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;c2&quot;</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="keyword">array</span>(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>),</span><br><span class="line">            <span class="keyword">array</span>(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;12&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>常用函数：</p>
<ul>
<li><code>count()</code>：可以返回数组的长度。</li>
<li><code>sort()</code>：进行升序排序。</li>
<li><code>rsort()</code>：进行降序排序。</li>
<li><code>asort()</code>：根据关联值进行升序排序。</li>
<li><code>ksort()</code>：根据关联键值进行升序排序。</li>
<li><code>arsort()</code>：根据关联值进行降序排序。</li>
<li><code>krsort()</code>：根据关联键值进行降序排序。</li>
</ul>
<h2 id="语句">语句</h2>
<h3 id="选择语句">选择语句</h3>
<p>PHP 中的选择语句与 C 语言完全相同，使用 <code>if-else</code> 语句或 <code>switch-case</code> 语句。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* if-else 语句 */</span></span><br><span class="line">    <span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * ......</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* switch-case 语句 */</span></span><br><span class="line">    <span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">        <span class="keyword">case</span> value1: </span><br><span class="line">            statement</span><br><span class="line">        <span class="keyword">case</span> value2: </span><br><span class="line">            statement</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * ...... </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 遇到 break 才会终止</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            statement</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<p>PHP 中的循环语句在 C 语言提供的 <code>while</code>、<code>do while</code>、<code>for</code> 的基础上又提供了一种 <code>foreach</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* while 型 */</span></span><br><span class="line">    <span class="keyword">while</span> (condition) &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do-while 型 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125; <span class="keyword">while</span> (condition)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for 型 */</span></span><br><span class="line">    <span class="keyword">for</span> (initializing; condition; addition) &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* foreach 型用于遍历数组 */</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">array</span> (<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$value</span>;</span><br><span class="line">    &#125;   <span class="comment">// 将输出 123</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<p>PHP 内建了大量的函数，功能强大，在下文会列举几个关键函数。</p>
<p>PHP 是脚本语言，直接由 PHP 解释器解释执行，不需要进行编译，故函数可以在代码中的任意位置定义，不需要在调用前进行声明，函数的定义方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">function_identifier</span>(<span class="params">parameter_list</span>) </span>&#123;</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">return</span> ... ;    <span class="comment">// 返回值    </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="php-进阶">PHP 进阶</h1>
<h2 id="php-面向对象">PHP 面向对象</h2>
<p>PHP 面向对象的使用方法与 C++ 类似：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">php_class</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 成员变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var1</span>;</span><br><span class="line">    <span class="comment">// var $var1;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$var2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$var3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span>, <span class="variable">$par2</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;var1 = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;var2 = <span class="variable">$par2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 析构函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;销毁对象&quot;</span> . this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 成员函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"><span class="variable">$par</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$par</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明对象 */</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">php_class</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用成员函数 */</span></span><br><span class="line"><span class="variable">$obj</span> -&gt; <span class="title function_ invoke__">fun</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继承 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child_class</span> <span class="keyword">extends</span> <span class="title">php_class</span> </span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接口 */</span></span><br><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">parameter_list</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">parameter_list</span>) </span>&#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象类 */</span></span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">parameter_list</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">parameter_list</span>) </span>&#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php-http">PHP HTTP</h2>
<h3 id="http">HTTP</h3>
<p>使用 <code>header()</code> 函数向浏览器发送 HTTP 报头，函数原型为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * string 表示要发送的报头字符串</span></span><br><span class="line"><span class="comment">     * replace 表示是否代替原来的报头，默认 TRUE</span></span><br><span class="line"><span class="comment">     * http_response_code 可选，表示把 HTTP 响应强制为指定的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="keyword">string</span>, replace, http_response_code)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如想要在新的页面定向到某个 URL：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: https://cohanbb.github.io/&quot;</span>, <span class="literal">FALSE</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="get-和-post">GET 和 POST</h3>
<p><code>$_GET[]</code> 和 <code>$_POST[]</code> 两个数组分别用来收集 HTML 使用 get 和 post 方式提交的数据。</p>
<p>例如想要收集 get 方式提交的数据 DEMO:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo.php */</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;demo.php&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;DEMO&quot;</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$demo</span> = <span class="variable">$_GET</span>[<span class="string">&quot;DEMO&quot;</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$demo</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="cookie-和-session">Cookie 和 Session</h3>
<p>何谓 Cookie？</p>
<blockquote>
<p>cookie 常用于识别用户，cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。</p>
</blockquote>
<p>PHP 使用 <code>setcookie()</code> 函数设置 cookie：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 函数原型 */</span></span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(name, value, expire, path, domain);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置 cookie 并于 3600 秒后过期 */</span></span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;Cohanbb&quot;</span>, <span class="title function_ invoke__">time</span>() + <span class="number">3600</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>$_COOKIE_</code> 存储设置的 cookie 值：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&quot;user&quot;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>删除 cookie：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 将时间设为过去的时间即可删除 cookie */</span></span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">time</span>() - <span class="number">1</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>何谓 Session？</p>
<blockquote>
<p>在计算机上操作某个应用程序时，打开它、做些更改、关闭它，这很像一次对话。你所操作的计算机知道你是谁，它清楚你在何时打开和关闭应用程序。然而由于 HTTP 地址无法保持状态，Web 服务器并不知道你是谁以及你做了什么。<br />
session 解决了这个问题，它通过在服务器上存储用户信息以便随后使用（比如用户名称、购买商品等）。会话信息是临时的，在用户离开网站后将被删除。如果需要永久存储信息，可以把数据存储在数据库中。<br />
session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。</p>
</blockquote>
<p>PHP 操作 session：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 session */</span></span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Cohanbb&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取 session */</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_SESSION</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 清空 session */</span></span><br><span class="line">    <span class="title function_ invoke__">session_unset</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 销毁 session */</span></span><br><span class="line">    <span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php-操作数据库">PHP 操作数据库</h2>
<p>PHP 通过 <code>MySQLi</code> 或 <code>PDO</code> 连接和操作数据库，<code>PDO</code> 可以应用在12种不同的数据库，<code>MySQLi</code> 只能应用在 MySQL 数据库，在此仅演示 <code>MySQLi</code>。</p>
<p><code>MySQLi</code> 可以面向过程也可以面向对象，写法上有一些差异。</p>
<p><strong>连接数据库</strong><br />
使用 <code>mysqli_connect()</code> 函数连接数据库，或面向对象：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 面向过程*/</span></span><br><span class="line">    <span class="variable">$conn</span> = my <span class="title function_ invoke__">sqli_connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;数据库连接失败：&quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接成功&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 面向对象 */</span></span><br><span class="line">    <span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title class_">mysqli</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_error) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;数据库连接失败：&quot;</span> . <span class="variable">$conn</span>-&gt;connect_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接成功&quot;</span>;</span><br><span class="line">    <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 SQL 语句</strong><br />
使用 <code>mysqli_query()</code> 函数连接 SQL 语句，或面向对象：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 面向过程 */</span></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 面向对象 */</span></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>其他常用函数</strong></p>
<ul>
<li>使用 <code>mysqli_error()</code> 函数返回最近调用函数的最后一个错误的描述。</li>
<li>使用 <code>mysqli_errno()</code> 函数返回最近调用函数的最后一个错误代码。</li>
<li>使用 <code>mysqli_affected_rows()</code> 函数返回上一个 SQL 语句影响的行。<br />
</li>
<li>使用 <code>mysqli_real_escape_string()</code> 函数转义 SQL 语句中的特殊字符，可用于防注入。<br />
</li>
<li><p>使用 <code>mysqli_fetch_xxx()</code> 函数从查询结构中返回一些数据：</p>
<ul>
<li><code>mysqli_fetch_all()</code> 从结果集中取得所有行作为关联/数值数组<br />
</li>
<li><code>mysqli_fetch_array()</code> 从结果集中取得一行作为关联/数值数组<br />
</li>
<li><code>mysqli_fetch_assoc()</code> 从结果中取得一行作为关联数组<br />
</li>
<li><code>mysqli_fetch_object()</code> 从结果中取得一行作为对象</li>
</ul></li>
</ul>
<h2 id="php-文件包含">PHP 文件包含</h2>
<p>PHP 有四种文件包含方式：</p>
<ul>
<li><code>include</code></li>
<li><code>include_once</code></li>
<li><code>require</code></li>
<li><code>require_once</code></li>
</ul>
<p>其中 <code>include</code> 和 <code>require</code> 的区别是，二者处理错误的方式不同，前者生成一个警告，出错后脚本继续执行，后者生成一个致命错误，脚本停止执行。<br />
后面带上 <code>_once</code> 的作用是如果之前已经包含了该文件，则不会再次包含，即防止多次包含同一个文件。</p>
<p>常用文件包含语句：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 普通方式包含 */</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;file.php&quot;</span>;</span><br><span class="line">    <span class="keyword">require</span> <span class="string">&quot;file.php&quot;</span>;</span><br><span class="line">    <span class="keyword">include_once</span> <span class="string">&quot;file.php&quot;</span>;</span><br><span class="line">    <span class="keyword">require_once</span> <span class="string">&quot;file.php&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get 方式传参包含 */</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;FILE&quot;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">    <span class="keyword">require</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php-文件读写">PHP 文件读写</h2>
<p>PHP 中使用 <code>fopen()</code> 函数打开文件，<code>fwrite()</code> 函数写入文件，<code>fclose()</code> 函数关闭文件，用法如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以只读方式打开 test.txt 文件</span></span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$file</span>, <span class="string">&quot;str&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>fopen()</code> 函数第二个参数表示打开文件的模式：</p>
<table>
<thead>
<tr class="header">
<th>Patterns</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>只读，从文件开头开始。</td>
</tr>
<tr class="even">
<td>r+</td>
<td>读写，从文件开头开始。</td>
</tr>
<tr class="odd">
<td>w</td>
<td>只写，且清空文件内容，若文件不存在则新建。</td>
</tr>
<tr class="even">
<td>w+</td>
<td>读写，且清空文件内容，若文件不存在则新建。</td>
</tr>
<tr class="odd">
<td>a</td>
<td>只写，从文件末尾进行追加，若文件不存在则新建。</td>
</tr>
<tr class="even">
<td>a+</td>
<td>读写，从文件末尾进行追加，若文件不存在则新建。</td>
</tr>
<tr class="odd">
<td>x</td>
<td>只写，创建一个新文件，若文件已存在则返回 FALSE 并报错。</td>
</tr>
<tr class="even">
<td>x+</td>
<td>读写，创建一个新文件，若文件已存在则返回 FALSE 并报错。</td>
</tr>
</tbody>
</table>
<h2 id="php-文件上传">PHP 文件上传</h2>
<p>PHP 使用 <code>$_FILES</code> 超级全局变量进行文件上传，<code>$_FILES</code> 是一个二维数组，结构如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_FILES</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="comment">/* 假设 filename 为 HTML 表单中 &lt;input &quot;name&quot; /&gt; 的值 */</span></span><br><span class="line">    <span class="string">&quot;filename&quot;</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&quot;name&quot;</span> =&gt; 被上传的文件名称</span><br><span class="line">        <span class="string">&quot;type&quot;</span> =&gt; 被上传的文件类型</span><br><span class="line">        <span class="string">&quot;tmp_name&quot;</span> =&gt; 被上传的文件在服务器中暂时的路径和名称</span><br><span class="line">        <span class="string">&quot;error&quot;</span> =&gt; 上传过程有无错误</span><br><span class="line">        <span class="string">&quot;size&quot;</span> =&gt; 被上传文件的大小</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在此我给出一个简单的文件上传程序：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>请上传文件：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认上传&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">upload.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/* 限制上传文件的类型和大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;image/gif&quot;</span>) </span><br><span class="line">      || (<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;image/jpeg&quot;</span>) </span><br><span class="line">      || (<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;type&quot;</span>] ==<span class="string">&quot;image/pjpeg&quot;</span>)) </span><br><span class="line">      &amp;&amp; (<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;size&quot;</span>] &lt; <span class="number">20000</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;error&quot;</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;错误：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 输出上传的文件信息 */</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;文件名：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;文件类型：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;文件大小&quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot;Kb&lt;br /&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;文件副本：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">/* 将文件存储在服务器 */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;name&quot;</span>])) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;已经存在&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;文件存储在&quot;</span> . <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;filename&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;无法上传该文件&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php-命令执行">PHP 命令执行</h2>
<p>PHP 调用系统命令函数：</p>
<ul>
<li><code>system()</code>：执行系统命令，输出执行结果。</li>
<li><code>passthru()</code>：与 <code>system()</code>函数相似。</li>
<li><code>exec()</code>：执行系统命令，无回显，返回最后一行结果。</li>
<li><code>shell_exec()</code>：执行系统命令，返回完整的输出结果。</li>
<li><code>popen(command, mode)</code>：command 为执行的命令，mode 规定连接模式，可以是 r（只读）、w（只写）等。</li>
<li><code>proc_open()</code>：不直接返回执行结果，返回一个文件指针。</li>
<li><code>pcntl_exec()</code>：执行发生错误返回 FALSE，无错误不返回。</li>
</ul>
<p>命令执行的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$ip</span> = <span class="variable">$_GET</span>[<span class="string">&quot;ip&quot;</span>];</span><br><span class="line">    <span class="variable">$command</span> = <span class="string">&quot;ping -c 3 <span class="subst">$ip</span>&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="string">&quot;<span class="subst">$command</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php-过滤器">PHP 过滤器</h2>
<p>以网络安全为目的，常在 PHP 程序中使用 <code>Filter</code> 函数对外部数据进行过滤，外部数据指表单提交的数据、cookie、Web 服务器信息、数据库查询结果等。</p>
<p>常用的过滤函数：</p>
<ul>
<li><code>filter_var()</code>：对单一的变量使用指定过滤器过滤。</li>
<li><code>filter_var_array()</code>：对多个变量使用多个过滤器过滤。</li>
<li><code>filter_input()</code>：获取一个表单输入的内容，并指定过滤器进行过滤。</li>
<li><code>filter_input_array()</code>：获取多个表单输入的内容，并通过多个过滤器进行过滤。</li>
</ul>
<p>下面的例子使用 <code>filter_var()</code> 进行过滤：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$int</span> = <span class="number">777</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$int</span>, FILTER_VALIDATE_INT)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;不是合法的整数&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;是合法整数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建简单说明</title>
    <url>/2022/03/02/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本站使用 Hexo 进行搭建，发布在 Github Page 上，Github地址：https://github.com/cohanbb <br />本文为使用 Hexo 和 Github Page 搭建个人博客网站的详细教程。<br />
步骤为：配置 git 和 hexo、配置 github、配置主题、发布文章。</p>
<hr>
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#安装-git-和-hexo">安装 Git 和 hexo</a></li>
<li><a href="#github-page-配置">GitHub Page 配置</a></li>
<li><a href="#配置主题">配置主题</a></li>
<li><a href="#发布博客">发布博客</a></li>
</ul>
<!-- /code_chunk_output -->
<hr>
<h1 id="安装-git-和-hexo">安装 Git 和 hexo</h1>
<ol type="1">
<li><p>安装 <a href="https://nodejs.org/en/">node.js</a>。</p></li>
<li><p>安装 <a href="https://git-scm.com/download/win">Git</a>。</p></li>
<li><p>命令行输入命令检验是否安装成功</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br><span class="line">$ git --version</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>安装 hexo<br />
命令行输入 <code>npm install hexo-cli -g</code>，输入 <code>hexo -v</code> 检验是否安装成功。</p></li>
<li><p>初始化 hexo<br />
命令行输入 <code>hexo init [folder]</code>，[folder] 为自定义名字，作为博客的根目录。</p></li>
<li><p>根目录的结构</p>
<ul>
<li>_config.yml : 网站的配置信息，在此配置网站的功能和结构。</li>
<li>package.json: 应用程序的信息，可以查看安装的包。</li>
<li>scaffolds: 模版文件夹，Hexo 根据此来建立文件。</li>
<li>source: 资源文件夹，如 post、tags 等文件存放在此。</li>
<li>themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul></li>
<li><p>生成静态文件，在根目录下命令行输入 <code>hexo generate</code><br />
启动服务器，输入 <code>hexo server</code><br />
可在 http://localhost:4000/ 查看网站。</p></li>
</ol>
<h1 id="github-page-配置">GitHub Page 配置</h1>
<ol type="1">
<li><p>登录 <a href="https://github.com">GitHub</a>，新建 repository，名字必须设为 <strong>username.github.io</strong></p></li>
<li><p>复制仓库的地址 SSH/HTTPs，推荐使用HTTPs，操作简单，但是网路状况不佳；使用 SSH 方式首先需要在本地生成 SSH Key，在终端输入 <code>$ ssh-keygen -t rsa -b 4096 -C "your github email"</code>，然后登录 GitHub 将刚刚生成的公钥添加到 SSH Key 即可。</p></li>
<li><p>进入根目录下的 **_config.yml** 文件，在末尾加入：</p></li>
</ol>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li><p>部署 GitHub<br />
需要下载插件，根目录命令行输入 <code>npm install hexo-deployer-git --save</code><br />
发布网站到GitHub Page<br />
<code>hexo deploy</code></p></li>
<li><p>然后在浏览器访问 https://username.github.io 即可进入博客主页。</p></li>
</ol>
<h1 id="配置主题">配置主题</h1>
<p>Hexo 博客默认主题为 landscape，若想修改主题，在 GitHub 上找到主题，克隆到 theme 文件夹下。本例为 next 主题。</p>
<p><strong>获取主题</strong><br />
theme文件夹下命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>打开 next 的 _config.yml 文件，里面是 next 主题的配置信息，阅读该文档内的注释即可大致明白各部分的作用。<br />
要修改的主要内容为 <code>tags</code>, <code>categories</code>, <code>about</code>, <code>social</code>, <code>avatar</code>, <code>search</code>，网站的背景等。</p>
<p><strong>tags 和 categories</strong><br />
tags 为标签，categories 为类别。在根目录下命令行输入 <code>hexo new page tags</code> ，进入 ./source/tags/index.md，修改为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">xxxxx</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>如果想要文章加上标签，只用在文章上加入 <code>tags: xxxx</code> 即可。<br />
categories 与以上同理。</p>
<p><strong>about</strong><br />
在 next/_config.yml 文件中找到 <code>menu</code> ，可在网站中增加 about。<br />
根目录命令行输入 <code>hexo new page about</code> ，进入 ./source/about/index.md 可编辑 about 的内容。</p>
<p><strong>修改头像，网站的图标、背景</strong></p>
<ul>
<li>修改头像，next/_config.yml 文件中找到 <code>avatar</code> 可配置头像。next/source/image/ 下 avatar.gif 为头像图片，进行更改即可。更改 logo.svg 以及 favicon 图片可以修改网站的图标。</li>
<li>修改背景，在 next/_config.yml 文件查找 <code>custom</code> 可配置 style <code>style: source/_data/styles.styl</code> 后新建 ./source/_data/styles.styl 加入以下代码，后在 next/source/image 中增添背景图片，命名为 background.jpg 即可。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">/images/background.jpg</span>); //图片路径，默认</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;    //图片无法铺满时，是否重复及重复方式</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;    //图片是否跟随滚动</span><br><span class="line">    <span class="attribute">background-size</span>: cover;    //覆盖</span><br><span class="line">    <span class="attribute">background-position</span>: center; //图片显示 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启用search</strong><br />
安装插件，根目录下命令行输入 <code>npm install hexo-generator-searchdb --save</code><br />
根目录/_config.yml 文件中加入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>next/_config.yml 文件中找到 <code>localsearch</code> 修改为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>插入图片</strong><br />
需要将 _config.yml 中的 <code>post_asset_folder</code> 设为 true，这样新建一个博客文件将生成一个同名的目录（文件夹），将图片放入该文件夹，在 markdown 文件中使用 <code>![](图片的名称)</code> 即可正常显示图片了。</p>
<h1 id="发布博客">发布博客</h1>
<p>在根目录命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [pagename]</span><br></pre></td></tr></table></figure>
<p>即可创建新的文章，进入 ./source/_post/ 可找到该文章文件夹，编辑里面的 index.md 即为文章内容。<br />
编辑完成后根目录命令行输入以下命令发布博客。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>如果 markdown 内容中有数学公式，需要在文章上方加入 <code>mathjax: true</code>，或是在 next/_config.yml 文件中找到 <code>mathjax</code>，将 <code>per_page</code> 后改为 <code>true</code>，后者会使所有文章都自动加入 <code>mathjax: true</code>。</p>
<p>由于数学公式与 hexo 默认的 marked 渲染器有冲突，故建议卸载 marked 渲染器，使用 pandoc 渲染器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一元函数微分学</title>
    <url>/2022/09/08/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<p>高等数学-一元函数微分学的概念和计算。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#导数">导数</a></li>
<li><a href="#微分">微分</a></li>
</ul></li>
<li><a href="#计算">计算</a>
<ul>
<li><a href="#基本求导公式和导数运算法则">基本求导公式和导数运算法则</a></li>
<li><a href="#特殊函数求导方法">特殊函数求导方法</a>
<ul>
<li><a href="#复合函数求导法和微分形式不变性">复合函数求导法和微分形式不变性</a></li>
<li><a href="#反函数求导法">反函数求导法</a></li>
<li><a href="#参数方程求导法">参数方程求导法</a></li>
<li><a href="#隐函数求导法">隐函数求导法</a></li>
<li><a href="#变限积分求导公式">变限积分求导公式</a></li>
<li><a href="#对数求导法">对数求导法</a></li>
<li><a href="#幂指函数求导法">幂指函数求导法</a></li>
</ul></li>
<li><a href="#分段函数求导">分段函数求导</a></li>
<li><a href="#高阶导数">高阶导数</a></li>
</ul></li>
<li><a href="#一元函数微分学的几何应用">一元函数微分学的几何应用</a>
<ul>
<li><a href="#单调性与极值点">单调性与极值点</a></li>
<li><a href="#求最值或取值范围">求最值或取值范围</a></li>
<li><a href="#凹凸性与拐点">凹凸性与拐点</a></li>
<li><a href="#渐近线">渐近线</a></li>
<li><a href="#曲率">曲率</a></li>
<li><a href="#相关变化率">相关变化率</a></li>
</ul></li>
<li><a href="#一元函数微分学的物理应用">一元函数微分学的物理应用</a></li>
<li><a href="#应试技巧">应试技巧</a></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="导数">导数</h3>
<p>设函数 <span class="math inline">\(y = f(x)\)</span> 在点 <em>x</em><sub>0</sub> 的某邻域内有定义，若 <em>y</em> 的增量 <span class="math inline">\(\Delta y=f(x_0+\Delta x)-f(x_0)\)</span> 与 <span class="math inline">\(\Delta x\)</span> 的比值在 <span class="math inline">\(\Delta x \to 0\)</span> 时的极限存在，则 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处『<strong>可导</strong>』，该<strong>极限</strong>称为 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处的『<strong>导数</strong>』，记作：</p>
<p><span class="math display">\[
\begin{align}
f’(x_0) = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} &amp;= \lim_{\Delta x \to 0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}\\
&amp;= \lim_{x \to x_0} \frac{f(x)-f(x_0)}{x-x_0}
\end{align}
\]</span></p>
<ul>
<li>(1)式称为增量式，(2) 式称为差值式。</li>
<li><p>导数的本质是一种<strong>极限</strong>，存在的充要条件是左右极限都存在且相等。</p>
<blockquote>
<p>当 <span class="math inline">\(\Delta x \to 0^{-}\)</span> 时，<span class="math inline">\(\lim \frac{\Delta y}{\Delta x}\)</span> 为左导数 <span class="math inline">\(f_{-}’(x_0)\)</span>，反之为右导数 <span class="math inline">\(f_{+}’(x_0)\)</span>.</p>
</blockquote></li>
<li>下面三种说法等价：
<ul>
<li><span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处可导。</li>
<li><span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处导数存在。</li>
<li><span class="math inline">\(f&#39;(x_0) = A \; (A \in \mathbb{R})\)</span>。</li>
</ul></li>
<li>导数代表 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处的『（瞬时）变化率』，几何意义为函数图形上某一点的『切线斜率』。<br />
</li>
<li><p>函数在某处可导，则必然在此处连续。<strong>反之不成立</strong>。</p>
<blockquote>
<p><strong>证</strong><br />
设函数 <span class="math inline">\(y=f(x)\)</span> 在 <em>x</em><sub>0</sub> 处的导数为 A，<br />
则 <span class="math inline">\(\lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = A\)</span>，<br />
<span class="math inline">\(\frac{\Delta y}{\Delta x} = A + \alpha \; (\lim_{\Delta x \to 0} \alpha = 0)\)</span>，<br />
当 <span class="math inline">\(\Delta x \to 0\)</span>，<br />
<span class="math inline">\(\Delta y = f(x_0+\Delta x)-f(x_0)= A\Delta x + \alpha \Delta x = A\Delta x+o(\Delta x)\)</span>，<br />
显然 <span class="math inline">\(\Delta y \to 0\)</span>，即 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处连续。<br />
反之不成立的例子：<span class="math inline">\(y = |x|\)</span>，<span class="math inline">\(y = x\sin(x)\)</span>。</p>
</blockquote></li>
</ul>
<p>函数 <span class="math inline">\(y = f&#39;(x)\)</span> 为 <span class="math inline">\(f(x)\)</span> 的导函数，导函数具有特殊的性质：</p>
<ul>
<li>导函数零点定理：<br />
若函数 <span class="math inline">\(y=f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <strong>可导</strong>（无需导函数连续），<span class="math inline">\(f’_+(a) \cdot f’_-(b) &lt; 0\)</span>，则 <span class="math inline">\(\exists \xi \in (a, b)\)</span>，使得 <span class="math inline">\(f&#39;(\xi) = 0\)</span>。</li>
<li>达布定理（导函数介值定理）：<br />
若函数 <span class="math inline">\(y=f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <strong>可导</strong>（无需导函数连续），<span class="math inline">\(f’(a) \ne f’(b)\)</span>，则对于 <span class="math inline">\(\forall \mu\)</span> 位于 <span class="math inline">\(f’(a)\)</span> 和 <span class="math inline">\(f’(b)\)</span> 之间，都 <span class="math inline">\(\exists \xi \in [a,b]\)</span>，使得 <span class="math inline">\(f’(\xi)=\mu\)</span>。</li>
<li>在可导区间内导函数无第一类间断点和无穷间断点。即若函数 <span class="math inline">\(y=f(x)\)</span> 在某处可导，则 <span class="math inline">\(f&#39;(x)\)</span> 在此处<strong>连续或存在振荡间断点</strong>。</li>
<li><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上可导，<span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上有界，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上有界。换个说法，<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上可导且无界，则 <span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上无界。</li>
</ul>
<h3 id="微分">微分</h3>
<p>设函数 <span class="math inline">\(y = f(x)\)</span> 在点 <em>x</em><sub>0</sub> 的某邻域内有定义，对于函数增量 <span class="math inline">\(\Delta y = f(x_0 + \Delta x) - f(x_0)\)</span>，若存在与 <span class="math inline">\(\Delta x\)</span> 无关的常数 <em>A</em>，使得</p>
<p><span class="math display">\[
\Delta y = A\Delta x + o(\Delta x)
\]</span></p>
<p>则称 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处『<strong>可微</strong>』，并称 <span class="math inline">\(A\Delta x\)</span> 为 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处的『<strong>微分</strong>』（线性主部），记作</p>
<p><span class="math display">\[
\text{d}y \bigg|_{x = x_0} = A\Delta x
\]</span></p>
<p>又因为 <span class="math inline">\(\Delta x = 1 \cdot \Delta x + 0 \Rightarrow 1 \cdot \Delta x + o(\Delta x)\)</span>，所以 <span class="math inline">\(\text{d}x = \Delta x\)</span>。</p>
<p>所以</p>
<p><span class="math display">\[
\text{d}y \bigg|_{x = x_0} = A\text{d}x
\]</span></p>
<p>又 <span class="math inline">\(\frac{\Delta y}{\Delta x} = A + \frac{o(\Delta x)}{\Delta x}\)</span>，所以 <span class="math inline">\(\lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = A + 0 = A\)</span>，即</p>
<p><span class="math display">\[
A = f&#39;(x_0)
\]</span></p>
<p>故</p>
<p><span class="math display">\[
\text{d}y \bigg|_{x = x_0} = f&#39;(x_0)\text{d}x
\]</span></p>
<p>跟据以上分析，可得出两个重要结论：</p>
<ol type="1">
<li>导数的第三个定义式：</li>
</ol>
<p><span class="math display">\[
\begin{align}
f&#39;(x_0) = \frac{\text{d}y}{\text{d}x}\bigg|_{x = x_0}
\end{align}
\]</span></p>
<ol start="2" type="1">
<li>若函数在某处可微，则必在此处可导。反之也成立。即<strong>函数在某处可微等价于在某处可导</strong>。</li>
</ol>
<blockquote>
<p><strong>证</strong><br />
设函数 <span class="math inline">\(y=f(x)\)</span> 在 <em>x</em><sub>0</sub> 处的导数为 A，<br />
则 <span class="math inline">\(\lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = A\)</span>，<br />
<span class="math inline">\(\frac{\Delta y}{\Delta x} = A + \alpha \; (\lim_{\Delta x \to 0} \alpha = 0)\)</span>，<br />
当 <span class="math inline">\(\Delta x \to 0\)</span>，<br />
<span class="math inline">\(\Delta y = f(x_0+\Delta x)-f(x_0)= A\Delta x + \alpha \Delta x = A\Delta x+o(\Delta x)\)</span>，<br />
即 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处可微。</p>
</blockquote>
<h2 id="计算">计算</h2>
<h3 id="基本求导公式和导数运算法则">基本求导公式和导数运算法则</h3>
<p>基本求导公式：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\left(x^{\alpha}\right)&#39;=\alpha x^{\alpha - 1}, \quad \left(a^{x}\right)&#39; = a^{x} \ln a \;(a&gt;0, a \neq 1), \quad\left(\mathrm{e}^{x}\right)^{\prime}=\mathrm{e}^{x}, \\ &amp;\left(\log _{a} x\right)^{\prime}=\frac{1}{x \ln a} \;(a&gt;0, a \neq 1) ,\quad(\ln |x|)^{\prime}=\frac{1}{x}, \\ &amp;(\sin x)^{\prime}=\cos x, \quad(\cos x)^{\prime}=-\sin x, \quad(\tan x)^{\prime}=\sec ^{2} x, \quad(\cot x)^{\prime}=-\csc ^{2} x, \\
&amp; (\arcsin x)^{\prime}=\frac{1}{\sqrt{1-x^{2}}} ,\quad(\arccos x)^{\prime}=-\frac{1}{\sqrt{1-x^{2}}}, \quad(\arctan x)^{\prime}=\frac{1}{1+x^{2}} ,\\
&amp; (\operatorname{arccot} x)^{\prime}=-\frac{1}{1+x^{2}}, \quad(\sec x)^{\prime}=\sec x \tan x, \quad(\csc x)^{\prime}=-\csc x \cot x ,\\
&amp; \left[\ln \left(x+\sqrt{x^{2}+1}\right)\right]^{\prime}=\frac{1}{\sqrt{x^{2}+1}}, \quad\left[\ln \left(x+\sqrt{x^{2}-1}\right)\right]^{\prime}=\frac{1}{\sqrt{x^{2}-1}}
\end{aligned}
\]</span></p>
<p>导数和微分的运算法则：</p>
<ul>
<li><span class="math inline">\((ku)&#39; = ku&#39;,\; \text{d}(ku) = k\text{d}u\)</span>，<em>k</em> 为常数。</li>
<li><span class="math inline">\((u \pm v)&#39; = u&#39; \pm v&#39;,\;\text{d}(u \pm v) = \text{d}u \pm \text{d}v\)</span></li>
<li><span class="math inline">\((uv)&#39; = u&#39;v + v&#39;u, \; \text{d}(uv) = v\text{d}u + u\text{d}v\)</span></li>
<li><span class="math inline">\(\left(\frac{u}{v}\right)&#39; = \frac{u&#39;v - v&#39;u}{v^2}, \;\text{d}\left(\frac{u}{v}\right) = \frac{v\text{d}u - u\text{d}v}{v^2},\; v \neq 0\)</span></li>
</ul>
<h3 id="特殊函数求导方法">特殊函数求导方法</h3>
<h4 id="复合函数求导法和微分形式不变性">复合函数求导法和微分形式不变性</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;\{f[g(x)]\}&#39; = g&#39;(x)f&#39;[g(x)]\\
&amp;\text{d}\{f[g(x)]\} = f&#39;[g(x)]\text{d}g(x)= g&#39;(x)f&#39;[g(x)]\text{d}x
\end{aligned}
\]</span></p>
<p>注：要分清楚 <span class="math inline">\(f&#39;[g(x)]\)</span> 和 <span class="math inline">\(\{f[g(x)]\}&#39;\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f&#39;[g(x)] = \frac{\text{d}\{f[g(x)]\}}{\text{d}g(x)}\\
&amp;\{f[g(x)]\}&#39; = \frac{\text{d}\{f[g(x)]\}}{\text{d}x}
\end{aligned}
\]</span></p>
<h4 id="反函数求导法">反函数求导法</h4>
<p>若 <span class="math inline">\(f(x)\)</span> 可导且 <span class="math inline">\(f&#39;(x) \neq 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 是单调函数，存在反函数 <span class="math inline">\(x = f^{-1}(y) = \varphi(y)\)</span>，则</p>
<p><span class="math display">\[
\begin{aligned}
\varphi&#39;(y) &amp;= \frac{\text{d}x}{\text{d}y} = \frac{1}{f&#39;(x)}\\
\varphi&#39;&#39;(y) &amp;= \frac{\text{d}\left(\frac{\text{d}x}{\text{d}y}\right)}{\text{d}y} = \frac{\text{d}\left(\frac{\text{d}x}{\text{d}y}\right)}{\text{d}x}\cdot \frac{\text{d}x}{\text{d}y} = \frac{\text{d}\left(\frac{1}{f&#39;(x)}\right)}{\text{d}x} \cdot \frac{1}{f&#39;(x)} \\&amp;= - \frac{f&#39;&#39;(x)}{[f&#39;(x)]^2} \cdot \frac{1}{f&#39;(x)} = - \frac{f&#39;&#39;(x)}{[f&#39;(x)]^3}
\end{aligned}
\]</span></p>
<h4 id="参数方程求导法">参数方程求导法</h4>
<p>函数以参数方程形式表示：<span class="math inline">\(\left\{\begin{aligned}&amp; x = \varphi(t)\\&amp; y = \psi(t)\end{aligned}\right.\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp; y&#39; = \frac{\text{d}y}{\text{d}x} = \frac{\text{d}y/\text{d}t}{\text{d}x/\text{d}t} = \frac{\psi&#39;(t)}{\varphi&#39;(t)}\\
&amp; y&#39;&#39; = \frac{\text{d}\left(\frac{\text{d}y}{\text{d}x}\right)}{\text{d}x} = \frac{\text{d}\left(\frac{\text{d}y}{\text{d}x}\right)/\text{d}t}{\text{d}x/\text{d}t} = \frac{\psi&#39;&#39;(t)\varphi(t) - \varphi&#39;&#39;(t)\psi&#39;(t)}{[\varphi&#39;(t)]^3}
\end{aligned}
\]</span></p>
<h4 id="隐函数求导法">隐函数求导法</h4>
<p>函数由方程 <span class="math inline">\(F(x,y) = 0\)</span> 确定，对方程两侧求导，注意 <span class="math inline">\(y = y(x)\)</span>，得到一个由 <span class="math inline">\(x,y,y&#39;\)</span> 构成的方程，求解可得到 <span class="math inline">\(y&#39;\)</span>。</p>
<h4 id="变限积分求导公式">变限积分求导公式</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;F(x) = \int _{\varphi_1(x)}^{\varphi_2(x)} f(t) \text{d}t\\
&amp;F&#39;(x) = f[\varphi_2(x)]\varphi_2&#39;(x)-f[\varphi_1(x)]\varphi_1&#39;(x)
\end{aligned}
\]</span></p>
<p>注意：如果被积函数中含有『求导变量』<em>x</em>，如：<span class="math inline">\(F(x)= \int_a^x xf(t)\text{d}x\)</span>，则无法直接使用变限积分求导公式。</p>
<h4 id="对数求导法">对数求导法</h4>
<p>多项式相乘除、幂运算的式子，可先取对数再求导：</p>
<p><span class="math display">\[
y = f(x) \Rightarrow \ln y = \ln f(x) \Rightarrow \frac{y&#39;}{y} = \frac{f&#39;(x)}{f(x)} \Rightarrow y&#39; = \frac{yf&#39;(x)}{f(x)}
\]</span></p>
<h4 id="幂指函数求导法">幂指函数求导法</h4>
<p>形如 <span class="math inline">\(u(x)^{v(x)}\)</span>，可恒等变形为指数形式 <span class="math inline">\(e^{v(x)\ln u(x)}\)</span> 然后求导：</p>
<p><span class="math display">\[
\begin{aligned}
\left[e^{v(x)\ln u(x)}\right]&#39;&amp; = e^{v(x)\ln u(x)}\left[v&#39;(x)\ln u(x) + \frac{u&#39;(x)v(x)}{u(x)}\right]\\
&amp; = u(x)^{v(x)}\left[v&#39;(x)\ln u(x) + \frac{u&#39;(x)v(x)}{u(x)}\right]
\end{aligned}
\]</span></p>
<h3 id="分段函数求导">分段函数求导</h3>
<ol type="1">
<li>在<strong>分段点</strong>处用<strong>导数的定义</strong>求导。</li>
<li>在<strong>非分段点</strong>使用<strong>求导公式</strong>求导。</li>
</ol>
<h3 id="高阶导数">高阶导数</h3>
<ol type="1">
<li>归纳法</li>
</ol>
<p><span class="math display">\[
\begin{array}{l}
\left(a^{x}\right)^{(n)}=a^{x}(\ln a)^{n}(a&gt;0, a \neq 1) , \quad\left(\mathrm{e}^{x}\right)^{(n)}=\mathrm{e}^{x} , \quad(\sin k x)^{(n)}=k^{n} \sin \left(k x+n \cdot \frac{\pi}{2}\right) , \\
(\cos k x)^{(n)}=k^{n} \cos \left(k x+n \cdot \frac{\pi}{2}\right) , \quad(\ln x)^{(n)}=(-1)^{n-1} \frac{(n-1) !}{x^{n}}\;(x&gt;0) , \\
\left(\frac{1}{x}\right)^{(n)}=(-1)^{n} n ! x^{-n-1}=(-1)^{n} \frac{n !}{x^{n+1}}, \quad [\ln (1+x)]^{(n)}=(-1)^{n-1} \frac{(n-1) !}{(1+x)^{n}}\;(x&gt;-1) , \\
\left[\left(x+x_{0}\right)^{m}\right]^{(n)}=m(m-1)(m-2) \cdots(m-n+1)\left(x+x_{0}\right)^{m-n} , \quad\left(\frac{1}{x+a}\right)^{(n)}=\frac{(-1)^{n} n !}{(x+a)^{n+1}}
\end{array}
\]</span></p>
<ol start="2" type="1">
<li>莱布尼茨公式</li>
</ol>
<p>设 <span class="math inline">\(u =u(x),v=v(x)\)</span> 均 <em>n</em> 阶可导，则</p>
<p><span class="math display">\[
\begin{aligned}
&amp;(u \pm v)^{(n)} = u^{(n)} \pm v^{(n)}\\
&amp;\begin{aligned}(uv)^{(n)}  &amp;= u^{(n)}v + \text{C}_n^1u^{(n-1)}v&#39; + \cdots + \text{C}_n^ku^{(n-k)}v^{(k)} + \cdots + \text{C}_n^{n-1}u&#39;v^{(n-1)} + uv^{(n)} \\
&amp;= \sum_{k=0}^n \text{C}_n^ku^{(n-k)}v^{(k)}
\end{aligned}
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>麦克劳林公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \mathrm{e}^{x}=\sum_{n=0}^{\infty} \frac{x^{n}}{n !}=1+x+\frac{x^{2}}{2 !}+\cdots+\frac{x^{n}}{n !}+\cdots, \; -\infty&lt;x&lt;+\infty \\
&amp; \frac{1}{1+x}=\sum_{n=0}^{\infty}(-1)^{n} x^{n}=1-x+x^{2}-x^{3}+\cdots+(-1)^{n} x^{n}+\cdots, \; -1&lt;x&lt;1 \\
&amp; \frac{1}{1-x}=\sum_{n=0}^{\infty} x^{n}=1+x+x^{2}+\cdots+x^{n}+\cdots, \; -1&lt;x&lt;1 \\
&amp; \ln (1+x)=\sum_{n=1}^{\infty}(-1)^{n-1} \frac{x^{n}}{n}=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\frac{x^{4}}{4}+\cdots+(-1)^{n-1} \frac{x^{n}}{n}+\cdots, \; -1&lt;x \leqslant 1 \\
&amp; \sin x=\sum_{n=0}^{\infty}(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !} 
 =x-\frac{x^{3}}{3 !}+\frac{x^{5}}{5 !}-\frac{x^{7}}{7 !}+\cdots+(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !}+\cdots, \; -\infty&lt;x&lt;+\infty \\
&amp; \cos x=\sum_{n=0}^{\infty}(-1)^{n} \frac{x^{2 n}}{(2 n) !} =1-\frac{x^{2}}{2 !}+\frac{x^{4}}{4 !}-\frac{x^{6}}{6 !}+\cdots+(-1)^{n} \frac{x^{2 n}}{(2 n) !}+\cdots,\;-\infty&lt;x&lt;+\infty \\
&amp;(1+x)^{\alpha}=1+\alpha x+\frac{\alpha(\alpha-1)}{2 !} x^{2}+\cdots+\frac{\alpha(\alpha-1) \cdots(\alpha-n+1)}{n !} x^{n}+\cdots,\;\left\{\begin{array}{l}
x \in(-1,1), &amp;\alpha \leqslant-1\\
x \in(-1,1], &amp;-1&lt;\alpha&lt;0\\
x \in[-1,1], &amp; \alpha&gt;0,\; \alpha \notin \mathbf{N}_{+}\\
x \in \mathbf{R}, &amp; \alpha \in \mathbf{N}_{+}
\end{array}\right.
\end{aligned}
\]</span></p>
<h2 id="一元函数微分学的几何应用">一元函数微分学的几何应用</h2>
<h3 id="单调性与极值点">单调性与极值点</h3>
<p>若<strong>存在</strong>点 <em>x</em><sub>0</sub> 的某邻域 <span class="math inline">\(U(x_0)\)</span>，使得对于 <span class="math inline">\(\forall x \in U(x_0)\)</span>，都有</p>
<p><span class="math display">\[
f(x) \leq f(x_0)\; (\text{or} \; f(x) \geq f(x_0))
\]</span></p>
<p>成立，则称点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的<strong>广义的极大值点（或极小值点）</strong>。</p>
<p>若<strong>存在</strong>点 <em>x</em><sub>0</sub> 的某去心邻域 <span class="math inline">\(\mathring{U}(x_0)\)</span>，使得对于 <span class="math inline">\(\forall x \in \mathring{U}(x_0)\)</span>，都有</p>
<p><span class="math display">\[
f(x) &lt; f(x_0)\; (\text{or} \; f(x) &gt; f(x_0))
\]</span></p>
<p>成立，则称点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的<strong>真正的极大值点（或极小值点）</strong>。</p>
<p><strong>注意：</strong></p>
<p>极值点是一个非常宽松的概念，只要在该点的某个邻域内取得最值，该点便是一个极值点。极值点两侧的<strong>单调性不一定发生改变</strong>，该点<strong>不一定可导</strong>，也<strong>不一定连续</strong>。譬如 <span class="math inline">\(x = 0\)</span> 为下面函数的极大值点：</p>
<p><span class="math display">\[
\begin{array}{l}
f(x) =
\left\{\begin{array}{l}
1, &amp; x = 0 \\
x, &amp; x \neq 0
\end{array}\right.
\end{array}
\]</span></p>
<p><strong>判断极值点的第一充分条件：</strong></p>
<p>若函数在点 <em>x</em><sub>0</sub> 两侧的<strong>单调性发生改变</strong>，则点 <em>x</em><sub>0</sub> 是函数的一个极值点。</p>
<p>即若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处连续，且在点 <em>x</em><sub>0</sub> 的某去心 <span class="math inline">\(\delta\)</span> 邻域 <span class="math inline">\(\mathring{U}(x, \delta)\)</span> 内可导：</p>
<ul>
<li><span class="math inline">\(x \in (x_0-\delta, x_0),\; f&#39;(x) &lt; 0,\;x \in (x_0, x_0+\delta),\; f&#39;(x) &gt; 0\)</span>，则点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极小值点。</li>
<li><span class="math inline">\(x \in (x_0-\delta, x_0),\; f&#39;(x) &gt; 0,\;x \in (x_0, x_0+\delta),\; f&#39;(x) &lt; 0\)</span>，则点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极大值点。</li>
</ul>
<p><strong>判断极值点的第二充分条件：</strong></p>
<p>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处二阶可导，且 <span class="math inline">\(f&#39;(x_0) = 0, \;f&#39;&#39;(x_0) \neq 0\)</span>，则点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极值点。</p>
<ul>
<li>当 <span class="math inline">\(f&#39;&#39;(x_0) &gt; 0\)</span>，点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极小值点。</li>
<li>当 <span class="math inline">\(f&#39;&#39;(x_0) &lt; 0\)</span>，点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极大值点。</li>
</ul>
<p><strong>第二充分条件的推广形式：</strong></p>
<p>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处 <em>n</em>（<em>n</em> 为正偶数）阶可导，且</p>
<p><span class="math display">\[
f^{(m)}(x_0) = 0 \;(m = 1,2,\ldots,n-1), \;f^{(n)}(x_0) \neq 0
\]</span></p>
<p>则点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极值点：</p>
<ul>
<li><span class="math inline">\(f^{(n)}(x_0) &gt; 0\)</span>，点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极小值点。</li>
<li><span class="math inline">\(f^{(n)}(x_0) &lt; 0\)</span>，点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极大值点。</li>
</ul>
<p><strong>极值点的必要条件：</strong></p>
<p>点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个极值点，若 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处可导，则 <span class="math inline">\(f&#39;(x)=0\)</span>。</p>
<h3 id="求最值或取值范围">求最值或取值范围</h3>
<p>重要结论：</p>
<ul>
<li><p>无论开闭区间上的唯一极值点一定是最值点。</p></li>
<li>求 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([a,b]\)</span> 上的最值：
<ul>
<li>疑似极值点：一阶导数为零或不可导点，求这些点的函数值。</li>
<li>求区间端点的函数值 <span class="math inline">\(f(a),f(b)\)</span>。</li>
<li>对比上两个过程求的函数值得到最大值和最小值。</li>
</ul></li>
<li>求 <span class="math inline">\(f(x)\)</span> 在开区间 <span class="math inline">\((a,b)\)</span> 上的最值或取值范围：
<ul>
<li>疑似极值点：一阶导数为零或不可导点，求这些点的函数值。</li>
<li>求 <span class="math inline">\(x \to a^+\)</span> 和 <span class="math inline">\(x \to b^-\)</span> 时函数的极限。</li>
<li>对比上两个过程求的函数值得到最大值和最小值或取值范围。</li>
</ul></li>
</ul>
<h3 id="凹凸性与拐点">凹凸性与拐点</h3>
<p>若 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上连续，若对于 <span class="math inline">\(\forall x_1,x_2 \in I \;(x_1 \neq x_2)\)</span>，都有</p>
<p><span class="math display">\[
f\left(\frac{x_1+x_2}{2}\right) &lt; \frac{f(x_1)+f(x_2)}{2} \;(\text{or} \;f\left(\frac{x_1+x_2}{2}\right) &gt; \frac{f(x_1)+f(x_2)}{2})
\]</span></p>
<p>成立，则称 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上的图形是凹（或凸）的。函数图形上凹凸性发生变化的点称为<strong>拐点</strong>。</p>
<p><strong>判断拐点的第一充分条件：</strong></p>
<p>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处连续，在点 <em>x</em><sub>0</sub> 的某去心邻域内二阶可导，且在左、右邻域内的二阶导数异号，则点 <span class="math inline">\((x_0,f(x_0))\)</span> 为 <span class="math inline">\(f(x)\)</span> 图形上的拐点。</p>
<p><strong>判断拐点的第二充分条件：</strong></p>
<p>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处三阶可导，且 <span class="math inline">\(f&#39;&#39;( x_0) = 0,\;f&#39;&#39;&#39;(x_0) \neq 0\)</span>，则点 <span class="math inline">\((x_0,f(x_0))\)</span> 为 <span class="math inline">\(f(x)\)</span> 图形上的拐点。</p>
<p><strong>第二充分条件的推广形式：</strong></p>
<p>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处 <em>n</em>（<em>n</em> 为大于等于 3 的奇数）阶可导，且</p>
<p><span class="math display">\[
f^{(m)}( x_0) = 0\; (m = 2,3,\ldots,n-1),\;f^{(n)}(x_0) \neq 0
\]</span></p>
<p>则点 <span class="math inline">\((x_0,f(x_0))\)</span> 为 <span class="math inline">\(f(x)\)</span> 图形上的拐点。</p>
<h3 id="渐近线">渐近线</h3>
<ol type="1">
<li>铅垂渐近线</li>
</ol>
<p><span class="math display">\[
\lim _{x \rightarrow x_{0}^{+}} f(x)=\infty\; (\text{or} \lim _{x \rightarrow x_{0}^{-}} f(x)=\infty)
\]</span></p>
<p>则 <span class="math inline">\(x=x_{0}\)</span> 为 <span class="math inline">\(y = f(x)\)</span> 的一条『铅垂渐近线』。</p>
<blockquote>
<p>注：此处的 <span class="math inline">\(x_{0}\)</span> 或是函数的无定义点，或是函数定义区间的端点，或是分段函数的分段点。</p>
</blockquote>
<ol start="2" type="1">
<li>水平渐近线</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp;\lim _{x \rightarrow+\infty} f(x)=y_{1} \\
&amp;\lim _{x \rightarrow-\infty} f(x)=y_{2} \\
&amp;\lim _{x \rightarrow+\infty} f(x)=\lim _{x \rightarrow-\infty} f(x)=y_{0}
\end{aligned}
\]</span></p>
<p>满足上三种情况的 <span class="math inline">\(y = y_1,\; y = y_2,\; y = y_0\)</span> 均为 <span class="math inline">\(y = f(x)\)</span> 的『水平渐近线』。</p>
<ol start="3" type="1">
<li>斜渐近线</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp;\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=a_{1},\;\lim _{x \rightarrow+\infty}\left[f(x)-a_{1} x\right]=b_{1} \\
&amp;\lim _{x \rightarrow-\infty} \frac{f(x)}{x}=a_{2},\;\lim _{x \rightarrow-\infty}\left[f(x)-a_{2} x\right]=b_{2} \\
&amp;\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=\lim _{x \rightarrow-\infty} \frac{f(x)}{x}=a_{0},\;\lim _{x \rightarrow+\infty}[f(x)-a_{0} x]=\lim _{x \rightarrow-\infty}[f(x)-a_{0}x]=b_{0}
\end{aligned}
\]</span></p>
<p>满足上述三种情况的 <span class="math inline">\(y=a_{1}x+b_{1}, \;y=a_{2}x+b_{2}, \;y=a_{0}x+b_{0}\)</span> 均为曲线 <span class="math inline">\(y=f(x)\)</span> 的『斜渐近线』。</p>
<h3 id="曲率">曲率</h3>
<p>设曲线的直角坐标方程为 <span class="math inline">\(y=f(x)\)</span>， 且 <span class="math inline">\(y=f(x)\)</span> 具有二阶导数，曲线在点 <em>M</em> 处的切线的斜率为 <span class="math inline">\(y=\tan \alpha\)</span>， 所以</p>
<p><span class="math display">\[
\begin{aligned}
\sec ^{2} \alpha \times \frac{\text{d}\alpha}{\text{d} x} = y^{\prime \prime} &amp;\Rightarrow \frac{\text{d} \alpha}{\text{d} x}=\frac{y^{\prime \prime}}{1+\tan ^{2} \alpha}=\frac{y^{\prime \prime}}{1+y^{\prime 2}}\\
\text{d} \alpha &amp;= \frac{y^{\prime \prime}}{1+y^{\prime 2}} \text{d} x
\end{aligned}
\]</span></p>
<p>又 <span class="math inline">\(\text{d} s=\sqrt{1+y^{\prime 2}} \text{d}x\)</span>，故曲线 <em>L</em> 在 <em>M</em> 点处的『曲率』为：</p>
<p><span class="math display">\[
K= \left|\frac{\text{d} \alpha}{\text{d} s} \right| = \frac{\left|y^{\prime \prime}\right|}{\left(1+y^{\prime 2}\right)^{\frac{3}{2}}}
\]</span></p>
<p>设曲线是由参数方程 <span class="math inline">\(\left\{\begin{array}{l}x=\varphi(t) \\ y=\psi(t)\end{array}\right.\)</span> 给出，利用参数方程求导法可得：</p>
<p><span class="math display">\[
K=\frac{\left|\varphi^{\prime}(t) \psi^{\prime \prime}(t)-\psi^{\prime}(t) \varphi^{\prime \prime}(t)\right|}{\left[\varphi^{\prime 2}(t)+\psi^{\prime 2}(t)\right]^{\frac{3}{2}}}
\]</span></p>
<p>『曲率半径』：</p>
<p><span class="math display">\[
\rho = \frac{1}{K} = \frac{\left(1+y^{\prime 2}\right)^{\frac{3}{2}}}{\left|y^{\prime \prime}\right|}
\]</span></p>
<h3 id="相关变化率">相关变化率</h3>
<p>已知 <span class="math inline">\(\frac{\text{d}A}{\text{d}B},\frac{\text{d}B}{\text{d}C}\)</span>，则 <span class="math inline">\(\frac{\text{d}A}{\text{d}C} = \frac{\text{d}A}{\text{d}B} \cdot \frac{\text{d}B}{\text{d}C}\)</span>。</p>
<h2 id="一元函数微分学的物理应用">一元函数微分学的物理应用</h2>
<h2 id="应试技巧">应试技巧</h2>
<ul>
<li><span class="math inline">\((\ln |x|)&#39; = \frac{1}{x}\)</span></li>
<li><span class="math inline">\(f(0) = 0 \Rightarrow \lim_{h \to 0} \frac{f(h)}{h} = f&#39;(0)\)</span></li>
<li>根据导函数的零点定理，<span class="math inline">\(f(x)\)</span>（在区间内）可导，<span class="math inline">\(f&#39;(x) \neq 0\)</span>，则 <span class="math inline">\(f&#39;(x)\)</span> 恒正或恒负，即 <span class="math inline">\(f(x)\)</span>（在区间内）严格单调递增或递减。</li>
<li>若 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处连续，则 <span class="math inline">\(\lim_{x \to x_0} \frac{f(x)}{x - x_0} = A \Rightarrow f(x_0) = 0, \; f&#39;(x_0) =A\)</span>。</li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Calulus</tag>
      </tags>
  </entry>
  <entry>
    <title>二次型</title>
    <url>/2022/09/25/%E4%BA%8C%E6%AC%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>线性代数-二次型的概念与计算。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#正交矩阵">正交矩阵</a></li>
<li><a href="#实对称矩阵">实对称矩阵</a></li>
<li><a href="#实对称矩阵的合同">实对称矩阵的合同</a></li>
<li><a href="#二次型及其标准形和规范形">二次型及其标准形和规范形</a></li>
<li><a href="#惯性定理">惯性定理</a></li>
<li><a href="#正定二次型">正定二次型</a></li>
</ul></li>
<li><a href="#化二次型为标准形或规范形">化二次型为标准形或规范形</a>
<ul>
<li><a href="#正交变换法">正交变换法</a></li>
<li><a href="#配方法">配方法</a></li>
</ul></li>
<li><a href="#结句">结句</a></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="正交矩阵">正交矩阵</h3>
<p><strong><em>A</em></strong> 是『<strong>正交矩阵</strong>』 <span class="math inline">\(\Leftrightarrow\boldsymbol{A}\boldsymbol{A}^{\text{T}} = \boldsymbol{E}\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\Leftrightarrow \boldsymbol{A}^{-1} = \boldsymbol{A}^{\text{T}}\\
&amp;\Leftrightarrow \boldsymbol{A}^{\text{T}}{\left(\boldsymbol{A}^{\text{T}}\right)}^{\text{T}} = \boldsymbol{A}^{-1}\boldsymbol{A} = \boldsymbol{E} \\
&amp;\Leftrightarrow \boldsymbol{A}^{-1}{\left(\boldsymbol{A}^{-1}\right)}^{\text{T}} = \boldsymbol{A}^{-1}\boldsymbol{A} =\boldsymbol{E}\\
&amp;\Leftrightarrow -\boldsymbol{A}(-\boldsymbol{A})^{\text{T}} = \boldsymbol{A}\boldsymbol{A}^{\text{T}} = \boldsymbol{E} \\
&amp;\Rightarrow |\boldsymbol{A}|^2 = |\boldsymbol{A}\boldsymbol{A}| = \left|\boldsymbol{A}\boldsymbol{A}^{-1}\right| = |\boldsymbol{E}| = 1 \Rightarrow |\boldsymbol{A}| = \pm 1\\
&amp;\Leftrightarrow \boldsymbol{A}^*(\boldsymbol{A}^*)^{\text{T}} = |\boldsymbol{A}|\boldsymbol{A}^{-1}{\left(|\boldsymbol{A}|\boldsymbol{A}^{-1}\right)}^{\text{T}} = \boldsymbol{A}^{-1}{\left(\boldsymbol{A}^{-1}\right)}^{\text{T}} = \boldsymbol{E}
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\boldsymbol{A}^{\text{T}},\boldsymbol{A}^{-1},\boldsymbol{A}^*,-\boldsymbol{A}\)</span> 是正交矩阵。</li>
<li><strong><em>A</em></strong> 必可逆，<span class="math inline">\(\text{det}(\boldsymbol{A}) = \pm 1\)</span>。</li>
<li>若 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 为同阶正交矩阵，则 <strong><em>AB</em></strong> 必为正交矩阵（<strong><em>A</em></strong> + <strong><em>B</em></strong> 未必）。</li>
</ul>
<p><strong>正交矩阵与向量空间的关系：</strong></p>
<ul>
<li><strong><em>A</em></strong> 是正交矩阵 <span class="math inline">\(\Leftrightarrow\)</span> <strong><em>A</em></strong> 的列向量组和行向量组都是<strong>单位正交向量组</strong>。</li>
<li><strong><em>A</em></strong> 是正交矩阵 <span class="math inline">\(\Leftrightarrow\)</span> <strong><em>A</em></strong> 的 <em>n</em> 个列向量和 <em>n</em> 个行向量都是 <em>n</em> 维向量空间的<strong>规范正交基</strong>。</li>
<li><strong><em>A</em></strong> 是正交矩阵 <span class="math inline">\(\Leftrightarrow\)</span> <strong><em>A</em></strong> 是规范正交基到规范正交基的过渡矩阵。</li>
</ul>
<h3 id="实对称矩阵">实对称矩阵</h3>
<p><strong><em>A</em></strong> 是『<strong>实对称矩阵</strong>』<span class="math inline">\(\Leftrightarrow\boldsymbol{A} = \boldsymbol{A}^{\text{T}}\)</span> 且元素都是实数。</p>
<p><strong>实对称矩阵的性质：</strong></p>
<ul>
<li><strong>实对称矩阵的 <em>k</em> 重特征值必有 <em>k</em> 个线性无关的特征向量。</strong></li>
<li>根据上一条结论，<em>n</em> 阶实对称矩阵必有 <em>n</em> 个线性无关的特征向量，即<strong>必可以相似对角化</strong>。</li>
<li><strong>实对称矩阵不同特征值对应的特征向量必正交。</strong></li>
<li>根据上述结论，实对称矩阵<strong>必可以用『正交矩阵』相似对角化</strong>。</li>
</ul>
<blockquote>
<p>注：只有对相同特征值对应的特征向量（即同一个特征子空间的基）进行施密特正交化，才能保证正交化后的特征向量仍是其对应特征值的特征向量（仍是其对应的特征子空间的基）。</p>
<p>而实对称矩阵不同特征值对应的特征向量正交，故只需要对相同特征值的特征向量进行施密特正交化就可以得到正交矩阵，故实对称矩阵一定可以使用正交矩阵相似对角化（但可以<strong>用正交矩阵相似对角化的矩阵未必是实对称矩阵</strong>）。</p>
</blockquote>
<h3 id="实对称矩阵的合同">实对称矩阵的合同</h3>
<ol type="1">
<li>矩阵的合同</li>
</ol>
<p><strong><em>A</em></strong> 和 <strong><em>B</em></strong> 是两个同阶方阵，若存在可逆矩阵 <strong><em>C</em></strong>，使得 <span class="math inline">\(\boldsymbol{C}^{\text{T}}\boldsymbol{A}\boldsymbol{C} = \boldsymbol{B}\)</span>，则称 <strong><em>A</em></strong> 『<strong>合同</strong>』于 <strong><em>B</em></strong>，记作 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B}\)</span>。</p>
<p>矩阵合同的性质：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B},\boldsymbol{B} \simeq \boldsymbol{C}\Rightarrow \boldsymbol{A} \simeq \boldsymbol{C}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B} \Rightarrow \boldsymbol{A} \cong \boldsymbol{B} \Leftrightarrow r(\boldsymbol{A}) = r(\boldsymbol{B})\)</span></li>
</ul>
<ol start="2" type="1">
<li><strong>实对称矩阵的合同</strong></li>
</ol>
<p><strong><em>A</em></strong> 和 <strong><em>B</em></strong> 是两个同阶实对称矩阵，则 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B} \Leftrightarrow\)</span> <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 拥有相同的『<a href="#惯性定理">正、负惯性指数</a>』。</p>
<p>重要结论：</p>
<ul>
<li><strong>实对称矩阵闭可以合同对角化</strong>。<strong><em>A</em></strong> 是实对称矩阵，则必有可逆矩阵 <strong><em>C</em></strong>，使得 <span class="math inline">\(\boldsymbol{C}^{\text{T}}\boldsymbol{AC} = \boldsymbol{\Lambda}\)</span>，即 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{\Lambda}\)</span>。</li>
</ul>
<p>证：<strong><em>A</em></strong> 为实对称矩阵，则必存在正交矩阵 <strong><em>Q</em></strong>，使得 <span class="math inline">\(\boldsymbol{Q}^{-1}\boldsymbol{AQ} = \boldsymbol{\Lambda}\)</span>，因为 <span class="math inline">\(\boldsymbol{Q}^{-1} =\boldsymbol{Q}^{\text{T}}\)</span>，故 <span class="math inline">\(\boldsymbol{Q}^{\text{T}}\boldsymbol{AQ} = \boldsymbol{\Lambda}\)</span>，即 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{\Lambda}\)</span>。</p>
<blockquote>
<p>注：通过正交矩阵对角化只是合同对角化的一种特殊情形，此时 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span> 且 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{\Lambda}\)</span>。详见<a href="#正交变换法">正交变换法</a>。<br />
实际上即使不通过正交矩阵，仅仅通过可逆矩阵，就一定可以使实对称矩阵合同对角化。详见<a href="#配方法">配方法</a>。</p>
</blockquote>
<ul>
<li><strong>实对称矩阵相似必合同</strong>。<strong><em>A</em></strong> 和 <strong><em>B</em></strong> 是实对称矩阵，则 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B} \Rightarrow \boldsymbol{A} \simeq \boldsymbol{B}\)</span>。</li>
</ul>
<p>证 1：<strong><em>A</em></strong> 和 <strong><em>B</em></strong> 为同阶实对称矩阵，故必有正交矩阵 <span class="math inline">\(\boldsymbol{Q}_1,\boldsymbol{Q}_2\)</span>，使得</p>
<p><span class="math display">\[
\begin{aligned}
&amp; {\boldsymbol{Q}_1}^{-1}\boldsymbol{AQ}_1 = {\boldsymbol{Q}_1}^{\text{T}}\boldsymbol{AQ}_1 = \boldsymbol{\Lambda}_1 \\
&amp; {\boldsymbol{Q}_2}^{-1}\boldsymbol{BQ}_2 = {\boldsymbol{Q}_2}^{\text{T}}\boldsymbol{BQ}_2 = \boldsymbol{\Lambda}_2
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B}\)</span>，则必存在 <span class="math inline">\(\boldsymbol{\Lambda} = \boldsymbol{\Lambda}_1 = \boldsymbol{\Lambda}_2\)</span>，使得</p>
<p><span class="math display">\[
{\boldsymbol{Q}_1}^{\text{T}}\boldsymbol{AQ}_1 = \boldsymbol{\Lambda} = {\boldsymbol{Q}_2}^{\text{T}}\boldsymbol{BQ}_2
\]</span></p>
<p>等式两边左乘 <span class="math inline">\(\boldsymbol{Q}_2\)</span> 右乘 <span class="math inline">\({\boldsymbol{Q}_2}^{\text{T}}\)</span>，因为 <span class="math inline">\({\boldsymbol{Q}_2}^{\text{T}} = {\boldsymbol{Q}_2}^{-1}\)</span>，故</p>
<p><span class="math display">\[
\boldsymbol{Q}_2{\boldsymbol{Q}_1}^{\text{T}}\boldsymbol{AQ}_1{\boldsymbol{Q}_2}^{\text{T}} = \boldsymbol{B}
\]</span></p>
<p>令 <span class="math inline">\(\boldsymbol{C} = \boldsymbol{Q}_1{\boldsymbol{Q}_2}^{\text{T}}\)</span>，则</p>
<p><span class="math display">\[
\boldsymbol{C}^{\text{T}}\boldsymbol{A}\boldsymbol{C} = \boldsymbol{B}
\]</span></p>
<p>因为 <strong><em>C</em></strong> 是可逆矩阵，故 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B}\)</span>。</p>
<p>证 2：<span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B} \Rightarrow \lambda_{\boldsymbol{A}} = \lambda_{\boldsymbol{B}}\)</span>，因为 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 是实对称矩阵，故通过<a href="#正交变换法">正交变换法</a>得到的规范形的正、负惯性指数相同，故 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B}\)</span>。</p>
<blockquote>
<p>注：反之，<strong>实对称矩阵合同无法推出相似</strong>。</p>
</blockquote>
<h3 id="二次型及其标准形和规范形">二次型及其标准形和规范形</h3>
<ol type="1">
<li>实二次型</li>
</ol>
<p><em>n</em> 元变量 <span class="math inline">\(x_1,x_2,\ldots,x_n\)</span> 的二次多项式</p>
<p><span class="math display">\[
\begin{aligned}
f(x_1,x_2,\ldots,x_n) =  &amp;a_{11}{x_1}^2 + a_{12} x_1x_2 +  \cdots + a_{1n}x_1x_n + \\
&amp; a_{21}x_2x_1 + a_{22}{x_2}^2 +  \cdots + a_{2n}x_2x_n +\\
&amp; \cdots \cdots+\\
&amp;a_{n1}x_nx_1 + a_{n2} x_nx_2 +  \cdots + a_{nn}{x_n}^2 \\
\end{aligned}
\]</span></p>
<p>称为 『<strong><em>n</em> 元二次型</strong>』，若 <span class="math inline">\(a_{ij} \in \mathbb{R}\:(i,j=1,2,\ldots,n)\)</span>，则称为『<strong>实二次型</strong>』。</p>
<p>设 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}, \; \boldsymbol{A} = \begin{bmatrix} a_{11} &amp;a_{12} &amp;\cdots &amp;a_{1n} \\ a_{21} &amp;a_{22} &amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{n1} &amp;a_{n2} &amp;\cdots &amp;a_{nn} \end{bmatrix}\)</span>，则有</p>
<p><span class="math display">\[
\begin{aligned}
f(x_1,x_2,\ldots,x_n)
&amp; = [x_1,x_2,\ldots,x_n]\begin{bmatrix} a_{11} &amp;a_{12} &amp;\cdots &amp;a_{1n} \\  a_{21} &amp;a_{22} &amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{n1} &amp;a_{n2} &amp;\cdots &amp;a_{nn}  \end{bmatrix}\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix} \\
&amp; ={\boldsymbol{x}}^{\text{T}}\boldsymbol{Ax}
\end{aligned}
\]</span></p>
<p>称 <strong><em>A</em></strong> 为<strong>实二次型 <span class="math inline">\(f\)</span> 的矩阵</strong>，因为 <span class="math inline">\(a_{ij} = a_{ji}\)</span>，故 <strong><em>A</em></strong> 是实对称矩阵。</p>
<ol start="2" type="1">
<li>线性变换</li>
</ol>
<p>对于二次型 <span class="math inline">\(f(x_1,x_2,\ldots,x_n)\)</span>，若令</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp; x_1 = c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \\
&amp; x_2 = c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \\
&amp; \cdots \cdots \\
&amp; x_1 = c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n
\end{aligned}
\right.
\]</span></p>
<p>设 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} x_1 \\ x_2\\ \vdots \\ x_n \end{bmatrix},\; \boldsymbol{C} = \begin{bmatrix} c_{11} &amp;c_{12} &amp;\cdots &amp;c_{1n} \\ c_{21} &amp;c_{22} &amp;\cdots &amp;c_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ c_{n1} &amp;c_{n2} &amp;\cdots &amp;c_{nn} \end{bmatrix},\; \boldsymbol{y}= \begin{bmatrix} y_1 \\ y_2\\ \vdots \\ y_n \end{bmatrix}\)</span>，则有</p>
<p><span class="math display">\[
\boldsymbol{x} = \boldsymbol{Cy}
\]</span></p>
<p>称上式为从 <span class="math inline">\(x_1,x_2,\ldots,x_n\)</span> 到 <span class="math inline">\(y_1,y_2,\ldots,y_n\)</span> 的『<strong>线性变换</strong>』，若 <strong><em>C</em></strong> 是可逆矩阵，则称为『<strong>可逆线性变换</strong>』，若 <strong><em>C</em></strong> 是正交矩阵，则称为『<strong>正交变换</strong>』。</p>
<p>紧跟着继续探讨，可得</p>
<p><span class="math display">\[
{\boldsymbol{x}}^{\text{T}}\boldsymbol{Ax} = {(\boldsymbol{Cy})}^{\text{T}}\boldsymbol{A}(\boldsymbol{Cy}) = {\boldsymbol{y}}^{\text{T}}\left({\boldsymbol{C}}^{\text{T}} \boldsymbol{AC}\right) \boldsymbol{y}
\]</span></p>
<p>仅当 <span class="math inline">\({\boldsymbol{C}}^{\text{T}} \boldsymbol{AC} = \boldsymbol{B}\)</span> 即 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B}\)</span> 时，二次型 <span class="math inline">\(f(x_1,x_2,\ldots,x_n)\)</span> 可转化为 <span class="math inline">\(g(y_1,y_2,\ldots,y_n) = \boldsymbol{y}^{\text{T}}\boldsymbol{By}\)</span>。</p>
<p>即 <span class="math inline">\(\boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span> 可转化为 <span class="math inline">\(\boldsymbol{y}^{\text{T}}\boldsymbol{By}\)</span> 的<strong>充分必要条件</strong>为 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{B}\)</span>。</p>
<ol start="3" type="1">
<li>二次型的标准形和规范形</li>
</ol>
<p>二次型的『<strong>标准形</strong>』：二次型中<strong>只含平方项</strong>，即形如</p>
<p><span class="math display">\[
d_1{x_1}^2 + d_2{x_2}^2 + \cdots + d_n{x_n}^2
\]</span></p>
<p>二次型的『<strong>规范形</strong>』：标准形中的系数 <span class="math inline">\(d_i\;(i = 1,2,\ldots,n)\)</span> 仅为 1、-1、0 之一，即形如</p>
<p><span class="math display">\[
{x_1}^2 + \cdots + {x_p}^2 - {x_{p+1}}^2 - \cdots - {x_{p+q}}^2
\]</span></p>
<p>其中 <em>p</em>、<em>q</em> 为<a href="#惯性定理">正、负惯性指数</a>。</p>
<h3 id="惯性定理">惯性定理</h3>
<p>无论二次型通过何种可逆线性变换化为规范形或标准形，其正项个数 <em>p</em>、负项个数 <em>q</em> 都是不变的，<em>p</em> 称为『<strong>正惯性指数</strong>』，<em>q</em> 称为『<strong>负惯性指数</strong>』。</p>
<p><strong><em>A</em></strong> 是实对称矩阵 <span class="math inline">\(\Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda} \Rightarrow r(\boldsymbol{A}) =\)</span> 非零特征值的个数（按重数计），故 <span class="math inline">\(r(\boldsymbol{A}) = p+q\)</span>。</p>
<h3 id="正定二次型">正定二次型</h3>
<p><em>n</em> 元二次型 <span class="math inline">\(f(x_1,x_2,\ldots,x_n) = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span>，若对于任意 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} x_1 \\x_2 \\ \vdots \\ x_n \end{bmatrix} \neq \boldsymbol{0}\)</span>，均有 <span class="math inline">\(\boldsymbol{x}^{\text{T}}\boldsymbol{Ax} &gt; 0\)</span>，则称 <span class="math inline">\(f\)</span> 为『<strong>正定二次型</strong>』，称 <strong><em>A</em></strong> 为『<strong>正定矩阵</strong>』。</p>
<blockquote>
<p>注：正定矩阵的前提是实对称矩阵。</p>
</blockquote>
<p><strong>二次型正定的充要条件：</strong></p>
<p><em>n</em> 元二次型 <span class="math inline">\(f = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span> 正定</p>
<ul>
<li><span class="math inline">\(\Leftrightarrow\)</span> 对于 <span class="math inline">\(\forall \boldsymbol{x} \neq \boldsymbol{0}\)</span> 有 <span class="math inline">\(\boldsymbol{x}^{\text{T}}\boldsymbol{Ax} &gt; 0\)</span>。</li>
<li><span class="math inline">\(\Leftrightarrow f\)</span> 的正惯性指数 <span class="math inline">\(p = n\)</span>。</li>
<li><span class="math inline">\(\Leftrightarrow \boldsymbol{A}\)</span> 的特征值都大于零。</li>
<li><span class="math inline">\(\Leftrightarrow\)</span> 存在可逆矩阵 <strong><em>D</em></strong>，使得 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{D}^{\text{T}}\boldsymbol{D}\)</span>。</li>
<li><span class="math inline">\(\Leftrightarrow \boldsymbol{A} \simeq \boldsymbol{E}\)</span></li>
<li><span class="math inline">\(\Leftrightarrow \boldsymbol{A}\)</span> 的所有『顺序主子式』大于零。</li>
</ul>
<p><strong>二次型正定的必要条件：</strong></p>
<p><em>n</em> 元二次型 <span class="math inline">\(f = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span> 正定</p>
<ul>
<li><span class="math inline">\(\Rightarrow a_{ii} &gt; 0\;(i =1,2,\ldots,n)\)</span></li>
<li><span class="math inline">\(\Rightarrow\)</span> <strong><em>A</em></strong> 必可逆，且 <span class="math inline">\(\text{det}(\boldsymbol{A}) &gt; 0\)</span>。</li>
<li><span class="math inline">\(\Rightarrow \boldsymbol{A}^{\text{T}},\boldsymbol{A}^{-1},\boldsymbol{A}^*,\boldsymbol{A}^k\;(k \in \mathbb{N}_+)\)</span> 均正定。</li>
</ul>
<p><strong>重要结论：</strong></p>
<ul>
<li>若 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 正定，则 <span class="math inline">\(\boldsymbol{A} + \boldsymbol{B}\)</span> 正定，<span class="math inline">\(\begin{bmatrix} \boldsymbol{A} &amp;\boldsymbol{O}\\ \boldsymbol{O} &amp;\boldsymbol{B}\end{bmatrix}\)</span> 正定。</li>
<li>若 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 正定，则 <span class="math inline">\(\boldsymbol{AB}\)</span> 正定 <span class="math inline">\(\Leftrightarrow \boldsymbol{AB} = \boldsymbol{BA}\)</span>。</li>
</ul>
<blockquote>
<p>注：此处注意与正交矩阵区分。</p>
</blockquote>
<ul>
<li><strong><em>A</em></strong> 既正交又正定 <span class="math inline">\(\Leftrightarrow \boldsymbol{A} = \boldsymbol{E}\)</span>。</li>
</ul>
<h2 id="化二次型为标准形或规范形">化二次型为标准形或规范形</h2>
<h3 id="正交变换法">正交变换法</h3>
<p>将二次型 <span class="math inline">\(f = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span> 化为标准形，即将 <span class="math inline">\(\boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span> 化为 <span class="math inline">\(\boldsymbol{y}^{\text{T}}\boldsymbol{\Lambda y}\)</span>，其充分必要条件是 <span class="math inline">\(\boldsymbol{A} \simeq \boldsymbol{\Lambda}\)</span>。因为实对称矩阵必可以使用正交矩阵相似对角化，这是合同对角化的一种特殊情形，其本质是<strong>通过相似理论求出正交矩阵 <em>Q</em>，使得 <span class="math inline">\(\boldsymbol{Q}^{-1}\boldsymbol{AQ} = \boldsymbol{Q}^{\text{T}}\boldsymbol{AQ} = \boldsymbol{\Lambda}\)</span>。</strong></p>
<p>对于 <em>n</em> 元二次型 <span class="math inline">\(f = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax}\)</span></p>
<ol type="1">
<li>求 <strong><em>A</em></strong> 的特征值 <span class="math inline">\(\lambda_i \;(i =1,2,\ldots,n)\)</span>。</li>
<li>根据特征值 <span class="math inline">\(\lambda_i \;(i =1,2,\ldots,n)\)</span> 求出 <em>n</em> 个线性无关的特征向量 <span class="math inline">\(\boldsymbol{\xi}_1,\boldsymbol{\xi}_2,\ldots,\boldsymbol{\xi}_n\)</span>。</li>
<li>对相同特征值对应的特征向量进行正交化、单位化，得到 <span class="math inline">\(\boldsymbol{\eta}_1, \boldsymbol{\eta}_2,\ldots,\boldsymbol{\eta}_n\)</span>。</li>
<li>设 <span class="math inline">\(\boldsymbol{Q} = [\boldsymbol{\eta}_1, \boldsymbol{\eta}_2,\ldots,\boldsymbol{\eta}_n]\)</span>，则 <strong><em>Q</em></strong> 为正交矩阵，且 <span class="math inline">\(\boldsymbol{Q}^{-1}\boldsymbol{AQ} = \boldsymbol{Q}^{\text{T}}\boldsymbol{AQ} = \boldsymbol{\Lambda}\)</span>。</li>
</ol>
<p>则</p>
<p><span class="math display">\[
f = \boldsymbol{x}^{\text{T}}\boldsymbol{Ax} \xlongequal{\boldsymbol{x} = \boldsymbol{Qy}} {(\boldsymbol{Qy})}^{\text{T}}\boldsymbol{A}(\boldsymbol{Qy}) = \boldsymbol{y}^{\text{T}}\boldsymbol{Q}^{\text{T}}\boldsymbol{AQy} =  \boldsymbol{y}^{\text{T}}\boldsymbol{\Lambda y}
\]</span></p>
<blockquote>
<p>注：因为正交变换法本质上是相似对角化，故得到的 <span class="math inline">\(\Lambda\)</span> 主对角线是 <strong><em>A</em></strong> 的特征值。所以<strong>正交变换法只能化为标准形，不能保证化为规范形</strong>。</p>
</blockquote>
<h3 id="配方法">配方法</h3>
<p>即使不通过正交矩阵，实对称矩阵也必可以合同对角化，那就是使用配方法：</p>
<ul>
<li>若二次型含有平方项，则将某个变量的平方项与其有关的项合并在一起，配成一个完全平方项，直至配完所有项。</li>
<li>若二次型不含平方项，则通过平方差公式创造平方项，然后再按照上一个步骤配方。</li>
</ul>
<blockquote>
<p>注：配方法必可以将二次型化为规范形。</p>
</blockquote>
<h2 id="结句">结句</h2>
<p>行列式、矩阵的幂、可逆矩阵、伴随矩阵、特征值和特征向量、相似理论、矩阵的合同、实对称矩阵、正交矩阵、正定矩阵所探讨的对象都是『方阵』。</p>
<p>矩阵的初等变换、矩阵的秩、向量组、线性方程组所探讨的对象未必是方阵。</p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>向量空间和线性方程组解的结构</title>
    <url>/2022/09/22/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>线性代数-向量空间和线性方程组解的结构。</p>
<span id="more"></span>
<hr />
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#线性相关和线性无关">线性相关和线性无关</a></li>
<li><a href="#向量组的秩">向量组的秩</a></li>
<li><a href="#向量空间和基">向量空间和基</a></li>
</ul></li>
<li><a href="#以向量的角度定义矩阵和矩阵乘法">以向量的角度定义矩阵和矩阵乘法</a></li>
<li><a href="#线性方程组解的结构">线性方程组解的结构</a>
<ul>
<li><a href="#矩阵的零空间">矩阵的零空间</a></li>
<li><a href="#矩阵的列空间">矩阵的列空间</a></li>
<li><a href="#同解和公共解">同解和公共解</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="线性相关和线性无关">线性相关和线性无关</h3>
<ol type="1">
<li>向量</li>
</ol>
<p>向量（vector）这一概念被提出用以<strong>表示一组有序的数据（即数组）</strong>。<em>n</em> 个数构成的一个有序数组被称为一个 <em>n</em> 维『<strong>向量</strong>』。设 <span class="math inline">\(\boldsymbol{\alpha}=[a_1,a_2,\ldots,a_n]^{\text{T}}\)</span>，则 <span class="math inline">\(\boldsymbol{\alpha}\)</span> 是一个 <em>n</em> 维『<strong>列向量</strong>』，<span class="math inline">\(\boldsymbol{\alpha}^{\text{T}} = [a_1,a_2,\ldots,a_n]\)</span> 是一个 <em>n</em> 维『<strong>行向量</strong>』。</p>
<ul>
<li>一般情况下，向量默认为列向量，使用列向量的转置来表示行向量。</li>
<li><em>n</em> 维列向量可看作 <em>n</em> 行 1 列的矩阵，<em>n</em> 维行向量可看作 1 行 <em>n</em> 列的矩阵。</li>
</ul>
<ol start="2" type="1">
<li>线性组合 &amp; 线性表示</li>
</ol>
<p>设有 <em>n</em> 个 <em>m</em> 维向量 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 与 <em>n</em> 个数 <span class="math inline">\(k_1,k_2,\ldots,k_n\)</span>，则</p>
<p><span class="math display">\[
k_1\boldsymbol{\boldsymbol{\alpha}}_1 + k_2\boldsymbol{\alpha}_2 +\cdots+ k_n\boldsymbol{\alpha}_n
\]</span></p>
<p>称为向量组 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 的『<strong>线性组合</strong>』。若向量 <span class="math inline">\(\boldsymbol{\beta}\)</span> 能表示为向量组 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 的线性组合，则称向量 <span class="math inline">\(\boldsymbol{\beta}\)</span> 能被向量组 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 『<strong>线性表示</strong>』。</p>
<p>线性组合可以用<a href="#以向量的角度定义矩阵和矩阵乘法">矩阵乘列向量的方式</a>表示：</p>
<p><span class="math display">\[
k_1 \boldsymbol{\alpha}_1 + k_2\boldsymbol{\alpha}_2 +\cdots+ k_n\boldsymbol{\alpha}_n = [\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n] \left[ \begin{matrix}k_1 \\k_2\\ \vdots \\k_n\end{matrix}\right]
\]</span></p>
<blockquote>
<p>零向量可以被任何向量组线性表示。</p>
</blockquote>
<ol start="3" type="1">
<li>线性相关</li>
</ol>
<p>若存在一组<strong>不全为零</strong>的数 <span class="math inline">\(k_1,k_2,\ldots,k_n\)</span>，使得向量组 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 的线性组合</p>
<p><span class="math display">\[
k_1\boldsymbol{\alpha}_1 + k_2\boldsymbol{\alpha}_2 +\cdots+ k_n\boldsymbol{\alpha}_n = 0
\]</span></p>
<p>则称 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 『<strong>线性相关</strong>』。</p>
<ol start="4" type="1">
<li>线性无关</li>
</ol>
<p>若不存在一组<strong>不全为零</strong>的数 <span class="math inline">\(k_1,k_2,\ldots,k_n\)</span>，使得 <span class="math inline">\(k_1\boldsymbol{\alpha}_1 + k_2\boldsymbol{\alpha}_2+\cdots+ k_n\boldsymbol{\alpha}_n = 0\)</span> 成立，即当且仅当 <span class="math inline">\(k_1 = k_2 =\cdots= k_n = 0\)</span> 时，才有 <span class="math inline">\(k_1\boldsymbol{\alpha}_1 + k_2\boldsymbol{\alpha}_2+\cdots+ k_n\boldsymbol{\alpha}_n = 0\)</span> 成立，则称 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 『<strong>线性无关</strong>』或『线性独立』。</p>
<blockquote>
<p>一个确定的向量组若不线性相关，则线性无关。反之成立。</p>
</blockquote>
<ol start="5" type="1">
<li>重要结论</li>
</ol>
<p>若向量组中某个向量可以被其他向量线性表示，则向量组线性相关。故含有零向量的向量组一定线性相关。</p>
<h3 id="向量组的秩">向量组的秩</h3>
<p>向量组的秩等于向量组的『<strong>极大线性无关组</strong>』的向量个数，即向量组内最多找到 <em>r</em> 个两两线性无关的向量。</p>
<ul>
<li><p>向量组的秩等于向量组张成的<a href="#向量空间和基">向量空间的维数</a>，向量组的极大线性无关组是向量组张成的向量空间的一组<a href="#向量空间和基">基</a>。</p></li>
<li><p>两向量组 <span class="math inline">\(A: \boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots ,\boldsymbol{\alpha}_s, \; B:\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_t\)</span> 中的向量『<strong>同维</strong>』，若 <em>A</em> 中的向量都可以由 <em>B</em> 线性表示，且 <em>B</em> 中的向量都可以由 <em>A</em> 线性表示 <span class="math inline">\(\Leftrightarrow A \cong B\)</span>。</p></li>
<li><p>向量组 <em>A</em> 和 <em>B</em> 中的向量同维，则 <span class="math inline">\(A \cong B \Leftrightarrow r(A) = r(B) = r(A,B)\)</span>。</p></li>
</ul>
<h3 id="向量空间和基">向量空间和基</h3>
<ol start="0" type="1">
<li>向量运算</li>
</ol>
<p>对于列向量 <span class="math inline">\(\boldsymbol{\alpha} = [a_1,a_2,\ldots,a_n]^{\text{T}}\)</span> 和 <span class="math inline">\(\boldsymbol{\beta} = [b_1,b_2,\ldots,b_n]^{\text{T}}\)</span>。</p>
<ul>
<li>向量加法：<span class="math inline">\(\boldsymbol{\alpha} + \boldsymbol{\beta} = [a_1+b_1,a_2+b_2,\ldots,a_n+b_n]^{\text{T}}\)</span>。</li>
<li>数乘：<span class="math inline">\(k\boldsymbol{\alpha} = [ka_1,ka_2,\ldots,ka_n]^{\text{T}}\)</span>。</li>
<li>标准内积：<span class="math inline">\(\langle \boldsymbol{\alpha}, \boldsymbol{\beta}\rangle = \boldsymbol{\alpha} \cdot \boldsymbol{\beta} = \boldsymbol{\alpha}^{\text{T}}\boldsymbol{\beta} = \boldsymbol{\beta} ^{\text{T}}\boldsymbol{\alpha} = a_1b_1 + a_2b_2 +\ldots+a_nb_n\)</span>。</li>
<li>向量的模：<span class="math inline">\(\| \boldsymbol{\alpha} \| = \sqrt{\boldsymbol{\alpha} \cdot \boldsymbol{\alpha}} = \sqrt{\boldsymbol{\alpha}^{\text{T}}\boldsymbol{\alpha}}\)</span>。</li>
<li><span class="math inline">\(\boldsymbol{\alpha} \perp \boldsymbol{\beta} \Leftrightarrow \boldsymbol{\alpha} \cdot \boldsymbol{\beta} = 0\)</span>。</li>
</ul>
<ol type="1">
<li>向量空间</li>
</ol>
<blockquote>
<p>向量空间的公理化定义：</p>
<p><span class="math inline">\(\mathbf{F}\)</span> 是一个域，<em>V</em> 是一个非空集合，<em>V</em> 在 <span class="math inline">\(\mathbf{F}\)</span> 上对两种运算封闭：</p>
<ul>
<li>向量加法：若 <span class="math inline">\(\boldsymbol{v,}\boldsymbol{w} \in V\)</span>，则 <span class="math inline">\(\boldsymbol{v} + \boldsymbol{w} \in V\)</span>。</li>
<li>数乘：若 <span class="math inline">\(\lambda \in \mathbf{F},\;\boldsymbol{v} \in V\)</span>，则 <span class="math inline">\(\lambda \boldsymbol{v} \in V\)</span>。</li>
</ul>
<p>且这两种运算满足向量空间的八条公理，则 <em>V</em> 是 <span class="math inline">\(\mathbf{F}\)</span> 上的一个『<strong>向量空间</strong>』。</p>
</blockquote>
<p>简单定义：<span class="math inline">\(\mathbb{R}^n\)</span> 是<strong>所有 <em>n</em> 维实向量的集合</strong>，<span class="math inline">\(\mathbb{R}^n\)</span> 内任意向量组的线性组合仍属于 <span class="math inline">\(\mathbb{R}^n\)</span>，所以 <span class="math inline">\(\mathbb{R}^n\)</span> 是一个向量空间。</p>
<blockquote>
<p><span class="math inline">\(\mathbb{R}^n\)</span> 是最常见的向量空间。如果 <span class="math inline">\(\mathbb{R}^n\)</span> 不仅定义了向量加法和数乘运算，还定义了向量内积运算，则 <span class="math inline">\(\mathbb{R}^n\)</span> 是『欧氏空间』。</p>
</blockquote>
<p>除 <span class="math inline">\(\mathbb{R}^n\)</span> 外，还有其他的向量空间，如：</p>
<ul>
<li><span class="math inline">\(\mathbb{R}^n\)</span> 的子空间。</li>
<li>只含有零向量的向量空间。</li>
</ul>
<blockquote>
<p>向量空间一定含有零向量。</p>
</blockquote>
<ol start="2" type="1">
<li>子空间</li>
</ol>
<p>若集合 <em>W</em> 是向量空间 <em>V</em> 的子集，且 <em>W</em> 也是一个向量空间，则称 <em>W</em> 是 <em>V</em> 的『子空间』。</p>
<ol start="3" type="1">
<li>张成</li>
</ol>
<p>向量空间 <em>V</em> 中一向量组 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 的所有线性组合构成的向量集合称为这个向量组的『张成』，记作 <span class="math inline">\(\text{span} \{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\}\)</span>。</p>
<ul>
<li><span class="math inline">\(\text{span} \{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\}\)</span> 一定是 <em>V</em> 的子空间。</li>
<li><span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 的极大线性无关组是 <span class="math inline">\(\text{span} \{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\}\)</span> 的一组基。</li>
<li>如果 <span class="math inline">\(\text{span}\{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\} = V\)</span>，即 <em>V</em> 中的所有向量都能被 <span class="math inline">\(\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 线性表示，则称 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 张成 <em>V</em>。</li>
</ul>
<ol start="4" type="1">
<li>基</li>
</ol>
<p>若向量空间 <em>V</em> 中一向量组 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 满足：</p>
<ul>
<li>是线性无关的。</li>
<li>张成 <em>V</em>，即 <span class="math inline">\(\text{span} \{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\} = V\)</span>。</li>
</ul>
<p>则 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 是向量空间 <em>V</em> 的一组『<strong>基</strong>』。所有基中含有的向量数目相同，表示向量空间的『<strong>维数</strong>』。</p>
<p><strong>一组基就是向量空间内的一个极大线性无关组，向量空间的维数等于向量空间内任意向量组的秩的最大值，即向量空间内任意线性无关组的最大向量个数。</strong></p>
<blockquote>
<p>注：向量空间的维数与向量的维数是不同的概念。仅当向量空间是 <span class="math inline">\(\mathbb{R}^n\)</span> 时，向量空间的维度等于向量空间中向量的维度等于 <em>n</em>。</p>
</blockquote>
<p><em>V</em> 上的任意向量 <strong><em>v</em></strong> 都可以被基线性表示：</p>
<p><span class="math display">\[
\boldsymbol{v} = x_1\boldsymbol{\alpha}_1 + x_2\boldsymbol{\alpha}_2 +\cdots+x_n\boldsymbol{\alpha}_n = \left[\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\right]\left[\begin{matrix}x_1\\x_2\\ \vdots \\ x_n\end{matrix}\right]
\]</span></p>
<p>其中 <span class="math inline">\([x_1,x_2,\ldots,x_n]^{\text{T}}\)</span> 称为 <strong><em>v</em></strong> 的『<strong>坐标</strong>』。</p>
<ol start="5" type="1">
<li>规范正交基</li>
</ol>
<p>欧氏空间 <span class="math inline">\(\mathbb{R}^n\)</span> 的标准基 <span class="math inline">\(\boldsymbol{e}_1 = [1, 0, 0, \ldots,0]^{\text{T}}, \boldsymbol{e}_2 = [0, 1, 0,\ldots,0]^{\text{T}}, \ldots, \boldsymbol{e}_n = [0,\ldots,0,0,1]^{\text{T}}\)</span> 由一组两两正交的单位向量构成。这种标准基具有优良的性质，即在『<strong>正交变换</strong>』后依然会得到一组两两正交的向量构成的基。</p>
<p>将欧氏空间的标准基推广到所有向量空间，把一组两两正交的单位向量构成的基称为『<strong>标准正交基</strong>』，或称『<strong>规范正交基</strong>』。</p>
<p>任何一个线性无关的向量组都可以通过『<strong>施密特正交化</strong>』得到一个等价的正交向量组。即向量空间的任何一组基都可以使用施密特正交化得到正交基，再单位化得到规范正交基。</p>
<p>若 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 是一组基，则：</p>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{\beta} _1 &amp;= \boldsymbol{\alpha}_1 \\
\boldsymbol{\beta}_2 &amp;= \boldsymbol{\alpha}_2 -\frac{\langle\boldsymbol{\alpha}_2,\boldsymbol{\beta}_1\rangle}{\langle\boldsymbol{\beta}_1, \boldsymbol{\beta}_1\rangle}\boldsymbol{\beta}_1 \\
&amp;\dots\\
\boldsymbol{\beta}_n &amp;=\boldsymbol{\alpha}_n - \frac{\langle\boldsymbol{\alpha}_n,\boldsymbol{\beta}_1\rangle}{\langle\boldsymbol{\beta}_1, \boldsymbol{\beta}_1\rangle}\boldsymbol{\beta}_1 -\frac{\langle\boldsymbol{\alpha}_n,\boldsymbol{\beta}_2\rangle}{\langle\boldsymbol{\beta}_2, \boldsymbol{\beta}_2\rangle}\boldsymbol{\beta}_2 - \cdots-\frac{\langle\boldsymbol{\alpha}_n,\boldsymbol{\beta}_{m-1}\rangle}{\langle\boldsymbol{\beta}_{n-1}, \boldsymbol{\beta}_{n-1}\rangle}\boldsymbol{\beta}_{n-1}
\end{aligned}
\]</span></p>
<p>则 <span class="math inline">\(\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n\)</span> 是一组与 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 等价的正交基，再令</p>
<p><span class="math display">\[
\boldsymbol{e}_i = \frac{\boldsymbol{\beta}_i}{\|\boldsymbol{\beta}_i\|}\;(i = 1,2,\ldots,n)
\]</span></p>
<p>可得一组与 <span class="math inline">\(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\)</span> 等价的规范正交基 <span class="math inline">\(\boldsymbol{e}_1,\boldsymbol{e}_2,\ldots,\boldsymbol{e}_n\)</span>。</p>
<blockquote>
<p>注：施密特正交化的对象是<strong>同一向量空间</strong>的基向量，经过施密特正交化后仍是该向量空间的基。不同特征值对应的特征向量属于不同『特征子空间』，不能使用施密特正交化。</p>
</blockquote>
<ol start="6" type="1">
<li>基变换和坐标变换</li>
</ol>
<p>若 <span class="math inline">\([\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\)</span> 和 <span class="math inline">\([\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n]\)</span> 是向量空间 <em>V</em> 的两组基，且</p>
<p><span class="math display">\[
[\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n] = [\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\boldsymbol{C}
\]</span></p>
<p>则矩阵 <strong><em>C</em></strong> 称为由基 <span class="math inline">\([\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\)</span> 到基 <span class="math inline">\([\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n]\)</span> 的『<strong>过渡矩阵</strong>』。</p>
<p>因为向量可表示为 <span class="math inline">\(\boldsymbol{v} = \left[\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\right]\left[\begin{matrix}x_1\\x_2\\ \vdots \\ x_n\end{matrix}\right] =\left[\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n\right]\left[\begin{matrix}y_1\\y_2\\ \vdots \\ y_n\end{matrix}\right]\)</span>，故 <span class="math inline">\(\left[\begin{matrix}x_1\\x_2\\ \vdots \\ x_n\end{matrix}\right] = \boldsymbol{C}\left[\begin{matrix}y_1\\y_2\\ \vdots \\ y_n\end{matrix}\right]\)</span>。</p>
<p>若 <span class="math inline">\([\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\)</span> 是一组规范正交基，且</p>
<p><span class="math display">\[
[\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n] = [\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\boldsymbol{C}
\]</span></p>
<p>则 <span class="math inline">\([\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_n]\)</span> 是规范正交基 <span class="math inline">\(\Leftrightarrow \boldsymbol{C}\)</span> 是正交矩阵。</p>
<h2 id="以向量的角度定义矩阵和矩阵乘法">以向量的角度定义矩阵和矩阵乘法</h2>
<p><strong>一个 <em>m</em> 行 <em>n</em> 列的矩阵就是 <em>n</em> 个 <em>m</em> 维列向量</strong>，当然也可认为是 <em>m</em> 个 <em>n</em> 维行向量：</p>
<p><span class="math display">\[
\boldsymbol{A}_{m \times n} = [\boldsymbol{v}_1, \boldsymbol{v}_2, \ldots, \boldsymbol{v}_n] = 
\left[
\begin{matrix}
{\boldsymbol{w}_1}^{\text{T}}\\
{\boldsymbol{w}_2}^{\text{T}}\\
\vdots \\
{\boldsymbol{w}_m}^{\text{T}}
\end{matrix}
\right] 
\; (\boldsymbol{v}_{1,2,\ldots,n} \in \mathbb{R}^m,\; \boldsymbol{w}_{1,2,\ldots,m} \in \mathbb{R}^n)
\]</span></p>
<p>矩阵的主元列是线性无关的，且自由列可由主元列线性表示，故矩阵的主元列是矩阵的列向量组的极大线性无关组。</p>
<p>故引出矩阵的秩的第二种定义：<strong>矩阵的秩 = 矩阵的列向量组的秩 = 矩阵的行向量组的秩 = 矩阵的列（或行）向量组张成的向量空间的维数。</strong></p>
<p><strong>矩阵乘向量：</strong></p>
<ol type="1">
<li>矩阵乘列向量：<strong><em>Ax</em></strong> 表示 <strong><em>A</em></strong> 的列向量组的线性组合：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A} \boldsymbol{x} = [\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n]\left[ \begin{matrix}x_1 \\x_2\\ \vdots \\x_n\end{matrix}\right] = x_1\boldsymbol{\alpha}_1 + x_2\boldsymbol{\alpha}_2+\cdots+x_n\boldsymbol{\alpha}_n
\]</span></p>
<ol start="2" type="1">
<li>矩阵称列向量：<strong><em>Ax</em></strong> 表示 <strong><em>A</em></strong> 的行向量组与列向量 <strong><em>x</em></strong> 的内积：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A} \boldsymbol{x} = \left[ \begin{matrix} {\boldsymbol{\alpha}_1}^{\text{T}} \\{\boldsymbol{\alpha}_2}^{\text{T}}\\ \vdots \\ {\boldsymbol{\alpha}_m}^{\text{T}} \end{matrix}\right] \boldsymbol{x}= \left[ \begin{matrix} {\boldsymbol{\alpha}_1}^{\text{T}} \cdot \boldsymbol{x} \\ {\boldsymbol{\alpha}_2}^{\text{T}} \cdot \boldsymbol{x}\\ \vdots \\ {\boldsymbol{\alpha}_m}^{\text{T}} \cdot \boldsymbol{x}\end{matrix}\right]
\]</span></p>
<ol start="3" type="1">
<li>行向量乘矩阵：<strong><em>x</em></strong><sup>T</sup><strong><em>B</em></strong> 表示 <strong><em>B</em></strong> 的行向量组的线性组合：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{x}^{\text{T}}\boldsymbol{B} = [x_1,x_2,\ldots,x_n]\left[
\begin{matrix}
{\boldsymbol{\beta}_1}^{\text{T}}\\
{\boldsymbol{\beta}_2}^{\text{T}}\\
\vdots \\
{\boldsymbol{\beta_n}}^{\text{T}}
\end{matrix}
\right]
= x_1 {\boldsymbol{\beta}_1}^{\text{T}} + x_2 {\boldsymbol{\beta}_2}^{\text{T}} + \cdots + x_n {\boldsymbol{\beta}_n}^{\text{T}}
\]</span></p>
<ol start="4" type="1">
<li>行向量乘矩阵：<strong><em>x</em></strong><sup>T</sup><strong><em>B</em></strong> 表示 <strong><em>B</em></strong> 的列向量组与行向量 <strong><em>x</em></strong><sup>T</sup> 的内积：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{x}^{\text{T}}\boldsymbol{B} = \boldsymbol{x}^{\text{T}}
\left[
\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_s
\right]
= \left[
\boldsymbol{x}^{\text{T}} \cdot \boldsymbol{\beta}_1,\boldsymbol{x}^{\text{T}}\cdot \boldsymbol{\beta}_2,\ldots,\boldsymbol{x}^{\text{T}}\cdot\boldsymbol{\beta}_s
\right]
\]</span></p>
<p><strong>矩阵乘矩阵：</strong></p>
<ol type="1">
<li><strong><em>AB</em></strong> 表示矩阵 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 的每个列向量相乘，即转化为矩阵乘列向量的形式：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s} = \boldsymbol{A}[\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_s] = [\boldsymbol{A\beta}_1,\boldsymbol{A\beta}_2,\ldots,\boldsymbol{A\beta}_s]
\]</span></p>
<ol start="2" type="1">
<li>当然 <strong><em>AB</em></strong> 也可以表示矩阵 <strong><em>B</em></strong> 与 <strong><em>A</em></strong> 的每个行向量相乘，即转化为行向量乘矩阵的形式：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s} =
\left[
\begin{matrix}
{\boldsymbol{\alpha}_1}^{\text{T}}\\
{\boldsymbol{\alpha}_2}^{\text{T}}\\
\vdots \\
{\boldsymbol{\alpha}_m}^{\text{T}}
\end{matrix}
\right] \boldsymbol{B} = 
\left[
\begin{matrix}
{\boldsymbol{\alpha}_1}^{\text{T}}\boldsymbol{B}\\
{\boldsymbol{\alpha}_2}^{\text{T}}\boldsymbol{B}\\
\vdots \\
{\boldsymbol{\alpha}_m}^{\text{T}}\boldsymbol{B}
\end{matrix}
\right]
\]</span></p>
<ol start="3" type="1">
<li><strong><em>AB</em></strong> 表示 <strong><em>A</em></strong> 的行向量组与 <strong><em>B</em></strong> 的列向量组的内积：</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s} = \left[ \begin{matrix} {\boldsymbol{\alpha}_1}^{\text{T}} \\ {\boldsymbol{\alpha}_2}^{\text{T}}\\ \vdots \\{\boldsymbol{\alpha}_m}^{\text{T}} \end{matrix}\right] [\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\ldots,\boldsymbol{\beta}_s]= 
\left[
\begin{matrix}
{\boldsymbol{\alpha}_1}^{\text{T}} \cdot \boldsymbol{\beta}_1 &amp;{\boldsymbol{\alpha}_1}^{\text{T}} \cdot \boldsymbol{\beta}_2&amp; \cdots &amp;{\boldsymbol{\alpha}_1}^{\text{T}} \cdot\boldsymbol{\beta}_s \\
{\boldsymbol{\alpha}_2}^{\text{T}} \cdot \boldsymbol{\beta}_1 &amp;{\boldsymbol{\alpha}_2}^{\text{T}} \cdot \boldsymbol{\beta}_2&amp; \cdots &amp;{\boldsymbol{\alpha}_2}^{\text{T}} \cdot\boldsymbol{\beta}_s\\ 
\vdots &amp; \vdots &amp;  \ddots&amp; \vdots\\ 
{\boldsymbol{\alpha}_m}^{\text{T}} \cdot \boldsymbol{\beta}_1 &amp;{\boldsymbol{\alpha}_m}^{\text{T}} \cdot \boldsymbol{\beta}_2&amp; \cdots &amp;{\boldsymbol{\alpha}_m}^{\text{T}} \cdot\boldsymbol{\beta}_s
\end{matrix}
\right]
\]</span></p>
<h2 id="线性方程组解的结构">线性方程组解的结构</h2>
<p>线性方程组可表示为矩阵与列向量相乘的形式：</p>
<ul>
<li>齐次方程组：<span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span>。</li>
<li>非齐次方程组：<span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span>。</li>
</ul>
<p><strong><em>A</em></strong> 为 <em>m</em> 行 <em>n</em> 列的矩阵，可视为 <em>n</em> 个 <em>m</em> 维列向量组。<strong>0</strong> 为零向量，<strong><em>b</em></strong> 为 <em>m</em> 维列向量。<strong><em>x</em></strong> 为 <em>n</em> 维列向量 <span class="math inline">\([x_1,x_2,\ldots,x_n]^{\text{T}}\)</span>，若当 <span class="math inline">\(\boldsymbol{x} = \boldsymbol{v}\)</span> 时方程组成立，则 <strong><em>v</em></strong> 为方程组的一个『<strong>解向量</strong>』。</p>
<h3 id="矩阵的零空间">矩阵的零空间</h3>
<p>假设向量 <span class="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2\)</span> 是方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的任意两个解向量，<em>k</em> 为任意常数，则必有</p>
<p><span class="math display">\[
\boldsymbol{A}(k\boldsymbol{v}_1) = k\boldsymbol{A}\boldsymbol{v}_1 = 0,\;\boldsymbol{A}(\boldsymbol{v}_1 + \boldsymbol{v}_2) = \boldsymbol{A}\boldsymbol{v}_1 + \boldsymbol{A}\boldsymbol{v}_2 = \boldsymbol{0}
\]</span></p>
<p>即 <span class="math inline">\(k\boldsymbol{v}_1\)</span> 和 <span class="math inline">\(\boldsymbol{v}_1+\boldsymbol{v}_2\)</span> 仍是方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的解向量，故<strong>方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的解向量的集合是一个向量空间</strong>。这个空间称为方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的『<strong>解空间</strong>』，也称矩阵 <strong><em>A</em></strong> 的『<strong>零空间</strong>』，记作 <span class="math inline">\(N(\boldsymbol{A})\)</span>。<span class="math inline">\(N(\boldsymbol{A})\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 的子空间。即零空间可表示为：</p>
<p><span class="math display">\[
N(\boldsymbol{A}) = \{\boldsymbol{x} \in \mathbb{R}^n \vert  \boldsymbol{Ax} = \boldsymbol{0}\}
\]</span></p>
<ul>
<li><p>如果 <strong><em>A</em></strong> 列满秩，即 <strong><em>A</em></strong> 的列向量组线性无关，根据<a href="#线性相关和线性无关">线性无关</a>的定义可知当且仅当 <strong><em>x</em></strong> 为零向量时 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 成立。即方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 有唯一（零）解，无非零解。</p></li>
<li><p>如果 <strong><em>A</em></strong> 列不满秩，即 <span class="math inline">\(r(\boldsymbol{A}) &lt; n\)</span>，则 <strong><em>A</em></strong> 的列向量组线性相关，根据<a href="#线性相关和线性无关">线性相关</a>的定义，方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 必有非零解，假设非零解向量为 <strong><em>v</em></strong>，即 <span class="math inline">\(\boldsymbol{v} \in N(\boldsymbol{A})\)</span>，则 <span class="math inline">\(k\boldsymbol{v} \in N(\boldsymbol{A})\)</span>，<em>k</em> 为任意常数，故方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 有无穷多解。</p>
<blockquote>
<p>推论：若 <strong><em>A</em></strong> 为方阵，则 <span class="math inline">\(\text{det}(\boldsymbol{A})= 0 \Leftrightarrow \boldsymbol{Ax} = \boldsymbol{0}\)</span> 有非零解。</p>
</blockquote></li>
<li><p>如果 <span class="math inline">\(m &lt; n\)</span>，即 <strong><em>A</em></strong> 的列向量个数大于列向量的维数，则 <strong><em>A</em></strong> 的列向量组必线性相关，则方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 必有（无穷）非零解。</p></li>
<li><p><span class="math inline">\(N(\boldsymbol{A})\)</span> 的一组基称为方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的『<strong>基础解系</strong>』，<span class="math inline">\(N(\boldsymbol{A})\)</span> 的维数取决于自由未知量的个数：<span class="math inline">\(\text{dim(}N(\boldsymbol{A})) = n -r(\boldsymbol{A})\)</span>，所以基础解系中有 <span class="math inline">\(n - r(\boldsymbol{A})\)</span> 个线性无关的向量。</p></li>
</ul>
<h3 id="矩阵的列空间">矩阵的列空间</h3>
<p>由 <strong><em>A</em></strong> 的列向量组张成的向量空间称为矩阵 <strong><em>A</em></strong> 的『<strong>列空间</strong>』，记作</p>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{A} &amp;= [\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n] \\
C(\boldsymbol{A}) &amp;= \text{span}\{\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\ldots,\boldsymbol{\alpha}_n\}
\end{aligned}
\]</span></p>
<p>列向量的维数为 <em>m</em>，故 <span class="math inline">\(C(\boldsymbol{A})\)</span> 是 <span class="math inline">\(\mathbb{R}^m\)</span> 的子空间。矩阵 <strong><em>A</em></strong> 的主列是 <strong><em>A</em></strong> 的列向量组的极大线性无关组，故<strong>矩阵 <em>A</em> 的主列是 <span class="math inline">\(C(\boldsymbol{A})\)</span> 的一组基</strong>，<strong>矩阵列空间的维数等于矩阵主列的个数等于矩阵的秩</strong>，即 <span class="math inline">\(\text{dim}(C(\boldsymbol{A})) = r(\boldsymbol{A})\)</span>。</p>
<p><span class="math inline">\(\boldsymbol{Ax}\)</span> 表示 <strong><em>A</em></strong> 的列向量组的线性组合，所以方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 有解等价于 <strong><em>b</em></strong> 可以被 <strong><em>A</em></strong> 的列向量组线性表示，等价于 <span class="math inline">\(\boldsymbol{b} \in C(\boldsymbol{A})\)</span>。</p>
<ul>
<li><p>当且仅当 <span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}])\)</span> 时，<span class="math inline">\(\boldsymbol{b} \in C(\boldsymbol{A})\)</span>，故非齐次线性方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 有解的充分必要条件是：<span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}])\)</span>。</p>
<blockquote>
<p><span class="math inline">\(\boldsymbol{b} \in C(\boldsymbol{A})\)</span>，矩阵 <strong><em>A</em></strong> 的主列是 <span class="math inline">\(C(\boldsymbol{A})\)</span> 的一组基，<strong><em>b</em></strong> 可被 <strong><em>A</em></strong> 的主列线性表示，所以 <strong><em>A</em></strong> 的主列等于 <span class="math inline">\(\boldsymbol{A}|\boldsymbol{b}\)</span> 的主列，所以 <span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}])\)</span>。<br />
<span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}])\)</span>，即 <span class="math inline">\(\boldsymbol{A}\)</span> 和 <span class="math inline">\([\boldsymbol{A},\boldsymbol{b}]\)</span> 的列向量组的极大线性无关组向量个数相同，则 <strong><em>b</em></strong> 必可以被 <strong><em>A</em></strong> 的极大线性无关组线性表示，即 <span class="math inline">\(\boldsymbol{b} \in C(\boldsymbol{A})\)</span>。</p>
</blockquote></li>
<li><p>当 <span class="math inline">\(\text{dim}(C(\boldsymbol{A})) = m\)</span> 时，<span class="math inline">\(C(\boldsymbol{A}) = \mathbb{R}^m\)</span>，<strong><em>b</em></strong> 为 <em>m</em> 维列向量，<span class="math inline">\(\boldsymbol{b} \in \mathbb{R}^m\)</span>，即 <span class="math inline">\(\boldsymbol{b} \in C(\boldsymbol{A})\)</span>。故当 <span class="math inline">\(\text{dim}(C(\boldsymbol{A})) = r(\boldsymbol{A}) = m\)</span> 即 <strong><em>A</em></strong> 行满秩时，非齐次线性方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 必有解。</p></li>
<li><p>当 <span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}]) = n\)</span> 时，因为矩阵 <strong><em>A</em></strong> 列满秩，故 <strong><em>A</em></strong> 的列向量组线性无关，根据<a href="#线性相关和线性无关">定理 2</a>，<strong><em>b</em></strong> 能被 <strong><em>A</em></strong> 的列向量组线性表示，且表示法唯一，故非齐次线性方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 有唯一解。</p></li>
<li><p>当 <span class="math inline">\(r(\boldsymbol{A}) = m = n\)</span> 时，即方阵 <strong><em>A</em></strong> 满秩，结合上两条可知非齐次线性方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 有唯一解。</p>
<blockquote>
<p>推论：如果 <span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span>，则 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 必有（唯一）解。逆否命题：<strong><em>A</em></strong> 是方阵，如果 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 无解，则 <span class="math inline">\(|\boldsymbol{A}| = 0\)</span>。</p>
</blockquote></li>
<li><p>当 <span class="math inline">\(r(\boldsymbol{A}) = r([\boldsymbol{A},\boldsymbol{b}]) &lt; n\)</span> 时，<strong><em>A</em></strong> 含有 <span class="math inline">\(n -r(\boldsymbol{A})\)</span> 个自由列，则 <strong><em>x</em></strong> 中含有 <span class="math inline">\(n -r(\boldsymbol{A})\)</span> 个自由变量，自由变量的取值是任意的，所以非齐次线性方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 有无穷解。</p></li>
</ul>
<p><span class="math inline">\(N(\boldsymbol{A})\)</span> 在求解 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 中起到了重要作用，假设 <span class="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2\)</span> 是方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 的两个解向量，则</p>
<p><span class="math display">\[
\boldsymbol{A}(\boldsymbol{v}_1 - \boldsymbol{v}_2) = \boldsymbol{A}\boldsymbol{v}_1 - \boldsymbol{A}\boldsymbol{v}_2 = \boldsymbol{b} - \boldsymbol{b} = \boldsymbol{0}
\]</span></p>
<p>即 <span class="math inline">\(\boldsymbol{v}_1-\boldsymbol{v}_2\)</span> 是方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的解向量，假设 <span class="math inline">\(\boldsymbol{v}_n \in N(\boldsymbol{A})\)</span>，则</p>
<p><span class="math display">\[
\boldsymbol{A}(\boldsymbol{v}_1 + \boldsymbol{v}_n) = \boldsymbol{A}\boldsymbol{v}_1 + \boldsymbol{A}\boldsymbol{v}_n = \boldsymbol{b} + \boldsymbol{0} = \boldsymbol{b}
\]</span></p>
<p>即 <span class="math inline">\(\boldsymbol{v}_1 + \boldsymbol{v}_n\)</span> 是方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 的解向量。由此可知，如果确定方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 的一个特解 <span class="math inline">\(\boldsymbol{x}_p\)</span> 并确定方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{0}\)</span> 的解空间 <span class="math inline">\(N(\boldsymbol{A})\)</span>，即可表示出方程组 <span class="math inline">\(\boldsymbol{Ax} = \boldsymbol{b}\)</span> 的通解 <span class="math inline">\(\boldsymbol{x}_p + N(\boldsymbol{A})\)</span>。</p>
<h3 id="同解和公共解">同解和公共解</h3>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>多元函数微分学</title>
    <url>/2022/09/15/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<p>高等数学-多元函数微分学的概念与计算。</p>
<span id="more"></span>
<hr />
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#极限">极限</a></li>
<li><a href="#连续">连续</a></li>
<li><a href="#偏导数">偏导数</a></li>
<li><a href="#可微">可微</a></li>
<li><a href="#偏导数的连续性">偏导数的连续性</a></li>
</ul></li>
<li><a href="#计算">计算</a>
<ul>
<li><a href="#多元复合函数求导">多元复合函数求导</a>
<ul>
<li><a href="#全导数">全导数</a></li>
<li><a href="#链式求导规则">链式求导规则</a></li>
<li><a href="#全微分形式不变性">全微分形式不变性</a></li>
</ul></li>
<li><a href="#多元隐函数求导">多元隐函数求导</a>
<ul>
<li><a href="#一个二元方程的隐函数">一个二元方程的隐函数</a></li>
<li><a href="#一个多元方程的隐函数">一个多元方程的隐函数</a></li>
<li><a href="#多元方程组的隐函数">多元方程组的隐函数</a></li>
</ul></li>
<li><a href="#多元函数的极值和最值">多元函数的极值和最值</a>
<ul>
<li><a href="#二元函数的泰勒公式">二元函数的泰勒公式</a></li>
<li><a href="#无条件极值">无条件极值</a></li>
<li><a href="#条件极值">条件极值</a></li>
</ul></li>
<li><a href="#偏微分方程">偏微分方程</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="基本概念">基本概念</h3>
<ol type="1">
<li>邻域</li>
</ol>
<p>设 <em>M</em><sub>0</sub> 为平面上一个点，<span class="math inline">\(\delta\)</span> 为正数，<em>M</em> 为平面上的点，则 <span class="math inline">\(\{M \vert \rho(M_0,M) &lt; \delta\}\)</span> 为点 <em>M</em><sub>0</sub> 的『<strong><span class="math inline">\(\delta\)</span> 邻域</strong>』，记作 <span class="math inline">\(U(M_0,\delta)\)</span>，<span class="math inline">\(\{M \vert 0 &lt; \rho(M_0,M) &lt; \delta\}\)</span> 为点 <em>M</em><sub>0</sub> 的『<strong>去心 <span class="math inline">\(\delta\)</span> 邻域</strong>』，记作 <span class="math inline">\(\mathring{U}(M_0,\delta)\)</span>。</p>
<ol start="2" type="1">
<li>边界</li>
</ol>
<p>给定平面上的一个点集 <em>E</em>，若 <span class="math inline">\(\exists \delta &gt; 0\)</span>，使得 <span class="math inline">\(U(M,\delta) \subset E\)</span>，则 <em>M</em> 为点集 <em>E</em> 的『<strong>内点</strong>』。若 <span class="math inline">\(\exists \delta &gt; 0\)</span>，使得 <span class="math inline">\(U(M,\delta) \cap E = \varnothing\)</span>，则 <em>M</em> 为点集 <em>E</em> 的『<strong>外点</strong>』。若对于 <span class="math inline">\(\forall \delta &gt; 0\)</span>，<span class="math inline">\(U(M,\delta)\)</span> 中既有 <em>E</em> 中的点也有 <em>E</em> 外的点，则 <em>M</em> 为点集 <em>E</em> 的『<strong>边界点</strong>』。</p>
<p>点集 <em>E</em> 的所有边界点的集合称为 <em>E</em> 的『<strong>边界</strong>』，记作 <span class="math inline">\(\partial E\)</span>。</p>
<ol start="3" type="1">
<li>区域</li>
</ol>
<p>设 <em>E</em> 是一个平面点集，对于其中的任意两点，都可用一条完全属于 <em>E</em> 的曲线将这两点连起来，则这样的 <em>E</em> 为『连通集』。连通的开集称为『<strong>开区域</strong>』，一个开区域和它的边界的并集称为『<strong>闭区域</strong>』。</p>
<p>设 <em>E</em> 是一个区域，若其中任意一条不交叉的简单闭曲线的内部还在 <em>E</em> 内，则 <em>E</em> 称为『<strong>单连通区域</strong>』，否则称为『<strong>多连通区域</strong>』。</p>
<ol start="4" type="1">
<li>聚点</li>
</ol>
<p>设 <em>E</em> 是一个平面点集，<em>M</em><sub>0</sub> 是平面上一个点，若对于 <span class="math inline">\(\forall \delta &gt; 0\)</span>，总有 <span class="math inline">\(\mathring{U}(M_0,\delta) \cap E \neq \varnothing\)</span>，则称 <em>M</em><sub>0</sub> 为 <em>E</em> 的『<strong>聚点</strong>』。开区域的内点和边界点都是聚点，闭区域内的任何一点都是聚点。</p>
<h3 id="极限">极限</h3>
<p>设二元函数 <span class="math inline">\(f(P) = f(x,y)\)</span> 的定义域为 <em>D</em>，<span class="math inline">\(P(x_0,y_0)\)</span> 是 <em>D</em> 的聚点如果存在常数 <em>A</em>，对于 <span class="math inline">\(\forall \varepsilon &gt; 0\)</span>，都 <span class="math inline">\(\exists \delta &gt; 0\)</span>，使得但点 <span class="math inline">\(P(x,y) \in D \cap \mathring{U}(P_0,\delta)\)</span> 时，都有</p>
<p><span class="math display">\[
\left|f(x,y) - A\right| &lt; \varepsilon
\]</span></p>
<p>则称 <em>A</em> 为 <span class="math inline">\(f(x,y)\)</span> 当 <span class="math inline">\((x,y) \to (x_0,y_0)\)</span> 时的『<strong>极限</strong>』，记作</p>
<p><span class="math display">\[
\lim_{(x,y) \to (x_0,y_0)}f(x,y) = A \; \text{or} \; f(x,y) \to A \;((x,y) \to (x_0,y_0))
\]</span></p>
<h3 id="连续">连续</h3>
<p>若 <span class="math inline">\(\lim_{(x,y) \to (x_0,y_0)} f(x,y) = f(x_0,y_0) \Leftrightarrow f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 处『<strong>连续</strong>』。</p>
<blockquote>
<p>多元函数的间断点类型不在考试范围内。</p>
</blockquote>
<h3 id="偏导数">偏导数</h3>
<p>设函数 <span class="math inline">\(z =f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 的某邻域内有定义，若极限</p>
<p><span class="math display">\[
\lim _{\Delta x \to 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}
\]</span></p>
<p>存在，则称此极限为 <span class="math inline">\(f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 处对 <em>x</em> 的『<strong>偏导数</strong>』，记作</p>
<p><span class="math display">\[
f&#39;_x(x_0,y_0) \; \text{or} \;  z&#39;_x\bigg |_{x = x_0,y=y_0} \; \text{or} \; 
\frac{\partial f}{\partial x} \bigg |_{x = x_0,y=y_0} \; \text{or} \; \frac{\partial z}{\partial x} \bigg |_{x = x_0,y=y_0} 
\]</span></p>
<p>故 <span class="math inline">\(f(x,y)\)</span> 的偏导数：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f&#39;_x(x_0,y_0) = \lim_{\Delta x \to 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x} = \lim_{x \to x_0}\frac{f(x,y) - f(x_0,y_0)}{x - x_0} \\
&amp; f&#39;_y(x_0,y_0) = \lim_{\Delta y \to 0}\frac{f(x_0,y_0 + \Delta y)-f(x_0,y_0)}{\Delta y} = \lim_{y \to y_0}\frac{f(x,y) - f(x_0,y_0)}{y - y_0}
\end{aligned}
\]</span></p>
<p>若函数 <span class="math inline">\(z = f(x,y)\)</span> 在区域 <em>D</em> 内的偏导数 <span class="math inline">\(f&#39;_x(x,y),f&#39;_y(x,y)\)</span> 仍具有偏导数，则它们的偏导数称为 <span class="math inline">\(f(x,y)\)</span> 的『<strong>二阶偏导数</strong>』，根据对变量求导的顺序不同分为四个二阶偏导数：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{\partial}{\partial x}\left(\frac{\partial z}{\partial x}\right) = \frac{\partial^2 z}{\partial x^2} = f&#39;&#39;_{xx}(x,y), \quad \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial y}\right) = \frac{\partial^2 z}{\partial y^2} = f&#39;&#39;_{yy}(x,y), \\
&amp; \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial x}\right) = \frac{\partial^2 z}{\partial x\partial y} = f&#39;&#39;_{xy}(x,y), \quad \frac{\partial}{\partial x}\left(\frac{\partial z}{\partial y}\right) = \frac{\partial^2 z}{\partial y\partial x} = f&#39;&#39;_{yx}(x,y)
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(f&#39;&#39;_{xy}(x,y),f&#39;&#39;_{yx}(x,y)\)</span> 称为『<strong>二阶混合偏导数</strong>』。</p>
<blockquote>
<p>注：求偏导数时把求导变量之外的变量视为<strong>常数</strong>。</p>
</blockquote>
<h3 id="可微">可微</h3>
<p>函数 <span class="math inline">\(z = f(x,y)\)</span> 在点 <span class="math inline">\((x,y)\)</span> 处的『<strong>全增量</strong>』 <span class="math inline">\(\Delta z = f(x + \Delta x, y + \Delta y) - f(x,y)\)</span> 可表示为</p>
<p><span class="math display">\[
\Delta z = A\Delta x + B\Delta y + o(\rho)
\]</span></p>
<p>其中 <span class="math inline">\(\rho = \sqrt{(\Delta x)^2 + (\Delta y)^2}\)</span>，<span class="math inline">\(A,B\)</span> 不依赖于 <span class="math inline">\(\Delta x,\Delta y\)</span> 仅与 <span class="math inline">\(x,y\)</span> 有关，则称函数 <span class="math inline">\(z = f(x,y)\)</span> 在点 <span class="math inline">\((x,y)\)</span> 处『<strong>可微</strong>』，称 <span class="math inline">\(A\Delta x + B\Delta y\)</span> 为函数 <span class="math inline">\(z =f(x,y)\)</span> 在点 <span class="math inline">\((x,y)\)</span> 处的『<strong>全微分</strong>』，记作</p>
<p><span class="math display">\[
\text{d} z = A\Delta x + B\Delta y
\]</span></p>
<p>定理：若函数 <span class="math inline">\(z = f(x,y)\)</span> 在点 <span class="math inline">\((x,y)\)</span> 处可微，则函数在该点的偏导数必存在，则函数在该点的全微分为：</p>
<p><span class="math display">\[
\begin{aligned}
\text{d} z&amp; = f&#39;_x(x,y)\Delta x + f&#39;_y(x,y)\Delta y \\
&amp; = \frac{\partial z}{\partial x}\text{d} x + \frac{\partial z}{\partial y}\text{d} y
\end{aligned}
\]</span></p>
<p><strong>判断函数 <span class="math inline">\(z = f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 处可微：</strong></p>
<ul>
<li>写出全增量 <span class="math inline">\(\Delta z = f(x_0 + \Delta x, y_0 + \Delta y)-f(x,y)\)</span>。</li>
<li>写出线性增量 <span class="math inline">\(f&#39;_x(x_0,y_0)\Delta x + f&#39;_y(x_0,y_0)\Delta y\)</span>。</li>
<li>计算极限</li>
</ul>
<p><span class="math display">\[
\lim_{\Delta x \to 0,\Delta y \to 0} \frac{\Delta z - (f&#39;_x(x_0,y_0)\Delta x + f&#39;_y(x_0,y_0)\Delta y)}{\sqrt{(\Delta x)^2 + (\Delta y)^2}}
\]</span></p>
<p>若该极限等于 0，则 <span class="math inline">\(f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 处可微，否则不可微。</p>
<h3 id="偏导数的连续性">偏导数的连续性</h3>
<p><strong>判断函数 <span class="math inline">\(z = f(x,y)\)</span> 在某特殊点 <span class="math inline">\((x_0,y_0)\)</span> 处（如分段点）偏导数是否连续：</strong></p>
<ul>
<li>定义法求 <span class="math inline">\(f&#39;_x(x_0,y_0),f&#39;_y(x_0,y_0)\)</span>。</li>
<li>用公式法求 <span class="math inline">\(f&#39;_x(x,y),f&#39;_y(x,y)\)</span>。</li>
<li>计算极限</li>
</ul>
<p><span class="math display">\[
\lim_{x \to x_0,y \to y_0}f&#39;_x(x_0,y_0),\lim_{x \to x_0,y \to y_0}f&#39;_y(x_0,y_0)
\]</span></p>
<ul>
<li>若求出的两个极限与定义法求出的偏导数相等，则 <span class="math inline">\(f(x,y)\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 处的偏导数连续。</li>
</ul>
<p><strong>重要结论：两个偏导数连续，则二阶混合偏导数相等。</strong></p>
<h2 id="计算">计算</h2>
<h3 id="多元复合函数求导">多元复合函数求导</h3>
<h4 id="全导数">全导数</h4>
<p>若 <span class="math inline">\(z =f(u,v),\; u = u(x),\; v = v(x)\)</span>，即 <em>z</em> 最终是关于单一变量 <em>x</em> 的函数，则 <span class="math inline">\(\frac{\text{d} z}{\text{d} x}\)</span> 称为该函数的『<strong>全导数</strong>』，记作</p>
<p><span class="math display">\[
\frac{\text{d} z}{\text{d} x} = \frac{\partial z}{\partial u}\frac{\text{d} u}{\text{d} x} + \frac{\partial z}{\partial v}\frac{\text{d} v}{\text{d} x}
\]</span></p>
<h4 id="链式求导规则">链式求导规则</h4>
<ol type="1">
<li><p>画出函数的<strong>复合结构图</strong>。</p></li>
<li><p>对哪个变量求导，就寻找通向这个变量的<strong>所有路线</strong>。</p></li>
<li><p>将所有路线求得的导数相加。</p></li>
</ol>
<p><span class="math display">\[
\text{e.g.} \;
z = f(u,v,w),\; u =u(x,y),\; v = v(x),\; w = w(y) \\
\]</span></p>
<p><img src="16644273534436.jpg" /></p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{\partial z}{\partial x} = \frac{\partial z}{\partial u}\frac{\partial u}{\partial x} + \frac{\partial z}{\partial v}\frac{\text{d} v}{\text{d} x}\\
&amp; \frac{\partial z}{\partial y} = \frac{\partial z}{\partial u}\frac{\partial u}{\partial y}+\frac{\partial z}{\partial w}\frac{\text{d} w}{\text{d} y}
\end{aligned}
\]</span></p>
<p><strong>注：无论 <em>z</em> 对哪个变量求导，也无论 <em>z</em> 已经求了几阶导，求导后的新函数仍然具有与原本函数完全相同的复合结构。</strong></p>
<h4 id="全微分形式不变性">全微分形式不变性</h4>
<p>函数 <span class="math inline">\(z =f(u,v)\)</span> 可微，则其全微分为</p>
<p><span class="math display">\[
\text{d}z = \frac{\partial z}{\partial u}\text{d}u + \frac{\partial z}{\partial v}\text{d}v
\]</span></p>
<p>若 <span class="math inline">\(u,v\)</span> 作为函数的中间变量，是自变量 <span class="math inline">\(x,y\)</span> 的可微函数 <span class="math inline">\(u =u(x,y),\;v=v(x,y)\)</span>，则复合函数 <span class="math inline">\(z = f(u(x,y),v(x,y))\)</span> 也是可微的，其全微分为</p>
<p><span class="math display">\[
\text{d} z = \frac{\partial z}{\partial x}\text{d}x + \frac{\partial z}{\partial y}\text{d}y
\]</span></p>
<h3 id="多元隐函数求导">多元隐函数求导</h3>
<h4 id="一个二元方程的隐函数">一个二元方程的隐函数</h4>
<p>设函数 <span class="math inline">\(F(x,y)\)</span> 在点 <span class="math inline">\(P(x_0,y_0)\)</span> 的某一邻域内具有连续偏导数，若 <span class="math inline">\(F(x_0,y_0) = 0,\;F&#39;_y(x_0,y_0) \neq 0\)</span>，则方程 <span class="math inline">\(F(x,y) = 0\)</span> 在点 <span class="math inline">\((x_0,y_0)\)</span> 的某一邻域内能唯一确定一个连续且具有连续导数的函数 <span class="math inline">\(y = f(x)\)</span>，且有</p>
<p><span class="math display">\[
\frac{\text{d}y}{\text{d}x} = - \frac{F&#39;_x}{F&#39;_y}
\]</span></p>
<ul>
<li><span class="math inline">\(x,y\)</span> 是当作<strong>独立的中间变量</strong>，不必在意 <span class="math inline">\(x,y\)</span> 之间的关系。之后的两个情景同理。</li>
<li>推导：<span class="math inline">\(F(x,y(x))=0\)</span> 的复合结构如图：</li>
</ul>
<p><img src="16644267691822.jpg" /></p>
<p>方程两侧对 <em>x</em> 求导：</p>
<p><span class="math display">\[
F&#39;_x \frac{\text{d}x}{\text{d}x} + F&#39;_y \frac{\text{d}y}{\text{d}x} = 0
\]</span></p>
<p>故当 <span class="math inline">\(F&#39;_y \neq 0\)</span> 时，<span class="math inline">\(\frac{\text{d}y}{\text{d}x} = - \frac{F&#39;_x}{F&#39;_y}\)</span>。</p>
<h4 id="一个多元方程的隐函数">一个多元方程的隐函数</h4>
<p>设函数 <span class="math inline">\(F(x,y,z)\)</span> 在点 <span class="math inline">\(P(x_0,y_0,z_0)\)</span> 的某一邻域内具有连续偏导数，若 <span class="math inline">\(F(P_0) = 0,\;F&#39;_z(P_0) \neq 0\)</span>，则方程 <span class="math inline">\(F(x,y,z) = 0\)</span> 在点 <span class="math inline">\(P_0\)</span> 的某一邻域内能唯一确定一个连续且具有连续导数的函数 <span class="math inline">\(z = z(x,y)\)</span>，且有</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial z}{\partial x} = -\frac{F&#39;_x}{F&#39;_z},\;\frac{\partial z}{\partial y} = -\frac{F&#39;_y}{F&#39;_z}
\end{aligned}
\]</span></p>
<h4 id="多元方程组的隐函数">多元方程组的隐函数</h4>
<p>设 <span class="math inline">\(\left\{ \begin{aligned}&amp;F(x,y,u,v) =0 \\ &amp;G(x,y,u,v) = 0 \end{aligned}\right.\)</span>，若记</p>
<p><span class="math display">\[
\left|\begin{matrix} F&#39;_u &amp;F&#39;_v \\ G&#39;_u &amp;G&#39;_v \end{matrix}\right | = \frac{\partial(F,G)}{\partial(u,v)}
\]</span></p>
<blockquote>
<p>此处为二阶雅可比行列式。</p>
</blockquote>
<p>则当满足 <span class="math inline">\(\frac{\partial(F,G)}{\partial(u,v)} \neq 0\)</span> 时，可确定 <span class="math inline">\(\left\{ \begin{aligned}&amp;u=u(x,y)\\ &amp;v = v(x,y)\end{aligned}\right.\)</span>。</p>
<p><img src="16644198249219.jpg" /></p>
<p>且有</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\frac{\partial u}{\partial x} = -\frac{\frac{\partial(F,G)}{\partial (x,v)}}{\frac{\partial (F,G)}{\partial (u,v)}}, \quad \frac{\partial v}{\partial x} = -\frac{\frac{\partial(F,G)}{\partial (u,x)}}{\frac{\partial (F,G)}{\partial (u,v)}}, \\
&amp;\frac{\partial u}{\partial y} = -\frac{\frac{\partial(F,G)}{\partial (y,v)}}{\frac{\partial (F,G)}{\partial (u,v)}}, \quad \frac{\partial v}{\partial y} = -\frac{\frac{\partial(F,G)}{\partial (u,y)}}{\frac{\partial (F,G)}{\partial (u,v)}}
\end{aligned}
\]</span></p>
<p><strong>简单形式</strong>：设 <span class="math inline">\(\left\{ \begin{aligned}&amp;F(x,y,z) =0 \\ &amp;G(x,y,z) = 0 \end{aligned}\right.\)</span>，当满足 <span class="math inline">\(\frac{\partial(F,G)}{\partial(y,z)} \neq 0\)</span> 时，可确定 <span class="math inline">\(\left\{ \begin{aligned}&amp; y =y(x) \\ &amp;z =z(x) \end{aligned}\right.\)</span>，其复合结构图为</p>
<p><img src="16644206705903.jpg" /></p>
<p>且有</p>
<p><span class="math display">\[
\frac{\text{d}y}{\text{d}x} = \frac{\frac{\partial(F,G)}{\partial(x,z)}}{\frac{\partial(F,G)}{\partial(y,z)}}, \quad \frac{\text{d}z}{\text{d}x} = \frac{\frac{\partial(F,G)}{\partial(y,x)}}{\frac{\partial(F,G)}{\partial(y,z)}}
\]</span></p>
<h3 id="多元函数的极值和最值">多元函数的极值和最值</h3>
<h4 id="二元函数的泰勒公式">二元函数的泰勒公式</h4>
<p>设 <span class="math inline">\(f(x,y)\)</span> 二阶偏导数连续，记 <span class="math inline">\(P_0 = (x_0,y_0)\)</span>，<span class="math inline">\(\Delta x = x -x_0\)</span>，<span class="math inline">\(\Delta y = y -y_0\)</span>，则</p>
<p><span class="math display">\[
f(x, y)=f\left(x_{0}, y_{0}\right)+\left[\begin{array}{ll}
f_{x}^{\prime} &amp; f_{y}^{\prime}
\end{array}\right]_{P_0}\left[\begin{array}{c}
\Delta x \\
\Delta y
\end{array}\right]+
\frac{1}{2 !}
\left[\begin{array}{ll}
\Delta x &amp; \Delta y
\end{array}\right]\left[\begin{array}{cc}
f_{x x}^{\prime \prime} &amp; f_{x y}^{\prime \prime} \\
f_{y x}^{\prime \prime} &amp; f_{y y}^{\prime \prime}
\end{array}\right]_{P_0}\left[\begin{array}{l}
\Delta x \\
\Delta y
\end{array}\right]+R_{2}
\]</span></p>
<h4 id="无条件极值">无条件极值</h4>
<p><strong><span class="math inline">\(f(x,y)\)</span> 取极值的必要条件：</strong></p>
<p>极值点必为驻点，设 <span class="math inline">\(P_0 = (x_0,y_0)\)</span> 为驻点，则</p>
<p><span class="math display">\[
\left\{\begin{aligned}&amp;f&#39;_x(x_0,y_0) = 0 \\ &amp;f&#39;_y(x_0,y_0) = 0 \end{aligned}\right. \Rightarrow \left[\begin{matrix}f&#39;_x &amp;f&#39;_y\end{matrix}\right]_{P_0}= \boldsymbol{0}
\]</span></p>
<p><strong><span class="math inline">\(f(x,y)\)</span> 取极值的充分条件：</strong></p>
<p><span class="math display">\[
\left[\begin{matrix}f&#39;_x &amp;f&#39;_y\end{matrix}\right]_{P_0}= \boldsymbol{0} \xrightarrow{Taylor} f(x,y) - f(x_0,y_0) = \frac{1}{2 !}
\left[\begin{array}{ll}
\Delta x &amp; \Delta y
\end{array}\right]\left[\begin{array}{cc}
f_{x x}^{\prime \prime} &amp; f_{x y}^{\prime \prime} \\
f_{y x}^{\prime \prime} &amp; f_{y y}^{\prime \prime}
\end{array}\right]_{P_0}\left[\begin{array}{l}
\Delta x \\
\Delta y
\end{array}\right]+R_{2}
\]</span></p>
<p>记 <span class="math inline">\(\left\{ \begin{aligned} &amp;f&#39;&#39;_{xx}(x_0,y_0) = A \\ &amp; f&#39;&#39;_{xy}(x_0,y_0) = f&#39;&#39;_{yx}(x_0,y_0) = B \\ &amp;f&#39;&#39;_{yy}(x_0,y_0) = C \end{aligned}\right.\)</span>，则</p>
<ul>
<li>当 <span class="math inline">\(\Delta = AC - B^2 &gt; 0\)</span> 且 <span class="math inline">\(A &gt; 0\)</span> 时，<span class="math inline">\(f(x_0,y_0)\)</span> 为极小值。</li>
<li>当 <span class="math inline">\(\Delta = AC - B^2 &gt; 0\)</span> 且 <span class="math inline">\(A &lt; 0\)</span> 时，<span class="math inline">\(f(x_0,y_0)\)</span> 为极大值。</li>
<li>当 <span class="math inline">\(\Delta = AC - B^2 &gt; 0\)</span> 时，<span class="math inline">\(f(x_0,y_0)\)</span> 非极值。</li>
<li>当 <span class="math inline">\(\Delta = AC - B^2= 0\)</span> 时，无法判别是否为极值。</li>
</ul>
<blockquote>
<p>注：该充分条件<strong>不适用于三元及以上的函数</strong>。</p>
</blockquote>
<h4 id="条件极值">条件极值</h4>
<p><strong>二元情况：</strong></p>
<p>函数 <span class="math inline">\(u =f(x,y)\)</span> 在条件 <span class="math inline">\(\varphi(x,y) = 0\)</span> 下取得最值，则</p>
<ul>
<li>构造辅助函数 <span class="math inline">\(F(x,y,\lambda) = f(x,y) + \lambda\varphi(x,y)\)</span></li>
<li>令</li>
</ul>
<p><span class="math display">\[
\left\{ \begin{aligned}
&amp; F&#39;_x = f&#39;_x + \lambda \varphi&#39;_x = 0 \\
&amp; F&#39;_y = f&#39;_y + \lambda \varphi&#39;_y = 0 \\
&amp; F&#39;_{\lambda} = \varphi(x,y,z) = 0
\end{aligned}
\right.
\]</span></p>
<ul>
<li>解上述方程组得到备选点 <span class="math inline">\(P_i\;(i = 1,2,\ldots)\)</span>，在备选点中计算最大值和最小值。</li>
</ul>
<p><strong>三元情况：</strong></p>
<p>函数 <span class="math inline">\(u =f(x,y,z)\)</span> 在条件 <span class="math inline">\(\left\{ \begin{aligned}&amp;\varphi(x,y,z) = 0 \\ &amp;\psi(x,y,z) = 0 \end{aligned}\right.\)</span> 下取得最值，则</p>
<ul>
<li>构造辅助函数 <span class="math inline">\(F(x,y,z,\lambda,\mu) = f(x,y,z) + \lambda\varphi(x,y,z) + \mu\psi(x,y,z)\)</span></li>
<li>令</li>
</ul>
<p><span class="math display">\[
\left\{ \begin{aligned}
&amp; F&#39;_x = f&#39;_x + \lambda \varphi&#39;_x + \mu\psi&#39;_x= 0 \\
&amp; F&#39;_y = f&#39;_y + \lambda \varphi&#39;_y + \mu\psi&#39;_y = 0 \\
&amp; F&#39;_z = f&#39;_z + \lambda \varphi&#39;_z + \mu\psi&#39;_z = 0 \\
&amp; F&#39;_{\lambda} = \varphi(x,y,z) = 0 \\
&amp; F&#39;_{\mu} = \psi(x,y,z) = 0 
\end{aligned}
\right.
\]</span></p>
<ul>
<li>解上述方程组得到备选点 <span class="math inline">\(P_i\;(i = 1,2,\ldots)\)</span>，在备选点中计算 <span class="math inline">\(f(P_i)\)</span> 最大值和最小值。</li>
</ul>
<h3 id="偏微分方程">偏微分方程</h3>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Calulus</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程</title>
    <url>/2022/09/10/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>高等数学-常微分方程的概念与计算。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#计算">计算</a>
<ul>
<li><a href="#变量可分离型微分方程">变量可分离型微分方程</a></li>
<li><a href="#一阶线性微分方程">一阶线性微分方程</a></li>
<li><a href="#二阶可降阶微分方程">二阶可降阶微分方程</a></li>
<li><a href="#高阶线性微分方程">高阶线性微分方程</a>
<ul>
<li><a href="#二阶线性微分方程解的结构">二阶线性微分方程解的结构</a></li>
<li><a href="#二阶常系数齐次线性微分方程的通解">二阶常系数齐次线性微分方程的通解</a></li>
<li><a href="#二阶常系数非齐次线性微分方程的特解">二阶常系数非齐次线性微分方程的特解</a></li>
<li><a href="#欧拉方程">欧拉方程</a></li>
<li><a href="#n-阶常系数齐次线性微分方程的解"><em>n</em> 阶常系数齐次线性微分方程的解</a></li>
</ul></li>
</ul></li>
<li><a href="#微分方程的应用">微分方程的应用</a></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<ol type="1">
<li>微分方程是什么？</li>
</ol>
<p>描述未知函数及其导数（或微分）与自变量之间的关系的方程，称为『<strong>微分方程</strong>』，一般记作：</p>
<p><span class="math display">\[
F\left[x,y,y&#39;,\ldots,y^{(n)}\right] = 0
\]</span></p>
<p>未知函数是一元函数的微分方程称为『<strong>常微分方程</strong>』，未知函数是多元函数的微分方程称为『<strong>偏微分方程</strong>』。</p>
<ol start="2" type="1">
<li>微分方程的阶数？微分方程的解？通解和特解？</li>
</ol>
<p>微分方程中未知函数的最高阶导数的阶数称为微分方程的<strong>阶数</strong>。</p>
<p>将一个函数代入微分方程，使得方程恒成立，则称该函数是微分方程的一个<strong>解</strong>。</p>
<p>若微分方程的解中含有<strong>独立常数的个数等于微分方程的阶数</strong>，则该解称为微分方程的『<strong>通解</strong>』。</p>
<p>用初始条件将微分方程通解中的<strong>常数全部确定</strong>的解称为微分方程的『<strong>特解</strong>』。</p>
<ol start="3" type="1">
<li>线性微分方程？齐次和非齐次？</li>
</ol>
<ul>
<li>形如 <span class="math inline">\(y&#39; + p(x)y = q(x)\)</span> 的方程称为『<strong>一阶线性微分方程</strong>』。</li>
<li>形如 <span class="math inline">\(y&#39;&#39; + p(x)y&#39; + q(x)y = f(x)\)</span> 的方程（或阶数更高）称为『<strong>高阶线性微分方程</strong>』。
<ul>
<li>若 <span class="math inline">\(p(x), q(x)\)</span> 为常数函数，则方程称为『<strong>高阶常系数线性微分方程</strong>』。</li>
<li>若 <span class="math inline">\(f(x) \equiv 0\)</span>，则方程称为『<strong>高阶齐次线性微分方程</strong>』。</li>
<li>若 <span class="math inline">\(f(x) \not\equiv 0\)</span>，则方程称为『<strong>高阶非齐次线性微分方程</strong>』。</li>
</ul></li>
</ul>
<h2 id="计算">计算</h2>
<h3 id="变量可分离型微分方程">变量可分离型微分方程</h3>
<ol type="1">
<li>形如 <span class="math inline">\(y&#39; = f(x) g(y)\)</span>，分离变量转化为 <span class="math inline">\(\frac {\text{d}y}{g(y)} = f(x)\text{d}x \Rightarrow \int \frac {\text{d}y}{g(y)} = \int f(x)\text{d}x\)</span>。</li>
<li>形如 <span class="math inline">\(y&#39; = f(ax+by+c)\)</span></li>
</ol>
<ul>
<li>设 <span class="math inline">\(u = ax+by+c \Rightarrow u’ = a + by&#39; = a + bf(u)\)</span>。</li>
<li>分离变量转化为 <span class="math inline">\(\frac{\text{d}u}{a+bf(u)} = \text{d}x \Rightarrow \int \frac{\text{d}u}{a+bf(u)} = \int \text{d}x\)</span>。</li>
</ul>
<ol start="3" type="1">
<li>形如 <span class="math inline">\(y’ = f \left(\frac{y}{x}\right)\)</span></li>
</ol>
<ul>
<li>令 <span class="math inline">\(\frac{y}{x} = u \Rightarrow y = ux \Rightarrow \frac{\text{d}y}{\text{d}x} = u + x \frac{\text{d}u}{\text{d}x}\)</span>，故原方程转化为 <span class="math inline">\(u + x \frac{\text{d}u}{\text{d}x} = f(u)\)</span>。</li>
<li>分离变量转化为 <span class="math inline">\(\frac{\text{d}u}{f(u)-u} = \frac{\text{d}x}{x} \Rightarrow \int \frac{\text{d}u}{f(u)-u} = \int \frac{\text{d}x}{x}\)</span>。</li>
</ul>
<ol start="4" type="1">
<li>形如 <span class="math inline">\(\frac{1}{y&#39;} = f \left(\frac{x}{y}\right)\)</span></li>
</ol>
<ul>
<li>令 <span class="math inline">\(\frac{x}{y} = u \Rightarrow x = uy \Rightarrow \frac{\text{d}x}{\text{d}y} = u + y \frac{\text{d}u}{\text{d}y}\)</span>，故原方程转化为 <span class="math inline">\(u + y \frac{\text{d}u}{\text{d}y} = f(u)\)</span>。</li>
<li>分离变量转化为 <span class="math inline">\(\frac{\text{d}u}{f(u)-u} = \frac{\text{d}y}{y} \Rightarrow \int \frac{\text{d}u}{f(u)-u} = \int \frac{\text{d}y}{y}\)</span>。</li>
</ul>
<h3 id="一阶线性微分方程">一阶线性微分方程</h3>
<ol type="1">
<li>形如 <span class="math inline">\(y&#39; + p(x)y = q(x)\)</span>，方程两边同时乘 <span class="math inline">\(e^{\int p(x) \text{d}x}\)</span>，得</li>
</ol>
<p><span class="math display">\[
\text{e}^{\int p(x) \text{d}x}y&#39; + \text{e}^{\int p(x) \text{d}x}p(x)y = \text{e}^{\int p(x) \text{d}x}q(x) \Rightarrow
\left[\text{e}^{\int p(x) \text{d}x}y\right]&#39; = \text{e}^{\int p(x) \text{d}x}q(x)
\]</span></p>
<p>两边积分得</p>
<p><span class="math display">\[
\text{e}^{\int p(x) \text{d}x}y = \int \text{e}^{\int p(x) \text{d}x}q(x) \text{d}x + C
\]</span></p>
<p>所以</p>
<p><span class="math display">\[
y = \text{e}^{-\int p(x) \text{d}x}\left[\text{e}^{\int p(x) \text{d}x}q(x)\text{d}x + C\right]
\]</span></p>
<blockquote>
<p>注：若求得 <span class="math inline">\(\int p(x)\text{d}x = \ln |x| + C\)</span>，仅在求解一阶线性微分方程时，可省略掉绝对值符号。即 <span class="math inline">\(\int p(x)\text{d}x = \ln |x| + C\)</span>。</p>
</blockquote>
<ol start="2" type="1">
<li>形如 <span class="math inline">\(y&#39; + p(x) y = q(x)y^n\)</span>，即『<strong>伯努利方程</strong>』：</li>
</ol>
<ul>
<li>先变形为 <span class="math inline">\(y^{-n}y&#39; + p(x)y^{1-n} = q(x)\)</span>。<br />
</li>
<li>设 <span class="math inline">\(z = y^{1-n}\)</span>，得 <span class="math inline">\(\frac{\text{d}z}{\text{d}x} = (1-n)y^{-n}\frac{\text{d}y}{\text{d}x}\)</span>，则 <span class="math inline">\(\frac{1}{1-n}\frac{\text{d}z}{\text{d}x} + p(x)z = q(x)\)</span>。<br />
</li>
<li>化为一阶线性微分方程进行求解。</li>
</ul>
<h3 id="二阶可降阶微分方程">二阶可降阶微分方程</h3>
<ol type="1">
<li>形如 <span class="math inline">\(y&#39;&#39; = f(x,y&#39;)\)</span></li>
</ol>
<ul>
<li>令 <span class="math inline">\(y&#39; = p,\; y&#39;&#39; = p&#39; = \frac{\text{d}p}{\text{d}x}\)</span>，原方程化为一阶方程 <span class="math inline">\(\frac{\text{d}p}{\text{d}x} = f(x,p)\)</span>。<br />
</li>
<li>求出上述方程通解 <span class="math inline">\(p = \varphi(x,C_1)\)</span>，即 <span class="math inline">\(y&#39; = \varphi(x,C_1) \Rightarrow y = \int \varphi(x,C_1) \text{d}x + C_2\)</span>。</li>
</ul>
<ol start="2" type="1">
<li>形如 <span class="math inline">\(y&#39;&#39; = f(y,y&#39;)\)</span></li>
</ol>
<ul>
<li>令 <span class="math inline">\(y&#39; = p, \; y&#39;&#39; = \frac{\text{d}p}{\text{d}x} = p\frac{\text{d}p}{\text{d}y}\)</span>，原方程化为一阶方程 <span class="math inline">\(p\frac{\text{d}p}{\text{d}y} = f(y,p)\)</span>。</li>
<li>求出上述方程通解为 <span class="math inline">\(p = \varphi(y,C_1)\)</span>，即 <span class="math inline">\(\frac{\text{d}y}{\text{d}x} = \varphi(y,C_1)\)</span>，分离变量得 <span class="math inline">\(\frac{\text{d}y}{\varphi(y,C_1)}= \text{d}x \Rightarrow \int \frac{\text{d}y}{\varphi(y,C_1)}= x + C_2\)</span>。</li>
</ul>
<h3 id="高阶线性微分方程">高阶线性微分方程</h3>
<h4 id="二阶线性微分方程解的结构">二阶线性微分方程解的结构</h4>
<ul>
<li><strong>齐次方程的通解：</strong></li>
</ul>
<p>若 <span class="math inline">\(y_1(x),y_2(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = 0\)</span> 的两个解，且 <span class="math inline">\(\frac{y_1(x)}{y_2(x)} \neq C\)</span>，则称 <span class="math inline">\(y_1(x),y_2(x)\)</span> 是该方程的两个<strong>线性无关解</strong>，且 <span class="math inline">\(y(x) = C_1y_1(x) + C_2y_2(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = 0\)</span> 的通解。</p>
<ul>
<li><strong>非齐次方程的通解：</strong></li>
</ul>
<p>若 <span class="math inline">\(y(x) = C_1y_1(x) + C_2y_2(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = 0\)</span> 的通解，<span class="math inline">\(y^*(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = f(x)\)</span> 的一个特解，则 <span class="math inline">\(y(x) + y^*(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = f(x)\)</span> 的通解。</p>
<ul>
<li><strong>非齐次方程的特解：</strong></li>
</ul>
<p>若 <span class="math inline">\(y_1^*(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = f_1(x)\)</span> 的一个特解，<span class="math inline">\(y_2^*(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = f_2(x)\)</span> 的一个特解，则 <span class="math inline">\(y_1^*(x) + y_2 ^*(x)\)</span> 是方程 <span class="math inline">\(y&#39;&#39; + p(x)y + q(x) = f_1(x) + f_2(x)\)</span> 的一个特解。</p>
<h4 id="二阶常系数齐次线性微分方程的通解">二阶常系数齐次线性微分方程的通解</h4>
<p>方程 <span class="math inline">\(y&#39;&#39; + py + q= 0\)</span> 对应的特征方程为 <span class="math inline">\(r^2 + pr + q = 0\)</span>，求其特征根：</p>
<p><span class="math display">\[
\Delta = p^2 - 4q
\]</span></p>
<ul>
<li><span class="math inline">\(\Delta &gt; 0\)</span>，特征方程有两个不等实根 <span class="math inline">\(r_1,r_2\)</span>。此时微分方程的通解为：</li>
</ul>
<p><span class="math display">\[
y = C_1 \text{e}^{r_1x} + C_2 \text{e}^{r_2x}
\]</span></p>
<ul>
<li><span class="math inline">\(\Delta = 0\)</span>，特征方程有两个相等实根 <span class="math inline">\(r_1 = r_2 = r\)</span>。此时微分方程的通解为：</li>
</ul>
<p><span class="math display">\[
y = \text{e}^{rx}(C_1 + C_2 x)
\]</span></p>
<ul>
<li><span class="math inline">\(\Delta &lt; 0\)</span>，特征方程有一对共轭复根 <span class="math inline">\(\alpha \pm \beta i\)</span>。此时微分方程的通解为：</li>
</ul>
<p><span class="math display">\[
y = \text{e}^{\alpha x}(C_1 \cos \beta x+ C_2 \sin \beta x)
\]</span></p>
<h4 id="二阶常系数非齐次线性微分方程的特解">二阶常系数非齐次线性微分方程的特解</h4>
<p>对于微分方程 <span class="math inline">\(y&#39;&#39; + py&#39; + qy = f(x)\)</span>，当 <span class="math inline">\(f(x)\)</span> 的形式为：</p>
<ul>
<li><span class="math inline">\(e^{\alpha x}P_n(x)\)</span>，其特解形式为 <span class="math inline">\(y^* = e^{\alpha x} Q_n(x)x^k\)</span>，其中
<ul>
<li><span class="math inline">\(Q_n(x)\)</span> 为 <em>x</em> 的 <em>n</em> 次多项式。</li>
<li><em>k</em> 表示 <span class="math inline">\(\alpha\)</span> 是齐次方程的特征根的个数（可能是 0、1、2）。</li>
</ul></li>
<li><span class="math inline">\(e^{\alpha x}[P_m(x) \cos \beta x + P_n(x) \sin \beta x]\)</span>，其特解形式为 <span class="math inline">\(y^* = e^{\alpha x}[Q_l^{(1)}(x) \cos \beta x + Q_l^{(2)}(x) \sin \beta x]x^k\)</span>，其中：
<ul>
<li><span class="math inline">\(l = \max(m,n)\)</span>，<span class="math inline">\(Q_l^{(1)}(x),Q_l^{(2)}(x)\)</span> 表示 <em>x</em> 的两个不同的 <em>l</em> 次多项式。</li>
<li><em>k</em> 表示 <span class="math inline">\(\alpha \pm \beta i\)</span> 是不是齐次方程的特征根（可能是 0、1）。</li>
</ul></li>
</ul>
<h4 id="欧拉方程">欧拉方程</h4>
<p>形如 <span class="math inline">\(x^2 y&#39;&#39; + pxy&#39; + qy = 0\)</span> 的方程称为『<strong>欧拉方程</strong>』，它的固定解法：</p>
<ul>
<li>当 <span class="math inline">\(x &gt; 0\)</span> 时，令 <span class="math inline">\(x = \text{e}^t\)</span>，则 <span class="math inline">\(t = \ln x,\; \frac{\text{d}t}{\text{d}x} = \frac{1}{x}\)</span>，则</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\frac{\text{d}y}{\text{d}x} = \frac{\text{d}y}{\text{d}t} \cdot \frac{\text{d}t}{\text{d}x} = \frac{\text{d}y}{\text{d}t} \cdot \frac{1}{x}\\
&amp;\begin{aligned}
\frac{\text{d}^2y}{\text{d}x^2} = \frac{\text{d}\left(\frac{1}{x}\frac{\text{d}y}{\text{d}t}\right)}{\text{d}x} &amp;= \frac{\frac{\text{d}y}{\text{d}t}\text{d}\left(\frac{1}{x}\right)}{\text{d}x}+\frac{\frac{1}{x}\text{d}\left(\frac{\text{d}y}{\text{d}t}\right)}{\text{d}x} \\&amp;= -\frac{1}{x^2}\frac{\text{d}y}{\text{d}t}+\frac{\frac{1}{x}\text{d}\left(\frac{\text{d}y}{\text{d}t}\right)}{\text{d}t} \frac{\text{d}t}{\text{d}x} = -\frac{1}{x^2}\frac{\text{d}y}{\text{d}t} +\frac{1}{x^2}\frac{\text{d}^2y}{\text{d}t^2}
\end{aligned}
\end{aligned}
\]</span></p>
<p>故方程可化为：</p>
<p><span class="math display">\[
\frac{\text{d}^2y}{\text{d}t^2} + (p-1) \frac{\text{d}y}{\text{d}t} +qy = f(\text{e}^t)
\]</span></p>
<p>按照求解<a href="#二阶常系数齐次线性微分方程的通解">二阶常系数线性微分方程</a>的方式进行求解，最后使用 <span class="math inline">\(t = \ln x\)</span> 回代成关于 <em>x</em> 的函数。</p>
<ul>
<li>当 <span class="math inline">\(x &lt; 0\)</span> 时，令 <span class="math inline">\(x = -e^t\)</span>，同理可求解方程。</li>
</ul>
<h4 id="n-阶常系数齐次线性微分方程的解"><em>n</em> 阶常系数齐次线性微分方程的解</h4>
<p>形如 <span class="math inline">\(y^{(n)} + p_1y^{(n-1)} +\cdots+ p_n y = 0 \; (n \geq 3)\)</span> 的微分方程，其对应的特征方程为 <span class="math inline">\(r^n + p_1 r^{n-1} + \cdots + p_n = 0\)</span>，设特征根为 <em>r</em>：</p>
<ul>
<li>若 <em>r</em> 为单实根，对应微分方程通解的一项 <span class="math inline">\(C\text{e}^{rx}\)</span>。</li>
<li>若 <em>r</em> 为 <em>k</em> 重实根，对于微分方程通解的 <em>k</em> 项 <span class="math inline">\(\text{e}^{rx}(C_1 + C_2x +\cdots+ C_kx^{k-1})\)</span>。</li>
<li>若 <em>r</em> 为单复根 <span class="math inline">\(\alpha \pm \beta i\)</span>，对应微分方程通解的两项 <span class="math inline">\(\text{e}^{\alpha x}(C_1 \cos \beta x+ C_2 \sin \beta x)\)</span>。</li>
</ul>
<h2 id="微分方程的应用">微分方程的应用</h2>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Calulus</tag>
      </tags>
  </entry>
  <entry>
    <title>数学知识拾遗</title>
    <url>/2022/09/07/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<p>大学前的数学知识拾遗。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#函数">函数</a>
<ul>
<li><a href="#函数性质">函数性质</a></li>
<li><a href="#函数图像">函数图像</a></li>
</ul></li>
<li><a href="#常用知识">常用知识</a>
<ul>
<li><a href="#数列求和">数列求和</a></li>
<li><a href="#三角函数变换">三角函数变换</a></li>
<li><a href="#对数和指数运算">对数和指数运算</a></li>
<li><a href="#常用因式分解">常用因式分解</a></li>
<li><a href="#一元二次方程的根">一元二次方程的根</a></li>
<li><a href="#常用不等式">常用不等式</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="函数">函数</h2>
<h3 id="函数性质">函数性质</h3>
<ol type="1">
<li>奇偶性</li>
</ol>
<p>函数 <span class="math inline">\(y = f(x)\)</span> 的定义域 <em>D</em> 关于原点对称，且：</p>
<ul>
<li>恒有 <span class="math inline">\(f(x) = f(-x)\)</span>，则函数是<strong>偶函数</strong>。偶函数图像关于 <em>y</em> 轴对称。</li>
<li>恒有 <span class="math inline">\(f(x) = -f(-x)\)</span>，则函数是<strong>奇函数</strong>。奇函数图像关于原点对称，若函数在原点处有定义，则 <span class="math inline">\(f(0)=0\)</span>。</li>
</ul>
<ol start="2" type="1">
<li>单调性</li>
</ol>
<p>函数 <span class="math inline">\(y = f(x)\)</span> 的定义域为 <em>D</em>，区间 <span class="math inline">\(I \subset D\)</span>，若对于 <span class="math inline">\(\forall x_1,x_2 \in I \;(x_1 \neq x_2)\)</span>，满足：</p>
<ul>
<li><span class="math inline">\([f(x_1)-f(x_2)] (x_1 - x_2)&gt; 0 \; \text{or} \; \frac{f(x_1)-f(x_2)}{x_1-x_2} &gt; 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上<strong>单调递增</strong>。</li>
<li><span class="math inline">\([f(x_1)-f(x_2)] (x_1 - x_2)&lt; 0 \; \text{or} \; \frac{f(x_1)-f(x_2)}{x_1-x_2} &lt; 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上<strong>单调递减</strong>。</li>
</ul>
<ol start="3" type="1">
<li>有界性</li>
</ol>
<p>函数 <span class="math inline">\(y = f(x)\)</span> 的定义域为 <em>D</em>，区间 <span class="math inline">\(I \subset D\)</span>，若对于 <span class="math inline">\(\forall x \in I\)</span>，都 <span class="math inline">\(\exists M &gt; 0\)</span>，使得 <span class="math inline">\(|f(x)| \leq M\)</span>，则称 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上<strong>有界</strong>。若 <em>M</em> 不存在，则称 <span class="math inline">\(f(x)\)</span> 在区间 <em>I</em> 上<strong>无界</strong>。</p>
<p>函数在闭区间内单调，则在闭区间内有界。</p>
<ol start="4" type="1">
<li>周期性</li>
</ol>
<p>函数 <span class="math inline">\(y = f(x)\)</span> 的定义域为 <em>D</em>，若 <span class="math inline">\(\exists T &gt; 0\)</span>，使得对于 <span class="math inline">\(\forall x \in D\)</span>，都有 <span class="math inline">\(x + T \in D\)</span>，且 <span class="math inline">\(f(x + T) =f(x)\)</span>，则称 <span class="math inline">\(f(x)\)</span> 为周期函数，称 <em>T</em> 为 <span class="math inline">\(f(x)\)</span> 的周期。</p>
<ol start="5" type="1">
<li>反函数</li>
</ol>
<p>函数 <span class="math inline">\(y = f(x)\)</span> 的定义域为 <em>D</em>，值域为 <em>R</em>，若对于 <span class="math inline">\(\forall y \in R\)</span>，都存在唯一的 <span class="math inline">\(x \in D\)</span>，使得 <span class="math inline">\(y = f(x)\)</span> 成立，则由此定义一个新的函数 <span class="math inline">\(x = \varphi (y)\)</span>，这个函数称为函数 <span class="math inline">\(y = f(x)\)</span> 的<strong>反函数</strong>，记作 <span class="math inline">\(x = f^{-1}(y)\)</span>。</p>
<p>（严格）单调的函数必有反函数，但有反函数的函数不一定是单调函数。</p>
<h3 id="函数图像">函数图像</h3>
<ol type="1">
<li><p>直角坐标系 <span class="math inline">\(f(x,y) = 0\)</span></p></li>
<li><p>极坐标系 <span class="math inline">\(g(r,\theta) = 0\)</span></p></li>
</ol>
<p>极坐标系与直角坐标系的转化：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; r = x^2 + y^2, \; \tan \theta = \frac{y}{x} \\
&amp; x = r \cos \theta, \; y = r\sin \theta
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>参数方程 <span class="math inline">\(\left\{\begin{aligned}&amp; x = \varphi(t) \\&amp; y = \psi(t)\end{aligned}\right.\)</span></li>
</ol>
<h2 id="常用知识">常用知识</h2>
<h3 id="数列求和">数列求和</h3>
<p>等差数列前 <em>n</em> 项和：<span class="math inline">\(S_n = \frac{n}{2}(a_1+a_n)\)</span></p>
<p>等比数列1前 <em>n</em> 项和：<span class="math inline">\(S_n = \frac{a_1(1-q^n)}{1-q}\)</span></p>
<p>其他：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{k=1}^n k^2 = \frac{n(n+1)(2n+1)}{6}\\
&amp; \sum_{k=1}^n \frac{1}{k(k+1)} = \frac{n}{n+1}\\
\end{aligned}
\]</span></p>
<h3 id="三角函数变换">三角函数变换</h3>
<ol type="1">
<li>基本关系</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp;\csc \alpha = \frac{1}{\sin \alpha}, \quad \sec \alpha =  \frac{1}{\cos\alpha}, \quad\cot \alpha =  \frac{1}{\tan \alpha}, \\
&amp;\tan \alpha =  \frac{\sin \alpha}{\cos \alpha} = \sin \alpha \sec \alpha, \quad \sin \alpha = \tan \alpha \cos \alpha = \frac{\tan \alpha}{\sec \alpha}, \\
&amp;\sin ^2 \alpha + \cos ^2 \alpha = 1, \quad 1 + \tan^2 \alpha = \sec ^2 \alpha, \quad 1+\cot^2\alpha = \csc ^2 \alpha, \\
&amp;\sin^2\alpha = (1 + \cos \alpha)(1- \cos \alpha), \quad \cos ^2 \alpha = (1+\sin \alpha)(1 - \sin \alpha), \\
&amp;\cos \alpha = \frac{1}{\sec \alpha} = \frac{1}{\sqrt{1 + \tan^2 \alpha}}, \quad \sin \alpha = \tan \alpha \cos \alpha = \frac{\tan \alpha}{\sqrt{1 + \tan^2 \alpha}}
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li>倍角公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin 2\alpha = 2\sin \alpha \cos \alpha, \quad \cos 2\alpha = \cos^2\alpha -\sin^2\alpha = 1 - 2\sin^2\alpha = 2\cos^2\alpha -1, \\
&amp; \tan 2\alpha = \frac{2\tan \alpha}{1 - \tan^2\alpha},\quad \cot 2\alpha = \frac{\cot^2\alpha-1}{2\cot \alpha}, \\
&amp; \sin 3\alpha = -4\sin^3\alpha + 3\sin \alpha, \quad \cos 3\alpha = 4\cos^3\alpha - 3\cos \alpha
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>半角公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin^2 \frac{\alpha}{2} = \frac {1}{2}(1 - \cos \alpha), \quad  \cos^2 \frac{\alpha}{2} = \frac {1}{2}(1 + \cos \alpha),\\
&amp; \sin \frac{\alpha}{2} = \pm \sqrt{\frac {1}{2}(1 - \cos \alpha)}, \quad  \cos \frac{\alpha}{2} =\pm \sqrt{ \frac {1}{2}(1 + \cos \alpha)},\\
&amp; \tan \frac {\alpha}{2} = \frac {1 - \cos \alpha}{\sin \alpha} = \frac{\sin \alpha}{1 + \cos \alpha} = \pm \sqrt{\frac{1 - \cos \alpha}{1 + \cos \alpha}}, \\
&amp; \cot \frac {\alpha}{2} = \frac {\sin \alpha}{1 - \cos \alpha} = \frac{1 + \cos \alpha}{\sin \alpha} = \pm \sqrt{\frac{1 + \cos \alpha}{1 - \cos \alpha}}
\end{aligned}
\]</span></p>
<ol start="4" type="1">
<li>万能公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; u = \tan \frac{\alpha}{2} \\
&amp; \sin \alpha=\frac{2u}{1+u^2}, \quad \cos \alpha=\frac{1-u^2}{1+u^2}, \quad \tan \alpha=\frac{2u}{1-u^2}
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li>诱导公式</li>
</ol>
<p>所谓『<strong>奇变偶不变，符号看象限</strong>』。即 <span class="math inline">\(f(\frac{k}{2}\pi + \alpha), \; k \in \mathbf{Z}, \; f\)</span> 表示 <span class="math inline">\(\sin,\; \cos\)</span> 中的一个。则当 <em>k</em> 为奇数时变为异名函数，当 <em>k</em> 为偶数时函数名不变。前面加上把 <span class="math inline">\(\alpha\)</span> 当作锐角时原来函数的符号。</p>
<p><span class="math inline">\(\sin \theta\)</span> 在第一、二象限符号为正，在第三、四象限符号为负，<span class="math inline">\(\cos \theta\)</span> 在第一、四象限符号为正，在第二、三象限符号为负。</p>
<ol start="6" type="1">
<li>两角和差的三角函数公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin (\alpha \pm \beta) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta, \quad \cos (\alpha \pm \beta) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta l,\\
&amp; \tan (\alpha \pm \beta) = \frac{\tan \alpha \pm \tan \beta}{1\mp \tan \alpha \tan\beta},\quad  \cot (\alpha\pm\beta) = \frac{ \cot \alpha \cot \beta \mp 1}{\cot \beta \pm \cot \alpha}
\end{aligned}
\]</span></p>
<ol start="7" type="1">
<li>和差化积公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin \alpha + \sin \beta = 2 \sin \frac{\alpha + \beta}{2}\cos\frac{\alpha - \beta}{2}, \quad \sin \alpha - \sin \beta = 2 \sin \frac{\alpha - \beta}{2}\cos\frac{\alpha + \beta}{2} \\
&amp; \cos \alpha + \cos \beta = 2 \cos \frac{\alpha + \beta}{2}\cos\frac{\alpha - \beta}{2}, \quad \cos \alpha - \cos \beta = -2 \sin \frac{\alpha + \beta}{2}\sin\frac{\alpha - \beta}{2} \\
&amp; \tan \alpha \pm \tan \beta=\frac{\sin \alpha}{\cos \alpha} \pm \frac{\sin \beta}{\cos \beta}=\frac{\sin \alpha \cos \beta \pm \cos \alpha \sin \beta}{\cos \alpha \cos \beta}=\frac{\sin (\alpha \pm \beta)}{\cos \alpha \cos \beta}
\end{aligned}
\]</span></p>
<ol start="8" type="1">
<li>积化和差公式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \cos \alpha \cos \beta =\frac{1}{2}[\cos (\alpha+\beta)+\cos (\alpha-\beta)], \quad \sin \alpha \sin \beta =-\frac{1}{2}[\cos (\alpha+\beta)-\cos (\alpha-\beta)] \\
&amp; \sin \alpha \cos \beta =\frac{1}{2}[\sin (\alpha+\beta)+\sin (\alpha-\beta)], \quad \cos \alpha \sin \beta =\frac{1}{2}[\sin (\alpha+\beta)-\sin (\alpha-\beta)]
\end{aligned}
\]</span></p>
<h3 id="对数和指数运算">对数和指数运算</h3>
<p>指数运算法则：</p>
<p><span class="math display">\[
a^\alpha \cdot a^\beta = a ^{\alpha + \beta}, \quad \frac{a^\alpha}{a^\beta} = a^{\alpha - \beta},  \quad (a^\alpha)^\beta = a^{\alpha \beta},  \quad (ab)^\alpha = a^\alpha b^\alpha, \quad \left(\frac{a}{b}\right)^\alpha = \frac{a^\alpha}{b^\alpha}
\]</span></p>
<p>对数运算法则：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \log _a MN = \log _a M + \log _a N, \quad  \log _a \frac{M}{N} = \log _a M - \log _a N, \\
&amp; \log _a M^k = k \log _a M, \quad  \log _a \sqrt[k]{M}  = \frac{1}{k} \log _a M
\end{aligned}
\]</span></p>
<p>指对数互相转换：</p>
<p><span class="math display">\[
a^k = N \Rightarrow \log _a N = k
\]</span></p>
<p>指对数恒等式：</p>
<p><span class="math display">\[
a^{\log _a N} = N
\]</span></p>
<h3 id="常用因式分解">常用因式分解</h3>
<p><span class="math display">\[
\begin{aligned}
(1) \; &amp;(a + b)^3 = a^3 + 3a^2b +3b^2a +b^3, \quad (a + b)^3 = a^3 + 3a^2b +3b^2a +b^3, \\
&amp; \begin{aligned}(a + b)^n = \sum _{k = 0}^n \text{C}_n^k a^{n-k}b^k = &amp;a^n + na^{n-1}b + \frac{n(n-1)}{2!}a^{n-2}b^2+ \cdots + \\
&amp;\frac{n(n-1)\cdots(n - k + 1)}{k!}a^{n-k}b^k +\cdots+ nab^{n-1} + b^n
\end{aligned} \\
(2) \; &amp; a^3 - b^3 = (a - b)\left(a^2 + ab + b^2\right), \quad a^3 + b^3 = (a + b)\left(a^2 - ab + b^2\right), \\
&amp; a^n - b^n = (a - b)\left(a^{n-1} + a^{n-2}b +\cdots+b^{n-2}a + b^{n-1}\right), \\
&amp; a^n + b^n \; (n = 2k + 1, k \in \mathbb{Z})  = (a+b)\left(a^{n-1} - a^{n-2}b + a^{n-3}b^2 -\cdots - ab^{n-2} + b^{n-1}\right)
\end{aligned}
\]</span></p>
<h3 id="一元二次方程的根">一元二次方程的根</h3>
<p>对于一元二次方程 <span class="math inline">\(ax^2 + bx + c = 0 \;(a \neq 0)\)</span>：</p>
<ul>
<li>判别式 <span class="math inline">\(\Delta = b^2 -4ac\)</span>，<span class="math inline">\(\Delta ＞0\)</span> 方程有两个不等实根，<span class="math inline">\(\Delta =0\)</span> 方程有两个相等实根，<span class="math inline">\(\Delta &lt; 0\)</span> 方程有一对共轭复根。</li>
<li>求根公式：</li>
</ul>
<p><span class="math display">\[
x_{1,2} = \frac{-b \pm \sqrt{\Delta}}{2a}
\]</span></p>
<ul>
<li>韦达定理：</li>
</ul>
<p><span class="math display">\[
x_1 + x_2 = -\frac{b}{a}, \quad x_1x_2 = \frac{c}{a}
\]</span></p>
<h3 id="常用不等式">常用不等式</h3>
<ol type="1">
<li>绝对值不等式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; |a \pm b| \leq |a| + |b|, \; ||a|-|b|| \leq |a-b| \; (a,b \in \mathbb{R})\\
&amp; |a_1\pm a_2 \pm\cdots\pm a_n| \leq |a_1| + |a_2| +\cdots+ |a_n| \;(a_1,a_2,\ldots,a_n \in \mathbb{R})\\
&amp; \left| \int _a^b f(x)\text{d}x\right| \leq \int _a^b \left|f(x)\right| \text{d} x
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li>均值不等式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; \sqrt{ab} \leq \frac{a+b}{2} \leq \sqrt{\frac{a^2+b^2}{2}} \;(a,b &gt; 0)\\
&amp; \sqrt[3]{abc} \leq \frac{a+b+c}{3} \leq \sqrt{\frac{a^2+b^2+c^2}{3}} \;(a,b,c &gt; 0)
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>柯西不等式</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp; (ac+bd)^2 \leq (a^2+b^2)(c^2+d^2) \\
&amp; \left|\vec{p}\cdot\vec{q}\right| \leq \left|\vec{p}\right|\cdot \left|\vec{q}\right| \;(\vec{p} = (p_1,p_2,\ldots,p_n), \; \vec{q} = (q_1,q_2,\ldots,q_n))\\
&amp; \left(\int _a^b f(x)g(x) \text{d}x\right)^2 \leq \int _a^b f^2(x) \text{d}x \int _a^b g^2(x) \text{d}x
\end{aligned}
\]</span></p>
<p>4.其他不等式</p>
<p><span class="math display">\[
\begin{aligned}
(1) \; &amp; a &gt; b &gt; 0, \; m &gt;0, \; n &lt; 0 \Rightarrow a^m &gt; b^m, \; a^n &lt; b^n \\
(2) \; &amp; \sin x &lt; x \;(x &gt;0) \\
(3) \; &amp; \sin x &lt; x &lt; \tan x \;\left(0 &lt; x &lt; \frac{\pi}{2}\right)\\
(4) \; &amp; \arctan x \leq x \leq \arcsin x \;(0 \leq x \leq 1) \\
(5) \; &amp; e^x \leq x + 1 \\
(6) \; &amp; \ln x \leq x - 1 \;(x &gt; 0) \\
(7) \; &amp; \frac{1}{x+1} &lt; \ln \left( 1 + \frac{1}{x} \right) &lt; \frac{1}{x} 
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Calulus</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_线性表，栈、队列和数组</title>
    <url>/2022/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数据结构线性表部分的知识总结<br />
内容包括：<br />
1. 线性表的概念和代码实现<br />
2. 栈、队列的概念和代码实现<br />
3. 特殊矩阵的压缩</p>
<hr>
<span id="more"></span>
<p><strong>本文索引</strong></p>
<ul>
<li><a href="#线性表">线性表</a>
<ul>
<li><a href="#顺序表">顺序表</a>
<ul>
<li><a href="#顺序表的定义和初始化">顺序表的定义和初始化</a></li>
<li><a href="#顺序表的基本操作">顺序表的基本操作</a></li>
</ul></li>
<li><a href="#链表">链表</a>
<ul>
<li><a href="#单链表">单链表</a></li>
<li><a href="#静态链表">静态链表</a></li>
<li><a href="#双向链表">双向链表</a></li>
<li><a href="#循环链表">循环链表</a></li>
</ul></li>
<li><a href="#顺序表和链表的比较">顺序表和链表的比较</a></li>
</ul></li>
<li><a href="#栈队列和数组">栈、队列和数组</a>
<ul>
<li><a href="#栈">栈</a>
<ul>
<li><a href="#顺序栈">顺序栈</a></li>
<li><a href="#链式栈">链式栈</a></li>
</ul></li>
<li><a href="#队列">队列</a>
<ul>
<li><a href="#顺序队列循环队列">顺序队列（循环队列）</a></li>
<li><a href="#链式队列">链式队列</a></li>
<li><a href="#双端队列">双端队列</a></li>
</ul></li>
<li><a href="#栈和队列的应用">栈和队列的应用</a>
<ul>
<li><a href="#栈_括号匹配">栈_括号匹配</a></li>
<li><a href="#栈_表达式">栈_表达式</a></li>
<li><a href="#栈_递归函数调用">栈_递归函数调用</a></li>
<li><a href="#队列_层次遍历">队列_层次遍历</a></li>
<li><a href="#队列_计算机系统">队列_计算机系统</a></li>
</ul></li>
<li><a href="#数组_矩阵的压缩存储">数组_矩阵的压缩存储</a>
<ul>
<li><a href="#对称矩阵">对称矩阵</a></li>
<li><a href="#三角矩阵">三角矩阵</a></li>
<li><a href="#三对角矩阵">三对角矩阵</a></li>
<li><a href="#稀疏矩阵">稀疏矩阵</a></li>
</ul></li>
</ul></li>
</ul>
<hr>
<p>线性表、栈和队列的完整代码均已上传到我的 GitHub：</p>
<ul>
<li><a href="https://github.com/Cohanbb/mycode/tree/main/c-cpp/DS">C/C++ 实现</a> <!--* [Go 实现](https://github.com/Cohanbb/mycode/tree/main/go/DS)--></li>
</ul>
<h1 id="线性表">线性表</h1>
<p>线性表是<strong>零或多个相同数据类型的有限序列</strong>。逻辑结构为线性结构，存储结构为顺序存储或链式存储，对应<a href="#顺序表">顺序表</a>或<a href="#链表">链表</a>。</p>
<p>线性表的抽象数据类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ADT List</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Data</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">InitList</span><span class="params">(&amp;L)</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">Empty</span>(L); <span class="comment">// 判断是否是空表</span></span><br><span class="line">    <span class="built_in">ListInsert</span>(&amp;L, i, e); <span class="comment">// 在第 i 个位置插入 e</span></span><br><span class="line">    <span class="built_in">ListDelete</span>(&amp;L, i, &amp;e); <span class="comment">// 删除第 i 个位置的数据并用 e 返回</span></span><br><span class="line">    <span class="built_in">LocateElem</span>(L, e); <span class="comment">// 按值查找</span></span><br><span class="line">    <span class="built_in">GetElem</span>(L, i); <span class="comment">// 按位查找</span></span><br><span class="line">    <span class="built_in">Length</span>(L); <span class="comment">// 求表长</span></span><br><span class="line">    <span class="built_in">PrintList</span>(L); <span class="comment">// 打印表</span></span><br><span class="line">    <span class="built_in">DestroyList</span>(&amp;L); <span class="comment">// 销毁表</span></span><br></pre></td></tr></table></figure>
<h2 id="顺序表">顺序表</h2>
<p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构称为顺序表。</p>
<h3 id="顺序表的定义和初始化">顺序表的定义和初始化</h3>
<p>地址连续的存储结构完全可以使用数组或者一个指向连续地址的指针来实现，故可以轻松写出顺序表的静态创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义顺序表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize N <span class="comment">// N 为自定义的整数，表示顺序表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sqlist</span> &#123;</span><br><span class="line">    ElemType data[Maxsize]; <span class="comment">// ElemType 为元素数据类型</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 顺序表实际存储数据的长度</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 初始化顺序表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span> <span class="params">(<span class="keyword">struct</span> Sqlist &amp;List)</span> </span>&#123;</span><br><span class="line">    List.length = <span class="number">0</span>; <span class="comment">// 初始长度为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">        List.data[i] = <span class="number">0</span>; <span class="comment">// 避免脏数据</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 实例化顺序表 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Sqlist</span> L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上定义的顺序表的最大长度为 Maxsize，若想顺序表的最大长度可变，则需动态创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义顺序表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize N <span class="comment">// 顺序表的初始最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sqlist</span> &#123;</span><br><span class="line">    ElemType *data; <span class="comment">// 指向顺序表首地址</span></span><br><span class="line">    <span class="type">int</span> maxsize, length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化顺序表 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(<span class="keyword">struct</span> Sqlist &amp;List)</span> </span>&#123;</span><br><span class="line">    List.maxsize = Initsize; <span class="comment">// 初始最大长度</span></span><br><span class="line">    List.length = <span class="number">0</span>; <span class="comment">// 初始长度为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; List.maxsize; i++)</span><br><span class="line">        List.data[i] = <span class="number">0</span>; <span class="comment">// 避免脏数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化顺序表 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Sqlist</span> L;</span><br><span class="line">    L.data = <span class="keyword">new</span> ElemType[Initsize];</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序表的基本操作">顺序表的基本操作</h3>
<p>插入（在表 L 的第 i 个位置插入 e）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="comment">// 超出表的实际长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length == Maxsize) <span class="comment">// 表已达最大长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--)  <span class="comment">// 从第 i 个位置循环后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>]; <span class="comment">// 赋值给后面的元素</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = e; <span class="comment">// 将第 i 个位置赋值为 e</span></span><br><span class="line">    L.length++; <span class="comment">// 实际长度加一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除（删除表 L 的第 i 个元素并用 e 返回删除值）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(Sqlist &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="comment">// 超出表的实际长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++) <span class="comment">// 将第 i 个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j]; <span class="comment">// 赋值给前面的元素</span></span><br><span class="line">    L.data[L.length - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 将末尾的元素设为 0</span></span><br><span class="line">    L.length--; <span class="comment">// 实际长度减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找（表 L 中的第一次出现的 e 的位置）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 找到返回位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<p>链表是一种非常非常非常重要的数据结构！</p>
<p>顺序表插入和删除需要移动大量的元素，链表通过指针将逻辑上相邻的元素连接起来，不需要在连续地址上存储。</p>
<h3 id="单链表">单链表</h3>
<p>单链表的每个结点除了要存储自身数据外还要存储指向后继元素的指针。</p>
<p>单链表必须有一个指向链表首地址的<strong>头指针</strong>，有两种定义方式，带头结点和不带头结点。不带头结点 的方式更直观但是不方便进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义结点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data; <span class="comment">// 自身数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">// 指向下一个结点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> LNode, *LinkList; <span class="comment">// 结点，链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带头结点初始化 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;List)</span> </span>&#123;</span><br><span class="line">    List = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="keyword">if</span> (List == <span class="literal">NULL</span>) <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    List-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始为空表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList &amp;List)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表的基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 按位查找 */</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList &amp;List, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> List; <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="comment">// 结点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = List;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; i &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按值查找 */</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList &amp;List, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = List-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入（后插） */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;List, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = <span class="built_in">GetElem</span>(List, i - <span class="number">1</span>); <span class="comment">// 找到前驱结点</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 在前驱结点后插入</span></span><br><span class="line">    LNode *s = <span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next; </span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拓展：前插 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先后插</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="comment">// 交换前后数据</span></span><br><span class="line">    temp = p-&gt;data;</span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    s-&gt;data = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;List, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    LNode *p = <span class="built_in">GetElem</span>(List, i - <span class="number">1</span>); <span class="comment">// 找到前驱结点 </span></span><br><span class="line">    <span class="keyword">if</span> (!p) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表的整表创建和销毁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 头插法 */</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;List)</span> </span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    ElemType x;</span><br><span class="line">    List = <span class="keyword">new</span> LNode;</span><br><span class="line">    List-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &amp;&amp; x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> LNode;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = List-&gt;next;</span><br><span class="line">        List-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> List;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾插法 */</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;List)</span> </span>&#123;</span><br><span class="line">    LNode *s, *r = List;</span><br><span class="line">    ElemType x;</span><br><span class="line">    List = <span class="keyword">new</span> LNode;</span><br><span class="line">    List-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &amp;&amp; x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> LNode;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> List;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁表 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;List)</span> </span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">while</span> (List) &#123;</span><br><span class="line">        p = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态链表">静态链表</h3>
<p>在早期的编程语言中没有指针、引用等机制，只能使用<strong>数组</strong>来代替指针，这样的链表内存固定，地址连续，称为静态链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义静态链表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize N </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLinkList</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next; <span class="comment">// 下一个元素下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SLinkList</span> SLinkList[Maxsize];</span><br></pre></td></tr></table></figure>
<h3 id="双向链表">双向链表</h3>
<p>每个结点除了存有数据和指向下一个结点的指针 next 外，还存有指向上一个结点的指针 prior。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义双向链表 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *next, *prior;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span> DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入（*p 后插入 *s） */</span></span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt; prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除（删除 *p 后的 *q） */</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<p>一种特殊的链表，即末尾结点 *r 的 next 指针指向头结点 <code>r-&gt;next = L</code>，好处是可以快速的找到尾结点而不用遍历表，如果是循环双链表还需要 <code>L-&gt;prior = r</code>。</p>
<h2 id="顺序表和链表的比较">顺序表和链表的比较</h2>
<ol type="1">
<li>顺序表随机存取/读写，链表只能顺序存取/读写。</li>
<li>顺序表逻辑相邻的元素存储位置也相邻。</li>
<li>链表分配内存空间灵活高效。</li>
<li>链表的插入和删除更高效。</li>
<li>顺序表插入和删除需要移动大量的元素。</li>
</ol>
<h1 id="栈队列和数组">栈、队列和数组</h1>
<p>栈和队列都是特殊的线性表，对数据的插入和删除操作有特殊的规定，使得数据的进出策略有所不同。</p>
<h2 id="栈">栈</h2>
<p><strong>栈（Stack）</strong>是只允许在一端进行插入或删除操作的线性表。</p>
<p>允许插入或删除的一端称为<strong>栈顶（Top）</strong>，另一端称为<strong>栈底（Bottom）</strong>，由于只允许一端进行插入或删除，栈的数据进出策略简单概括为<strong>后进先出（Last In First Out, LIFO）</strong>。</p>
<blockquote>
<p>n 个不同元素进栈，出栈元素有 <span class="math inline">\(\frac{1}{n+1}C_{2n}^{n}\)</span> 种不同排列。</p>
</blockquote>
<h3 id="顺序栈">顺序栈</h3>
<p>使用顺序结构存储栈元素的栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize 20 <span class="comment">// Initial Size 初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqStack</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> top, maxsize;</span><br><span class="line">&#125; sqstack;</span><br></pre></td></tr></table></figure>
<p>基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize Sequential Stack 初始化顺序结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(sqstack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.maxsize = Initsize;</span><br><span class="line">    S.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * S.maxsize);</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(sqstack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extend Size of Stack 扩充栈容量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendStack</span><span class="params">(sqstack &amp;S, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = S.data; <span class="comment">// p 指向原地址</span></span><br><span class="line">    S.maxsize += n; <span class="comment">// 扩容</span></span><br><span class="line">    S.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * S.maxsize); <span class="comment">// 开辟新地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)</span><br><span class="line">        S.data[i] = p[i];</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放原地址</span></span><br><span class="line">    p = <span class="literal">NULL</span>; <span class="comment">// p 置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Push Element 元素入栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(sqstack &amp;S, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top + <span class="number">1</span> == S.maxsize)</span><br><span class="line">        <span class="built_in">ExtendStack</span>(S, <span class="number">1</span>);</span><br><span class="line">    S.data[++S.top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pop Element 元素出栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(sqstack &amp;S, <span class="type">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Stack!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = S.data[S.top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Print Sequential Stack 打印顺序结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">(sqstack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Stack!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S.data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy Sequential Stack 销毁顺序结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(sqstack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(S-&gt;data); <span class="comment">// 释放数组内存</span></span><br><span class="line">    S-&gt;data = <span class="literal">NULL</span>; <span class="comment">// 指针置空</span></span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    S-&gt;maxsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式栈">链式栈</h3>
<p>使用链式结构存储栈元素的栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next; </span><br><span class="line">&#125; LNode, *linkstack;</span><br></pre></td></tr></table></figure>
<p>基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize Link Stack 初始化链式结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(linkstack &amp;S)</span> </span>&#123;</span><br><span class="line">    S = (lnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(lnode));</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail To Init!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(linkstack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(linkstack &amp;S, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    lnode *p = (lnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(lnode)); <span class="comment">// 开辟新结点作为栈顶</span></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(linkstack &amp;S, <span class="type">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Stack!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lnode *p = S-&gt;next; <span class="comment">// p 指向栈顶</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    S-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放该结点内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Print Link Stack 打印链式结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">(linkstack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty List!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lnode *p = S-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy Link Stack 销毁链式结构栈 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(linkstack &amp;S)</span> </span>&#123;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="keyword">while</span> (S) &#123;</span><br><span class="line">        p = S;</span><br><span class="line">        S = S-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">// 释放该结点内存 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p><strong>队列（Queue）</strong>也是一种操作受限制的先行表，只允许在表的一端进行插入，在表的另一端进行删除。</p>
<p>向队列插入元素的操作称为入队或进队，删除元素的操作称为出队。允许删除数据的一端称为<strong>队头（Front）</strong>，允许插入元素的一端称为<strong>队尾（Rear）</strong>。其数据的进出策略可以简单概括为<strong>先进先出（First In First Out, FIFO）</strong>。</p>
<h3 id="顺序队列循环队列">顺序队列（循环队列）</h3>
<p>使用顺序结构存储队列元素的循环队列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize 20 <span class="comment">// Initial Size 初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> front, rear, maxsize;</span><br><span class="line">&#125; sqqueue;</span><br></pre></td></tr></table></figure>
<p>基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize Sequential Queue 初始化顺序结构循环队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(sqqueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.maxsize = Initsize;</span><br><span class="line">    Q.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * Q.maxsize);</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Q.maxsize; i++)</span><br><span class="line">        Q.data[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(sqqueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.rear == Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extend Size of Queue 扩充循环队列的容量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendQueue</span><span class="params">(sqqueue &amp;Q, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = Q.data; <span class="comment">// p 指向原地址</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    j = Q.maxsize;</span><br><span class="line">    Q.maxsize += n; <span class="comment">// 扩容</span></span><br><span class="line">    Q.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * Q.maxsize); <span class="comment">// 开辟新地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (Q.rear + j - Q.front) % j; i++)</span><br><span class="line">        Q.data[i] = p[(Q.front + i) % j];</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放原地址</span></span><br><span class="line">    p = <span class="literal">NULL</span>; <span class="comment">// p 置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element Enter Queue 元素进入队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnterQueue</span><span class="params">(sqqueue &amp;Q, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % Q.maxsize == Q.front)</span><br><span class="line">        <span class="built_in">ExtendQueue</span>(Q, <span class="number">1</span>);</span><br><span class="line">    Q.data[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % Q.maxsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element Exit Queue 元素退出队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExitQueue</span><span class="params">(sqqueue &amp;Q, <span class="type">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Queue!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % Q.maxsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Print Sequential Queue 打印顺序结构循环队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(sqqueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Queue!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (Q.rear + Q.maxsize - Q.front) % Q.maxsize; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Q.data[(Q.front + i) % Q.maxsize]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy Sequential Queue 销毁顺序结构循环队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(sqqueue *Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Q)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(Q-&gt;data); <span class="comment">// 释放数组的内存</span></span><br><span class="line">    Q-&gt;data = <span class="literal">NULL</span>; <span class="comment">// 指针置空</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;maxsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式队列">链式队列</h3>
<p>使用链式结构存储队列元素的队列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next; </span><br><span class="line">&#125; lnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">    lnode *front;</span><br><span class="line">    lnode *rear;</span><br><span class="line">&#125; linkqueue;</span><br></pre></td></tr></table></figure>
<p>基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize Link Queue 初始化链式结构队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(linkqueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (lnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(lnode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(linkqueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Elements Enter Queue 元素入队 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnterQueue</span><span class="params">(linkqueue &amp;Q, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    lnode *s = (lnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(lnode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element Exit Queue 元素出队 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExitQueue</span><span class="params">(linkqueue &amp;Q, <span class="type">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Queue!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lnode *p = Q.front-&gt;next; <span class="comment">// p 指向要删除的结点</span></span><br><span class="line">    e = Q.front-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p ==  Q.rear) <span class="comment">// 若 p 等于尾结点，则队列置空</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放该结点内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Print Link Queue 打印链式结构队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(linkqueue Q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy Link Queue 销毁链式结构队列 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(linkqueue &amp;Q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双端队列">双端队列</h3>
<p>将队列的两端称作前端和后端，两端都可以进行入队和出队操作的队列。</p>
<ul>
<li><p>输入受限的双端队列</p></li>
<li><p>输出受限的双端队列</p></li>
</ul>
<h2 id="栈和队列的应用">栈和队列的应用</h2>
<h3 id="栈_括号匹配">栈_括号匹配</h3>
<h3 id="栈_表达式">栈_表达式</h3>
<h3 id="栈_递归函数调用">栈_递归函数调用</h3>
<h3 id="队列_层次遍历">队列_层次遍历</h3>
<h3 id="队列_计算机系统">队列_计算机系统</h3>
<h2 id="数组_矩阵的压缩存储">数组_矩阵的压缩存储</h2>
<h3 id="对称矩阵">对称矩阵</h3>
<h3 id="三角矩阵">三角矩阵</h3>
<h3 id="三对角矩阵">三对角矩阵</h3>
<h3 id="稀疏矩阵">稀疏矩阵</h3>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_绪论</title>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>数据结构与算法的入门概念。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<ul>
<li><a href="#数据结构">数据结构</a>
<ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#逻辑结构数据元素之间的相互关系">逻辑结构：数据元素之间的相互关系</a></li>
<li><a href="#数据运算">数据运算</a></li>
<li><a href="#数据的物理结构">数据的物理结构</a></li>
<li><a href="#抽象数据类型">抽象数据类型</a></li>
</ul></li>
<li><a href="#算法">算法</a></li>
<li><a href="#算法效率的度量">算法效率的度量</a>
<ul>
<li><a href="#算法的时间复杂度">算法的时间复杂度</a></li>
<li><a href="#算法的空间复杂度">算法的空间复杂度</a></li>
</ul></li>
</ul>
<hr>
<blockquote>
<p>Preface:</p>
<ol type="1">
<li><p>本篇所有代码均由 C++ 实现</p></li>
<li>参考文献：</li>
</ol>
<ul>
<li>大话数据结构（程杰）</li>
<li>数据结构考研指导（王道论坛）</li>
</ul>
</blockquote>
<h1 id="数据结构">数据结构</h1>
<h2 id="基本概念">基本概念</h2>
<p>数据：描述客观事物的符号，计算机的可操作对象，是一个整体的概念。</p>
<p><strong>数据元素</strong>：组成数据的基本单位，如数组的一项。</p>
<p>数据对象：相同性质的数据元素的集合，是数据的子集合。</p>
<p>数据项：数据不可分割的最小单位。</p>
<p><strong>数据结构（data structure）</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>四者关系可以如此表示：</p>
<p><img src="1.png" /></p>
<h2 id="逻辑结构数据元素之间的相互关系">逻辑结构：数据元素之间的相互关系</h2>
<p><strong>集合结构</strong><br />
数据元素除了同属一个集合外没有其他关系。</p>
<p><strong>线性结构</strong><br />
数据元素是一对一关系，除第一个元素外均有唯一前驱，除最后一个元素外均有唯一后继。</p>
<p><strong>树形结构</strong><br />
数据元素是一对多关系，有唯一的前驱和多个后继。</p>
<p><strong>图装结构</strong><br />
数据元素是多对多关系。</p>
<h2 id="数据运算">数据运算</h2>
<p>数据的查找、插入和删除等操作。</p>
<h2 id="数据的物理结构">数据的物理结构</h2>
<p>数据的存储结构影响着数据运算的效率和可行性。</p>
<blockquote>
<p>此部分知识在<a href="操作系统_文件管理.md">操作系统_文件管理</a>章节有详细说明。</p>
</blockquote>
<p>顺序存储：数据元素存放在连续的存储单元中。</p>
<p>非顺序存储：链式存储、索引存储、散列存储。</p>
<h2 id="抽象数据类型">抽象数据类型</h2>
<p>抽象数据类型（abstract data type，ADT）是数学的抽象、对实现原理的抽象，即使用者只关心数据对象和相关的操作 <strong>“是什么”</strong>，而不关心 <strong>“如何实现”</strong>。</p>
<p>如 C语言中的结构体（struct）、C++/Java/Python 中的类（class）等。</p>
<p>换言之，对于一门计算机语言来说，只要不是基本数据类型，即为抽象数据类型。</p>
<blockquote>
<p>拓展：同样采取抽象思想的还有应用程序接口（application programming interface，API）。</p>
</blockquote>
<h1 id="算法">算法</h1>
<p>算法（algorithm）是处理问题的方法、步骤，不仅涉及计算机科学，在计算机中是由程序实现，如函数、方法、类或是整个程序框架。</p>
<p>算法的特性：有穷性、可行性、确定性。</p>
<p>算法设计的要求：正确性、可读性、健壮性、时间效率高和存储量低。</p>
<h1 id="算法效率的度量">算法效率的度量</h1>
<h2 id="算法的时间复杂度">算法的时间复杂度</h2>
<p>算法的时间复杂度即事先预估算法的时间开销与问题规模 n 的关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123; <span class="comment">// n+1</span></span><br><span class="line">        i++; <span class="comment">// n</span></span><br><span class="line">        std::cout &lt;&lt; “Hello”; <span class="comment">// n</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; “World\n”; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序的时间复杂度为 T(n) = 3n+3.</p>
<p><strong>大O表示法</strong><br />
上限表示法，即算法在最坏的情况下的时间复杂度。</p>
<p><span class="math display">\[
T(n)=O(f(n)) \Leftrightarrow \lim_{n \to \infty} \frac{T(n)}{f(n)}=c(c\text{为常数}).
\]</span></p>
<p>故上述算法的时间复杂度为 T(n) = O(n).</p>
<p>常见算法的时间复杂度（从小到达排列）:</p>
<p><span class="math display">\[
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n).
\]</span></p>
<p>算法的时间复杂度相加，只保留最高阶的项。</p>
<p><span class="math display">\[
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
\]</span></p>
<h2 id="算法的空间复杂度">算法的空间复杂度</h2>
<p>程序的指令和数据存储在内存中，算法的空间复杂度即为程序占内存的大小与问题规模 n 的关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[n]; <span class="comment">// n Byte</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// 4 Byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的空间复杂度为 S(n) = n+1，同样使用大O表示法，则 S(n) = O(n).</p>
<p>递归函数调用的内存开销：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 8 Byte</span></span><br><span class="line">    <span class="built_in">func</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数递归调用 n 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数递归调用 n 次，每次在内存中增加两个 int 型变量，故 S(n) = O(n).</p>
<p>若将程序改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[n]; <span class="comment">// n Byte</span></span><br><span class="line">    <span class="built_in">func</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数递归调用 n 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则函数每次调用需在内存中增加一个 int 型数组，从 n 到 1 数组的长度分别为 n, n-1, … , 1，则总的长度为 <span class="math inline">\(\frac{1}{2}(n^2+n)\)</span>，故 S(n) = O(n<sup>2</sup>).</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>极限</title>
    <url>/2022/09/05/%E6%9E%81%E9%99%90/</url>
    <content><![CDATA[<p>高等数学-数列极限、函数极限的概念与计算。</p>
<hr />
<span id="more"></span>
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#数列极限">数列极限</a></li>
<li><a href="#收敛数列的性质">收敛数列的性质</a></li>
<li><a href="#判断数列收敛">判断数列收敛</a>
<ul>
<li><a href="#夹逼准则">夹逼准则</a></li>
<li><a href="#单调有界准则">单调有界准则</a></li>
<li><a href="#柯西极限存在准则">柯西极限存在准则</a></li>
</ul></li>
<li><a href="#邻域">邻域</a></li>
<li><a href="#函数极限">函数极限</a></li>
<li><a href="#函数极限存在的性质">函数极限存在的性质</a></li>
<li><a href="#无穷小">无穷小</a></li>
<li><a href="#函数的连续与间断">函数的连续与间断</a></li>
</ul></li>
<li><a href="#函数极限的计算">函数极限的计算</a>
<ul>
<li><a href="#无法直接计算">无法直接计算</a>
<ul>
<li><a href="#夹逼定理">夹逼定理</a></li>
<li><a href="#单调有界准则-1">单调有界准则</a></li>
</ul></li>
<li><a href="#可直接计算">可直接计算</a>
<ul>
<li><a href="#化简">化简</a></li>
<li><a href="#洛必达法则">洛必达法则</a></li>
<li><a href="#泰勒公式">泰勒公式</a></li>
</ul></li>
</ul></li>
<li><a href="#应试技巧">应试技巧</a></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="数列极限">数列极限</h3>
<p>设 <span class="math inline">\(\{x_n\}\)</span> 为一数列，若存在常数 <em>a</em>，对于任意（无论多小）的 <span class="math inline">\(\varepsilon &gt; 0\)</span>，总存在正整数 <em>N</em>，使得当 <span class="math inline">\(n &gt; N\)</span> 时，有 <span class="math inline">\(|x_n - a| &lt; \varepsilon\)</span> 恒成立，则称 <em>a</em> 为数列 <span class="math inline">\(\{x_n\}\)</span> 的极限，或称数列 <span class="math inline">\(\{x_n\}\)</span> 收敛于 <em>a</em>，记作：</p>
<p><span class="math display">\[
\lim_{n \to \infty} x_n = a \; \text{or} \; x_n \to a \; (n \to \infty)
\]</span></p>
<p>否则称数列 <span class="math inline">\(\{x_n\}\)</span> 是发散的。</p>
<ul>
<li><span class="math inline">\(\varepsilon - N\)</span>：</li>
</ul>
<p><span class="math display">\[
(\lim_{n \to \infty} x_n = a) \Leftrightarrow (\forall \varepsilon &gt; 0)(\exists N \in \mathbf{N_+})[(n &gt; N) \Rightarrow (|x_n - a| &lt; \varepsilon)]
\]</span></p>
<blockquote>
<p>注：由于数列的下标使用正整数表示，此处的 <span class="math inline">\(\infty\)</span> 只能为 <span class="math inline">\(+\infty\)</span>。</p>
</blockquote>
<h3 id="收敛数列的性质">收敛数列的性质</h3>
<ul>
<li>唯一性：如果数列收敛，那么它的极限唯一。</li>
<li>有界性：如果数列收敛，那么它一定有界。</li>
<li>保号性：如果数列 <span class="math inline">\(\{x_n\}\)</span> 的极限为 <em>a</em>，且 <span class="math inline">\(a &gt; 0 \; (\text{or} \;a &lt; 0)\)</span>，则存在正整数 <em>N</em>，当 <span class="math inline">\(n &gt; N\)</span> 时，有 <span class="math inline">\(x_n &gt; 0\;(\text{or} \; x_n &lt; 0)\)</span>。<br />
推论：如果数列 <span class="math inline">\(\{x_n\}\)</span> 从某项起有 <span class="math inline">\(x_n \geq 0\)</span>，且 <span class="math inline">\(\lim x_n = a\)</span>，则 <span class="math inline">\(a \geq 0\)</span>。</li>
</ul>
<h3 id="判断数列收敛">判断数列收敛</h3>
<h4 id="夹逼准则">夹逼准则</h4>
<p>如果数列 <span class="math inline">\(\{x_n\},\{y_n\}, \{z_n\}\)</span> 满足：</p>
<ol type="1">
<li><span class="math inline">\(\exists N \in \mathbf{N_+},\; n &gt; N,\; \{y_n\} \leq \{x_n\} \leq \{z_n\}\)</span></li>
<li><span class="math inline">\(\lim y_n = \lim z_n = a\)</span></li>
</ol>
<p>则 <span class="math inline">\(\lim x_n = a\)</span>。</p>
<h4 id="单调有界准则">单调有界准则</h4>
<p>若数列单调递增（或递减）且有上界（或下界），则数列的极限存在。</p>
<h4 id="柯西极限存在准则">柯西极限存在准则</h4>
<p>数列 <span class="math inline">\(\{x_n\}\)</span> 收敛的<strong>充分必要条件：</strong></p>
<p>对于 <span class="math inline">\(\forall \varepsilon &gt; 0\)</span>，都存在正整数 <em>N</em>，使得当 <span class="math inline">\(n&gt;N,m&gt;N\)</span> 时有</p>
<p><span class="math display">\[
|x_n - x_m | &lt; \varepsilon
\]</span></p>
<p>我们把满足该条件的 <span class="math inline">\(\{x_n\}\)</span> 称为『柯西序列』，那么上述定理可表述成：数列{xn}收敛，当且仅当它是一个柯西序列。</p>
<p>该准则的几何意义表示，收敛数列中的元素随着序数的增加而愈发靠近，即足够靠后的任意两项都无限接近。</p>
<h3 id="邻域">邻域</h3>
<ul>
<li>以 <em>x</em><sub>0</sub> 为中心的任何开区间称为点 <em>x</em><sub>0</sub> 的『邻域』，记作 <span class="math inline">\(U(x_0)\)</span>。</li>
<li><span class="math inline">\(\delta\)</span> 为正数，<span class="math inline">\((x_0 - \delta, x_0 + \delta)\)</span> 为点 <em>x</em><sub>0</sub> 的『<span class="math inline">\(\delta\)</span> 邻域』，即 <span class="math inline">\(\{x\vert |x-x_0| &lt; \delta \}\)</span>，记作 <span class="math inline">\(U(x_0, \delta)\)</span>。</li>
<li>除去 <em>x</em><sub>0</sub> 本身的点 <em>x</em><sub>0</sub> 的 <span class="math inline">\(\delta\)</span> 邻域称为点 <em>x</em><sub>0</sub> 的『去心 <span class="math inline">\(\delta\)</span> 邻域』，即 <span class="math inline">\(\{ x \vert 0 &lt; |x-x_0| &lt; \delta \}\)</span>，记作 <span class="math inline">\(\mathring{U}(x_0, \delta)\)</span>。</li>
</ul>
<h3 id="函数极限">函数极限</h3>
<p><span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 的某去心邻域内有定义，若存在常数 <em>A</em>，对于任意（无论多小）的 <span class="math inline">\(\varepsilon &gt; 0\)</span>，总存在正数 <span class="math inline">\(\delta\)</span>，在 <span class="math inline">\(\mathring{U}(x_0, \delta)\)</span> 内，有 <span class="math inline">\(| f(x) - A | &lt; \varepsilon\)</span> 恒成立，则 <em>A</em> 称为 <span class="math inline">\(f(x)\)</span> 当 <span class="math inline">\(x \to x_0\)</span> 时的『<strong>极限</strong>』，记作：</p>
<p><span class="math display">\[
\lim_{x \to x_0} f(x) = A \; \text{or} \; f(x) \to A \; (x \to x_0)
\]</span></p>
<ul>
<li><span class="math inline">\(\varepsilon - \delta\)</span>：<span class="math display">\[(\lim_{x \to x_0} f(x) = A) \Leftrightarrow (\forall \varepsilon &gt; 0)(\exists \delta &gt; 0)[(0 &lt; | x -x _0 | &lt; \delta) \Rightarrow (|f(x)- A| &lt; \varepsilon)]\]</span></li>
<li><span class="math inline">\(\varepsilon - X\)</span>：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;(\lim_{x \to \infty} f(x) = A) \Leftrightarrow (\forall \varepsilon &gt; 0)(\exists X &gt; 0)[(|x| &gt; X) \Rightarrow (|f(x) - A| &lt; \varepsilon)]\\
&amp;(\lim_{x \to +\infty} f(x) = A) \Leftrightarrow (\forall \varepsilon &gt; 0)(\exists X &gt; 0)[(x &gt; X) \Rightarrow (|f(x) - A| &lt; \varepsilon)]\\
&amp;(\lim_{x \to -\infty} f(x) = A) \Leftrightarrow (\forall \varepsilon &gt; 0)(\exists X &gt; 0)[(-x &gt; X) \Rightarrow (|f(x) - A| &lt; \varepsilon)]
\end{aligned}
\]</span></p>
<ul>
<li><p><span class="math inline">\(\lim_{x \to x_0^-}f(x)\)</span> 为 <span class="math inline">\(x \to x_0\)</span> 时的『左极限』，反之为『右极限』。</p></li>
<li><p>函数极限存在的<strong>充分必要条件</strong>：</p></li>
</ul>
<p><span class="math display">\[
(\lim_{x \to x_0} f(x) = A) \Leftrightarrow (\lim_{x \to x_0^-}f(x) = \lim_{x \to x_0^+}f(x) = A)
\]</span></p>
<p><span class="math display">\[
(\lim_{x \to x_0} f(x) = A) \Leftrightarrow [(x \to x_0) \Rightarrow (f(x) = A + \alpha (x))]
\]</span></p>
<ul>
<li>在高等数学中，仅当极限值为某一确定实数时极限存在。极限值为 <span class="math inline">\(\infty\)</span> 时极限不存在。极限值在某处振荡时极限不存在。</li>
<li>值得注意的是，与函数极限有关的所有讨论，都是基于 <span class="math inline">\(x \to x_0\)</span>，即点 <em>x</em><sub>0</sub> 的任意小的<strong>去心邻域</strong>，与点 <em>x</em><sub>0</sub> 处的函数值 <span class="math inline">\(f(x_0)\)</span> <strong>无任何关系</strong>。</li>
<li>复合函数极限定理：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;u = g(x),\; \lim_{x \to x_0} g(x) = u_0\;(g(x) \neq u_0) \Rightarrow \lim_{x \to x_0} f[g(x)] = \lim_{u \to u_0} f(u)\\
&amp;\text{if} \; f \;\text{is}\; continuous \;\text{at} \; u_0 \Rightarrow \lim_{x \to x_0} f[g(x)]= \lim_{u \to u_0} f(u) = f(u_0) = f\left[\lim_{x \to x_0} g(x)\right]
\end{aligned}
\]</span></p>
<h3 id="函数极限存在的性质">函数极限存在的性质</h3>
<p>首先探讨一下函数极限何时存在？</p>
<p>『<em>Y</em>』代表在 <span class="math inline">\(x \to x_0\)</span> 时极限存在，『<em>N</em>』代表在 <span class="math inline">\(x \to x_0\)</span> 时极限不存在，则：</p>
<ul>
<li><span class="math inline">\(Y \pm ,\times Y = Y\)</span></li>
<li><span class="math inline">\(Y \pm N = N\)</span></li>
<li><span class="math inline">\(Y \times N = Y \; (0 \cdot \infty) \; \text{or} \; N\)</span></li>
<li><span class="math inline">\(N \pm , \times N = Y \; \text{or} \; N\)</span></li>
</ul>
<p>如果函数极限存在，则满足下列性质：</p>
<ul>
<li>极限是一个<strong>常数</strong>。使用场景：函数表达式中包含极限。</li>
<li>极限是唯一的，<strong>极限 = 左极限 = 右极限</strong>。</li>
<li><strong>局部有界性</strong>：存在某 <span class="math inline">\(\mathring{U}(x_0)\)</span> 内函数有界。</li>
<li><strong>局部保号性</strong>：
<ul>
<li>当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(f(x) \to A\)</span>，如果 <span class="math inline">\(A &gt; 0 \; (\text{or} \; A &lt; 0)\)</span>，则存在某 <span class="math inline">\(\mathring{U}(x_0)\)</span> 内 <span class="math inline">\(f(x) &gt; 0 \; (\text{or} \; f(x) &lt; 0)\)</span>。</li>
<li>反之，如果在某 <span class="math inline">\(\mathring{U}(x_0)\)</span> 内 <span class="math inline">\(f(x) \ge 0 \; (\text{or} \; f(x) \le 0)\)</span>，且当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(f(x) \to A\)</span>，则 <span class="math inline">\(A \ge 0 \; (\text{or} \; A \le 0)\)</span>。注意把符号换成 &gt; 或 &lt; 则不成立。</li>
</ul></li>
</ul>
<h3 id="无穷小">无穷小</h3>
<p>当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(f(x) \to 0\)</span>，称 <span class="math inline">\(f(x)\)</span> 为当 <span class="math inline">\(x \to x_0\)</span> 时的『无穷小』。</p>
<blockquote>
<p>当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(f(x) \to \infty\)</span>，称 <span class="math inline">\(f(x)\)</span> 为当 <span class="math inline">\(x \to x_0\)</span> 时的『无穷大』， <span class="math inline">\(\frac{1}{f(x)}\)</span> 为无穷小。<br />
当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(f(x)\)</span> 为无穷小且 <span class="math inline">\(f(x) \neq 0\)</span>，则 <span class="math inline">\(\frac{1}{f(x)}\)</span> 为无穷大。</p>
</blockquote>
<p><strong>无穷小的比阶：</strong></p>
<p><span class="math inline">\(x \to x_0 ,\; \alpha(x) \to 0, \; \beta(x) \to 0, \; \beta(x) \neq 0\)</span>，则当 <span class="math inline">\(x \to x_0\)</span> 时：</p>
<ul>
<li><span class="math inline">\(\lim \frac{\alpha(x)}{\beta(x)} = 0\)</span>，则 <span class="math inline">\(\alpha(x)\)</span> 是 <span class="math inline">\(\beta(x)\)</span> 的『<strong>高阶无穷小</strong>』，记作 <span class="math inline">\(\alpha(x) = o(\beta(x))\)</span>。</li>
<li><span class="math inline">\(\lim \frac{\alpha(x)}{\beta(x)} = \infty\)</span>，则 <span class="math inline">\(\alpha(x)\)</span> 是 <span class="math inline">\(\beta(x)\)</span> 的『低阶无穷小』。</li>
<li><span class="math inline">\(\lim \frac{\alpha(x)}{\beta(x)} = c \neq 0\)</span>，则二者是『同阶无穷小』，记作 <span class="math inline">\(\alpha(x) = O(\beta(x))\)</span>。</li>
<li><span class="math inline">\(\lim \frac{\alpha(x)}{\beta(x)} = 1\)</span>，则二者是『<strong>等价无穷小</strong>』，记作 <span class="math inline">\(\alpha(x) \sim \beta(x)\)</span>。</li>
<li><span class="math inline">\(\lim \frac{\alpha(x)}{[\beta(x)]^k} = c \neq 0\)</span>，<em>k</em> &gt; 0，则 <span class="math inline">\(\alpha(x)\)</span> 是 <span class="math inline">\(\beta(x)\)</span> 的『<em>k</em> 阶无穷小』。</li>
</ul>
<p><strong>无穷小的性质：</strong></p>
<ul>
<li>常数 0 可认为是最高阶的无穷小：<span class="math inline">\(\lim \frac{0}{\forall \alpha} = 0, \; \lim \frac{\forall \alpha}{0} = \infty\)</span>。</li>
<li>有界函数与无穷小的积仍是无穷小。</li>
<li>有限个无穷小的和、积仍是无穷小。</li>
<li>无穷小加减，只需保留最低阶：<span class="math inline">\(o(x^m) \pm o(x^n) = o(x^{\min(m,n)})\)</span>。</li>
<li>无穷小相乘，阶数相加：<span class="math inline">\(o(x^m) \cdot o(x^n) = o(x^{m+n})\)</span>。</li>
</ul>
<h3 id="函数的连续与间断">函数的连续与间断</h3>
<p><span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 某邻域内有定义，则 <span class="math inline">\(\lim_{x \to x_0} f(x) = f(x_0) \Leftrightarrow\)</span> <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处『<strong>连续</strong>』。</p>
<blockquote>
<p>若 <span class="math inline">\(\lim_{x \to x_0^+} f(x) = f(x_0) \Leftrightarrow\)</span> <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处『右连续』。<br />
若 <span class="math inline">\(\lim_{x \to x_0^-} f(x) = f(x_0) \Leftrightarrow\)</span> <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处『左连续』。</p>
</blockquote>
<p>函数在某处连续是一个非常严格的条件，不连续有三种情况：</p>
<ul>
<li>函数在某处<strong>无定义</strong>。</li>
<li>函数在某处<strong>极限不存在</strong>。</li>
<li>函数在某处极限存在，但<strong>极限值不等于函数值</strong>。</li>
</ul>
<p><span class="math inline">\(f(x)\)</span> 在 <em>x</em><sub>0</sub> 某去心邻域内有定义，如果 <span class="math inline">\(f(x)\)</span> 在点 <em>x</em><sub>0</sub> 处不连续，则点 <em>x</em><sub>0</sub> 为 <span class="math inline">\(f(x)\)</span> 的一个间断点。</p>
<ul>
<li>第一类间断点：
<ul>
<li><strong>可去间断点</strong>：<span class="math inline">\(\lim_{x \to x_0} f(x)= A \neq f(x_0) \; (\text{or} \; x_0 \notin D_f)\)</span>。</li>
<li><strong>跳跃间断点</strong>：<span class="math inline">\(\lim_{x \to x_0^-} f(x) = A, \;\lim_{x \to x_0^+} f(x) = B, \; A \neq B\)</span>。</li>
</ul></li>
<li>第二类间断点：
<ul>
<li><strong>无穷间断点</strong>：<span class="math inline">\(\lim_{x \to x_0} f(x) = \infty\)</span>。</li>
<li><strong>振荡间断点</strong>：<span class="math inline">\(\lim_{x \to x_0} f(x)\)</span> 振荡不存在，如 <span class="math inline">\(y = \sin \frac{1}{x}\)</span>。</li>
</ul></li>
</ul>
<p>函数连续的性质：</p>
<ul>
<li><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上<strong>有界</strong>。换个说法，<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上无界，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上不连续，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上存在不可导点。</li>
<li><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上连续，且 <span class="math inline">\(\lim_{x \to a^+}f(x)\)</span> 和 <span class="math inline">\(\lim_{x \to b^-}f(x)\)</span> 都存在，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((a,b)\)</span> 上有界。</li>
<li>基本初等函数在其定义域内连续，初等函数在其<strong>定义区间</strong>内连续。</li>
<li>根据上一条性质，在高等数学中，初等函数的间断点只可能位于<strong>未定义的点</strong>，分段函数的间断点只可能位于<strong>未定义的点</strong>和<strong>分段点</strong>。</li>
<li>连续函数相加减乘除（排除除数为 0 的点）后仍然连续，连续函数与不连续函数相加减乘除后必然不连续。</li>
<li>函数 <span class="math inline">\(u = g(x)\)</span> 在点 <em>x</em><sub>0</sub> 处连续且 <span class="math inline">\(g(x_0) = u_0\)</span>，<span class="math inline">\(f(u)\)</span> 在点 <em>u</em><sub>0</sub> 处连续，则 <span class="math inline">\(f[g(x)]\)</span> 在点 <em>x</em><sub>0</sub> 处也连续。</li>
</ul>
<h2 id="函数极限的计算">函数极限的计算</h2>
<h3 id="无法直接计算">无法直接计算</h3>
<h4 id="夹逼定理">夹逼定理</h4>
<p>若满足：</p>
<ol type="1">
<li><p><span class="math inline">\(\exists \delta &gt; 0\)</span>，当 <span class="math inline">\(x \in \mathring{U}(x_0,\delta)\)</span>，有 <span class="math inline">\(F(x) \leq f(x) \leq G(x)\)</span> 成立。</p></li>
<li><p>当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(\lim F(x) = \lim G(x) = A\)</span>。</p></li>
</ol>
<p>则当 <span class="math inline">\(x \to x_0\)</span> 时 <span class="math inline">\(\lim f(x) = A\)</span>。</p>
<h4 id="单调有界准则-1">单调有界准则</h4>
<p>由数列的单调有界定理延伸而出，当 <span class="math inline">\(x \to +\infty\)</span>，<span class="math inline">\(f(x)\)</span> 单调递增（或递减），且 <span class="math inline">\(f(x)\)</span> 有上界（或下界），则 <span class="math inline">\(\lim_{x \to +\infty} f(x)\)</span> 存在。</p>
<h3 id="可直接计算">可直接计算</h3>
<p><span class="math inline">\(\frac{0}{0}\;/\;\frac{\infty}{\infty}\;/\;0 \cdot \infty\;/\;\infty-\infty\;/\;1^\infty\;/\;0^0\;/\;\infty^0\)</span> 七种未定式的计算。</p>
<h4 id="化简">化简</h4>
<ul>
<li>查看是哪一种未定式形式：
<ul>
<li>若是 <span class="math inline">\(\frac{0}{0}\;/\;\frac{\infty}{\infty}\;/\;0 \cdot \infty\)</span>，则对分式进行化简，如『上下同除以最高次幂』，『根式代换』，『根式有理化』。</li>
<li>若是 <span class="math inline">\(\infty - \infty\)</span>，如果有分数可进行通分转化成分式，如果没有分数可以『提取公因数』，『进行倒代换』等方式转化成分式。</li>
<li>若是 <span class="math inline">\(\infty^0, \; 0^0\)</span>，则指对数转化 <span class="math inline">\(\lim \alpha^\beta = \exp(\lim \beta \ln \alpha)\)</span>。</li>
<li>若是 <span class="math inline">\(1^\infty\)</span>，则指对数转化 <span class="math inline">\(\lim \alpha^{\beta} = \exp(\lim\beta(\alpha-1))\)</span>。</li>
</ul>
<blockquote>
<p>如果式子中含有根式，且 <span class="math inline">\(x &lt; 0\)</span>，则最好使用 <span class="math inline">\(t = -x\)</span> 进行代换，以免计算错误。</p>
</blockquote></li>
<li>乘积形式可以直接使用等价无穷小替换：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{if} \; h \to 0 :\\
&amp;\sin h \sim h, \quad \tan h \sim h, \quad \arcsin h \sim h, \quad \arctan h \sim h, \quad 1-\cos h \sim \frac{1}{2}h^2\\
&amp;\ln(1+h) \sim h, \quad e^h-1 \sim h, \quad a^h-1 \sim h\ln a, \quad  (1+h)^\alpha-1 \sim \alpha h
\end{aligned}
\]</span></p>
<h4 id="洛必达法则">洛必达法则</h4>
<p>若 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 满足：</p>
<ol type="1">
<li><span class="math inline">\(x \to a\)</span>，<span class="math inline">\(\lim f(x)=0 \; (\text{or} \; \infty)\)</span>，<span class="math inline">\(\lim g(x)=0 \; (\text{or} \; \infty)\)</span></li>
<li><span class="math inline">\(x \in \mathring{U}(a)\)</span>，<span class="math inline">\(f’(x)\)</span> 和 <span class="math inline">\(g’(x)\)</span> 都存在，且 <span class="math inline">\(g’(x) \ne 0\)</span></li>
<li><span class="math inline">\(x \to a\)</span>，<span class="math inline">\(\lim \frac{f’(x)}{g’(x)}=A \; (A \in \mathbb{R} \; \text{or} \; A = \infty)\)</span></li>
</ol>
<p>则</p>
<p><span class="math display">\[
\lim_{x \to a}\frac{f(x)}{g(x)}=\lim_{x \to a}\frac{f’(x)}{g’(x)}=A
\]</span></p>
<p><strong>注意：</strong></p>
<ul>
<li>洛必达法则用于 <span class="math inline">\(\frac{0}{0},\;\frac{\infty}{\infty}\)</span> 这两种未定式的计算。其他五种可以转化成这两种形式，然后使用洛必达法则。</li>
<li>公式中等号右侧极限存在，左侧极限必存在。但左侧极限存在，右侧极限未必存在，即使用洛必达法则求极限可能失效。</li>
</ul>
<h4 id="泰勒公式">泰勒公式</h4>
<p>常用泰勒（麦克劳林）公式：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;(1)\;  \mathrm{e}^{x}=1+x+\frac{1}{2 !} x^{2}+\cdots+\frac{1}{n !} x^{n}+o\left(x^{n}\right) \\
&amp;(2)\;  \sin x=x-\frac{x^{3}}{3 !}+\cdots+(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !}+o\left(x^{2 n+1}\right) \\
&amp;(3)\;  \cos x=1-\frac{x^{2}}{2 !}+\frac{x^{4}}{4 !}-\cdots+(-1)^{n} \frac{x^{2 n}}{(2 n) !}+o\left(x^{2 n}\right) \\
&amp;(4)\;  \frac{1}{1-x}=1+x+x^{2}+\cdots+x^{n}+o\left(x^{n}\right) \\
&amp;(5)\;  \frac{1}{1+x}=1-x+x^{2}-\cdots+(-1)^{n} x^{n}+o\left(x^{n}\right) \\
&amp;(6)\;  \ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\cdots+(-1)^{n-1} \frac{x^{n}}{n}+o\left(x^{n}\right) \\
&amp;(7)\;  (1+x)^{\alpha}=1+\alpha x+\frac{\alpha(\alpha-1)}{2 !} x^{2}+\cdots+\frac{\alpha(\alpha-1) \cdots(\alpha-n+1)}{n !} x^{n}+o\left(x^{n}\right) 
\end{aligned}
\]</span></p>
<p><strong>展开原则：</strong></p>
<ul>
<li><span class="math inline">\(\frac{A}{B}\)</span>『上下同阶』：即分母和分子展开到相同次幂，或者分子至少展开到分母的次幂。</li>
<li><span class="math inline">\(A - B\)</span>『幂次最低』：将 <em>A</em>、<em>B</em> 展开到系数不相等。</li>
</ul>
<h2 id="应试技巧">应试技巧</h2>
<ul>
<li><span class="math inline">\(x \to x_0, \; f(x) \to 0, \; g(x) \to 0 \Rightarrow e^{f(x)}-e^{g(x)} \sim f(x) - g(x)\)</span></li>
<li>闭区间内的单调函数必有界。</li>
<li><span class="math inline">\(x \to 0^+, \; x^x \to 1\)</span></li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Calulus</tag>
      </tags>
  </entry>
  <entry>
    <title>相似理论</title>
    <url>/2022/09/23/%E7%9B%B8%E4%BC%BC%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>线性代数-相似理论的概念与计算。</p>
<span id="more"></span>
<hr />
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#特征值和特征向量">特征值和特征向量</a></li>
<li><a href="#矩阵的相似">矩阵的相似</a></li>
<li><a href="#相似对角化">相似对角化</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<ol type="1">
<li><strong><em>A</em></strong> 是 <em>n</em> 阶矩阵，<span class="math inline">\(\lambda\)</span> 是一个数，若存在 <em>n</em> 维非零列向量 <span class="math inline">\(\boldsymbol{\xi}\)</span>，使得</li>
</ol>
<p><span class="math display">\[
\boldsymbol{A}\boldsymbol{\xi} = \lambda \boldsymbol{\xi}
\]</span></p>
<p>则 <span class="math inline">\(\lambda\)</span> 是 <strong><em>A</em></strong> 的『<strong>特征值</strong>』，<span class="math inline">\(\boldsymbol{\xi}\)</span> 是 <strong><em>A</em></strong> 的对应于特征值 <span class="math inline">\(\lambda\)</span> 的『<strong>特征向量</strong>』。</p>
<ol start="2" type="1">
<li>求特征值</li>
</ol>
<p><span class="math inline">\(\boldsymbol{A}\boldsymbol{\xi} = \lambda \boldsymbol{\xi} \Rightarrow (\lambda \boldsymbol{E} - \boldsymbol{A})\boldsymbol{\xi} = \boldsymbol{0}\)</span>，又因为 <span class="math inline">\(\boldsymbol{\xi} \neq 0\)</span>，即方程组 <span class="math inline">\((\lambda \boldsymbol{E} -\boldsymbol{A})x = 0\)</span> 有非零解，故</p>
<p><span class="math display">\[
|\lambda \boldsymbol{E} -\boldsymbol{A}| = \left|
\begin{matrix}
\lambda - a_{11} &amp;-a_{12} &amp;\cdots &amp;-a_{1n} \\
-a_{21} &amp;\lambda - a_{22} &amp;\cdots &amp;-a_{2n} \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
-a_{n1} &amp;-a_{n2} &amp;\cdots &amp;\lambda - a_{nn}
\end{matrix}
\right| = 0
\]</span></p>
<p>该式称为 <strong><em>A</em></strong> 的『特征方程』，是未知量 <span class="math inline">\(\lambda\)</span> 的 <em>n</em> 次方程，有 <em>n</em> 个根（按重数计）<span class="math inline">\(\lambda_i \;(i = 1,2,\ldots,n)\)</span>。</p>
<ol start="3" type="1">
<li>求特征向量</li>
</ol>
<p>将求出的特征值 <span class="math inline">\(\lambda_i\)</span> 代回 <span class="math inline">\((\lambda \boldsymbol{E} - \boldsymbol{A})\boldsymbol{x} = \boldsymbol{0}\)</span>，方程组的解向量即为 <strong><em>A</em></strong> 的对应于特征值 <span class="math inline">\(\lambda_i\)</span> 的特征向量。</p>
<p>特征值 <span class="math inline">\(\lambda_i\)</span> 对应的特征向量张成的向量空间，即 <span class="math inline">\(\lambda_i\boldsymbol{E} - \boldsymbol{A}\)</span> 的零空间，称为 <strong><em>A</em></strong> 的属于特征值 <span class="math inline">\(\lambda_i\)</span> 的『特征子空间』。</p>
<ol start="4" type="1">
<li>重要结论</li>
</ol>
<ul>
<li><em>n</em> 阶矩阵一定有 <em>n</em> 个特征值（按重数计）。</li>
<li>若 <span class="math inline">\(\lambda_i \;(i = 1,2,\ldots,n)\)</span> 是 <strong><em>A</em></strong> 的特征值，则 <span class="math inline">\(\text{det}(\boldsymbol{A})= \lambda_1\lambda_2\cdots\lambda_n, \; \text{tr}(\boldsymbol{A}) = \lambda_1 + \lambda_2 +\cdots+\lambda_n\)</span>。</li>
<li>根据上一条结论，<strong>方阵 <em>A</em> 可逆 <span class="math inline">\(\Leftrightarrow 0\)</span> 不是 <em>A</em> 的特征值</strong>。</li>
<li>上（下）三角矩阵、对角矩阵的特征值就是主对角线元素。</li>
<li><p><strong>下表要谨记：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>矩阵</th>
<th><span class="math inline">\(\boldsymbol{A}\)</span></th>
<th><span class="math inline">\(k\boldsymbol{A}\)</span></th>
<th><span class="math inline">\(\boldsymbol{A}^k\)</span></th>
<th><span class="math inline">\(f(\boldsymbol{A})\)</span></th>
<th><span class="math inline">\(\boldsymbol{A}^{\text{T}}\)</span></th>
<th><span class="math inline">\(\boldsymbol{A}^{-1}\)</span></th>
<th><span class="math inline">\(\boldsymbol{A}^*\)</span></th>
<th><span class="math inline">\(\boldsymbol{P}^{-1}\boldsymbol{A}\boldsymbol{P}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>特征值</td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(k\lambda\)</span></td>
<td><span class="math inline">\(\lambda^k\)</span></td>
<td><span class="math inline">\(f(\lambda)\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\frac{1}{\lambda}\)</span></td>
<td><span class="math inline">\(\frac{\text{det}(\boldsymbol{A})}{\lambda}\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
</tr>
<tr class="even">
<td>对应特征值的特征向量</td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td>未知</td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td><span class="math inline">\(\boldsymbol{\xi}\)</span></td>
<td><span class="math inline">\(\boldsymbol{P}^{-1}\boldsymbol{\xi}\)</span></td>
</tr>
</tbody>
</table>
<p>推论：若 <span class="math inline">\(f(\boldsymbol{A}) = \boldsymbol{O}, \; \lambda\)</span> 是 <strong><em>A</em></strong> 任意特征值，则 <span class="math inline">\(f(\lambda)=0\)</span>。</p>
<p>注意：<span class="math inline">\(\boldsymbol{A}^{\text{T}}\)</span> 特征值不变，但特征向量需要重新计算得出。</p></li>
<li><p>代数重数 <span class="math inline">\(\geq\)</span> 几何重数：<em>k</em> 重特征值<strong>最多</strong>有 <em>k</em> 个线性无关的特征向量。</p></li>
<li><p>不同特征值对应的特征向量必线性无关。</p></li>
<li>根据解空间理论，同一特征值对应的特征向量的非零线性组合仍是该特征值对应的特征向量。</li>
<li><p><span class="math inline">\(\boldsymbol{\xi}_1,\boldsymbol{\xi}_2\)</span> 是不同特征值对应的特征向量，则 <span class="math inline">\(k_1\boldsymbol{\xi}_1 + k_2\boldsymbol{\xi}_2\; (k_1 \neq 0,k_2 \neq 0)\)</span> 不是 <strong><em>A</em></strong> 的特征向量。</p></li>
</ul>
<h3 id="矩阵的相似">矩阵的相似</h3>
<p><strong><em>A</em></strong> 和 <strong><em>B</em></strong> 是两个同阶方阵，若存在可逆矩阵 <strong><em>P</em></strong>，使得 <span class="math inline">\(\boldsymbol{P}^{-1}\boldsymbol{A}\boldsymbol{P} = \boldsymbol{B}\)</span>，则称 <strong><em>A</em></strong> 『<strong>相似</strong>』于 <strong><em>B</em></strong>，记作 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B}\)</span>。</p>
<p>若 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B}\)</span>，则：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{A} \cong \boldsymbol{B}\)</span></li>
<li><span class="math inline">\(r(\boldsymbol{A}) = r(\boldsymbol{B})\)</span></li>
<li><span class="math inline">\(\lambda_{\boldsymbol{A}} = \lambda_{\boldsymbol{B}}\)</span></li>
<li><span class="math inline">\(\text{det}(\boldsymbol{A}) = \text{det}(\boldsymbol{B})\)</span></li>
<li><span class="math inline">\(\text{tr}(\boldsymbol{A}) = \text{tr}(\boldsymbol{B})\)</span></li>
</ul>
<blockquote>
<p>这是 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B}\)</span> 的基本必要条件，任何一个不成立则 <span class="math inline">\(\boldsymbol{A} \not\sim \boldsymbol{B}\)</span>。</p>
</blockquote>
<p>重要结论：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B} \Rightarrow \boldsymbol{A}^{\text{T}} \sim \boldsymbol{B}^{\text{T}},\boldsymbol{A}^{-1} \sim \boldsymbol{B}^{-1},\boldsymbol{A}^* \sim \boldsymbol{B}^*\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B} \Rightarrow k\boldsymbol{A} \sim k\boldsymbol{B},\boldsymbol{A}^k \sim \boldsymbol{B}^k,f(\boldsymbol{A}) \sim f(\boldsymbol{B})\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B} \Leftrightarrow \boldsymbol{B} \sim \boldsymbol{A}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B},\boldsymbol{B} \sim \boldsymbol{C} \Rightarrow \boldsymbol{A} \sim \boldsymbol{C}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B},\boldsymbol{B} \sim \boldsymbol{\Lambda} \Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{\Lambda},\boldsymbol{B} \sim \boldsymbol{\Lambda} \Rightarrow \boldsymbol{A} \sim \boldsymbol{B}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{C},\boldsymbol{B} \sim \boldsymbol{D} \Rightarrow \left[\begin{matrix} \boldsymbol{A} &amp;\boldsymbol{O}\\ \boldsymbol{O} &amp;\boldsymbol{B} \end{matrix}\right] \sim \left[\begin{matrix} \boldsymbol{C} &amp;\boldsymbol{O}\\ \boldsymbol{O} &amp;\boldsymbol{D} \end{matrix}\right]\)</span></li>
</ul>
<h3 id="相似对角化">相似对角化</h3>
<p>对角矩阵的良好性质，对角矩阵 <span class="math inline">\(\boldsymbol{\Lambda} = \text{diag}[ \lambda_1,\lambda_2,\ldots,\lambda_n]\)</span>：</p>
<ul>
<li><span class="math inline">\(\text{det}(\boldsymbol{\Lambda}) = \lambda_1\lambda_2\cdots\lambda_n\)</span></li>
<li><span class="math inline">\(\boldsymbol{\Lambda}^{\text{T}} = \boldsymbol{\Lambda}\)</span></li>
<li><span class="math inline">\(\boldsymbol{\Lambda}^{-1} = \text{diag}\left[\frac{1}{\lambda_1},\frac{1}{\lambda_2},\ldots,\frac{1}{\lambda_n}\right]\)</span></li>
<li><span class="math inline">\(\boldsymbol{\Lambda}^k = \text{diag}\left[{\lambda_1}^k,{\lambda_2}^k,\ldots,{\lambda_n}^k\right]\)</span></li>
</ul>
<p>若 <span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>，则称 <strong><em>A</em></strong> 可以『<strong>相似对角化</strong>』，称 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的『相似标准形』。</p>
<ol type="1">
<li>相似对角化的推导</li>
</ol>
<p><span class="math inline">\(\boldsymbol{P}^{-1}\boldsymbol{AP} = \boldsymbol{\Lambda} \Rightarrow \boldsymbol{AP} = \boldsymbol{P\Lambda}\)</span>，令 <span class="math inline">\(\boldsymbol{P} = [\boldsymbol{\xi}_1,\boldsymbol{\xi}_2,\ldots,\boldsymbol{\xi}_n],\; \boldsymbol{\Lambda} = \text{diag}[\lambda_1,\lambda_2,\ldots,\lambda_n]\)</span>，则</p>
<p><span class="math display">\[
\boldsymbol{A}[\boldsymbol{\xi}_1,\boldsymbol{\xi}_2,\ldots,\boldsymbol{\xi}_n] = [\boldsymbol{\xi}_1,\boldsymbol{\xi}_2,\ldots,\boldsymbol{\xi}_n] \begin{bmatrix} \lambda_1 &amp;\; &amp;\; &amp;\; \\ \; &amp;\lambda_2 &amp;\; &amp;\; \\ \; &amp;\; &amp;\ddots &amp;\; \\ \; &amp;\; &amp;\; &amp;\lambda_n\end{bmatrix}
\]</span></p>
<p>即</p>
<p><span class="math display">\[
[\boldsymbol{A\xi}_1,\boldsymbol{A\xi}_2,\ldots,\boldsymbol{A\xi}_n] =[\lambda_1\boldsymbol{\xi}_1,\lambda_2\boldsymbol{\xi}_2,\ldots,\lambda_n\boldsymbol{\xi}_n]
\]</span></p>
<p>故</p>
<p><span class="math display">\[
\boldsymbol{A\xi}_i = \lambda_i\boldsymbol{\xi}_i \;(i =1,2,\ldots,n)
\]</span></p>
<p>因为 <strong><em>P</em></strong> 可逆，故 <span class="math inline">\(\boldsymbol{\xi}_1,\boldsymbol{\xi}_2,\ldots,\boldsymbol{\xi}_n\)</span> 线性无关，故得出结论：</p>
<ul>
<li><em>n</em> 阶矩阵 <strong><em>A</em></strong> 可相似对角化 <span class="math inline">\(\Leftrightarrow\)</span> <strong><em>A</em> 有 <em>n</em> 个线性无关的特征向量。</strong></li>
<li><span class="math inline">\(\boldsymbol{\Lambda}\)</span> 是 <strong><em>A</em></strong> 的 <em>n</em> 个（按重数计）特征值构成的对角矩阵，<strong><em>P</em></strong> 的列向量是 <strong><em>A</em></strong> 的特征向量，且 <strong><em>P</em></strong> 中特征向量的位置与 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 中特征值的位置相对应。</li>
</ul>
<ol start="2" type="1">
<li>重要结论：</li>
</ol>
<p><em>n</em> 阶矩阵 <strong><em>A</em></strong> 可相似对角化的<strong>充分必要条件：</strong></p>
<ul>
<li><strong><em>A</em></strong> 有 <em>n</em> 个线性无关的特征向量 <span class="math inline">\(\Leftrightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>。</li>
<li>几何重数等于代数重数，即 <em>k</em> 重特征值具有 <em>k</em> 个线性无关的特征向量 <span class="math inline">\(\Leftrightarrow n_i = n - r(\lambda_i\boldsymbol{E}-\boldsymbol{A}) \Leftrightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>。</li>
</ul>
<p><em>n</em> 阶矩阵 <strong><em>A</em></strong> 可相似对角化的<strong>充分条件：</strong></p>
<ul>
<li><strong><em>A</em></strong> 是『<strong>实对称矩阵</strong>』 <span class="math inline">\(\Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>。</li>
<li><strong><em>A</em></strong> 有 <em>n</em> 个不同的特征值 <span class="math inline">\(\Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>。</li>
<li><span class="math inline">\(\boldsymbol{A}^2 = \boldsymbol{A} \Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A}^2 = \boldsymbol{E} \Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span></li>
<li><span class="math inline">\(r(\boldsymbol{A})=1\)</span> 且 <span class="math inline">\(\text{tr}(\boldsymbol{A}) \neq 0 \Rightarrow \boldsymbol{A} \sim \boldsymbol{\Lambda}\)</span>。</li>
</ul>
<p><em>n</em> 阶矩阵 <strong><em>A</em></strong> 可相似对角化的<strong>必要条件：</strong></p>
<ul>
<li><strong><span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{\Lambda} \Rightarrow r(\boldsymbol{A}) =\)</span> 非零特征值的个数（按重数计），则零特征值的重数为 <span class="math inline">\(n - r(\boldsymbol{A})\)</span>。</strong></li>
<li><span class="math inline">\(\lambda_{\boldsymbol{A}} = \lambda_{\boldsymbol{B}} \not\Rightarrow \boldsymbol{A} \sim \boldsymbol{B}\)</span>，但如果 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 均可相似对角化，则 <span class="math inline">\(\lambda_{\boldsymbol{A}} = \lambda_{\boldsymbol{B}} \Rightarrow \boldsymbol{A} \sim \boldsymbol{B}\)</span>。</li>
<li>根据上一条结论，『<strong>实对称矩阵</strong>』 <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 相似 <span class="math inline">\(\Leftrightarrow \lambda_{\boldsymbol{A}} = \lambda_{\boldsymbol{B}}\)</span>。</li>
</ul>
<p>矩阵 <strong><em>A</em></strong> <strong>不可</strong>相似对角化的<strong>充分条件：</strong></p>
<ul>
<li><span class="math inline">\(\boldsymbol{A} \neq \boldsymbol{O},\boldsymbol{A}^k = \boldsymbol{O}\;(k \in \mathbb{N}_+,k &gt; 1) \Rightarrow \boldsymbol{A} \not\sim \boldsymbol{\Lambda}\)</span></li>
<li><strong><em>A</em></strong> 的特征值全为 <em>k</em>，但 <span class="math inline">\(\boldsymbol{A} \neq k\boldsymbol{E} \Rightarrow \boldsymbol{A} \not\sim \boldsymbol{\Lambda}\)</span>。</li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵理论</title>
    <url>/2022/09/20/%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>线性代数-矩阵理论的概念与计算。</p>
<span id="more"></span>
<hr />
<p><strong>本文索引</strong></p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#概念">概念</a>
<ul>
<li><a href="#矩阵运算法则">矩阵运算法则</a></li>
<li><a href="#矩阵的转置">矩阵的转置</a></li>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#逆矩阵">逆矩阵</a></li>
<li><a href="#伴随矩阵">伴随矩阵</a></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
<li><a href="#矩阵的秩">矩阵的秩</a></li>
<li><a href="#矩阵的等价和等价标准形">矩阵的等价和等价标准形</a></li>
</ul></li>
<li><a href="#计算">计算</a>
<ul>
<li><a href="#求矩阵的幂">求矩阵的幂</a></li>
<li><a href="#求逆矩阵">求逆矩阵</a></li>
<li><a href="#矩阵方程">矩阵方程</a></li>
</ul></li>
</ul>
<!-- /code_chunk_output -->
<hr />
<h2 id="概念">概念</h2>
<h3 id="矩阵运算法则">矩阵运算法则</h3>
<ul>
<li>矩阵加法：若 <span class="math inline">\(\boldsymbol{A},\boldsymbol{B}\)</span> 都是 <span class="math inline">\(m \times n\)</span> 矩阵，则</li>
</ul>
<p><span class="math display">\[
\boldsymbol{A} + \boldsymbol{B} = \left[\begin{matrix}
a_{11}+b_{11} &amp;a_{12}+b_{12} &amp;\cdots &amp;a_{1n}+b_{1n} \\
a_{21}+b_{21} &amp;a_{22}+b_{22} &amp;\cdots &amp;a_{2n}+b_{2n} \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
a_{m1}+b_{m1} &amp;a_{m2}+b_{m2} &amp;\cdots &amp;a_{mn}+b_{mn}
\end{matrix}
\right]
\]</span></p>
<ul>
<li>数乘：</li>
</ul>
<p><span class="math display">\[
k\boldsymbol{A} = \left[\begin{matrix}
ka_{11} &amp;ka_{12} &amp;\cdots &amp;ka_{1n}\\
ka_{21} &amp;ka_{22} &amp;\cdots &amp;ka_{2n}\\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
ka_{m1} &amp;ka_{m2} &amp;\cdots &amp;ka_{mn}
\end{matrix}
\right]
\]</span></p>
<ul>
<li>矩阵乘法：若 <strong><em>A</em></strong> 是 <span class="math inline">\(m \times n\)</span> 矩阵，<strong><em>B</em></strong> 是 <span class="math inline">\(n \times s\)</span> 矩阵，则</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s} &amp;= \left[\begin{matrix}
a_{11} &amp;a_{12} &amp;\cdots &amp;a_{1n}\\
a_{21} &amp;a_{22} &amp;\cdots &amp;a_{2n}\\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
a_{m1} &amp;a_{m2} &amp;\cdots &amp;a_{mn}
\end{matrix}
\right]
\left[\begin{matrix}
b_{11} &amp;b_{12} &amp;\cdots &amp;b_{1s}\\
b_{21} &amp;b_{22} &amp;\cdots &amp;b_{2s}\\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
b_{n1} &amp;b_{n2} &amp;\cdots &amp;b_{ns}
\end{matrix}
\right] =\left[\begin{matrix}
c_{11} &amp;c_{12} &amp;\cdots &amp;c_{1s}\\
c_{21} &amp;c_{22} &amp;\cdots &amp;c_{2s}\\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
c_{m1} &amp;c_{m2} &amp;\cdots &amp;c_{ms}
\end{matrix}
\right] \\ c_{ij} &amp;= a_{i1}b_{1j} + a_{i2}b_{2j} +...+a_{in}b_{nj} =\sum_{k=1}^n a_{ik}b_{kj}\;(i = 1,2,...,m, \; j = 1,2,...,s)
\end{aligned}
\]</span></p>
<p>矩阵运算满足以下规律：</p>
<ul>
<li>加法交换律：<span class="math inline">\(\boldsymbol{A}+\boldsymbol{B} = \boldsymbol{B}+\boldsymbol{A}\)</span>。</li>
<li>加法结合律：<span class="math inline">\((\boldsymbol{A}+\boldsymbol{B})+\boldsymbol{C} = \boldsymbol{A}+(\boldsymbol{B}+\boldsymbol{C})\)</span>。</li>
<li>加法单位元：<span class="math inline">\(\boldsymbol{A}+\boldsymbol{O} = \boldsymbol{A}\)</span>。</li>
<li>加法逆元：<span class="math inline">\(\boldsymbol{A}+(-\boldsymbol{A}) = \boldsymbol{O}\)</span>。</li>
<li>数乘交换律：<span class="math inline">\(k\boldsymbol{A} = \boldsymbol{A}k\)</span>。</li>
<li>数乘与加法分配律：<span class="math inline">\((k+l)\boldsymbol{A} = k\boldsymbol{A} + l\boldsymbol{A}, \; k(\boldsymbol{A}+\boldsymbol{B}) =k\boldsymbol{A} + k\boldsymbol{B}\)</span>。</li>
<li>乘法结合律：<span class="math inline">\(\boldsymbol{A}\boldsymbol{B}\boldsymbol{C} = (\boldsymbol{A}\boldsymbol{B})\boldsymbol{C} = \boldsymbol{A}(\boldsymbol{B}\boldsymbol{C})\)</span>。</li>
<li>乘法与加法分配律：<span class="math inline">\(\boldsymbol{A}(\boldsymbol{B}+\boldsymbol{C}) = \boldsymbol{A}\boldsymbol{B} +\boldsymbol{A}\boldsymbol{C}, \;(\boldsymbol{A}+\boldsymbol{B})\boldsymbol{C} = \boldsymbol{A}\boldsymbol{C} +\boldsymbol{B}\boldsymbol{C}\)</span>。</li>
<li>乘法单位元：<span class="math inline">\(\boldsymbol{A}\boldsymbol{E} = \boldsymbol{E}\boldsymbol{A} = \boldsymbol{A}\)</span>。</li>
<li>乘法逆元：<span class="math inline">\(\boldsymbol{A}\boldsymbol{A}^{-1} = \boldsymbol{A}^{-1}\boldsymbol{A} = \boldsymbol{E}\)</span>。</li>
</ul>
<p>矩阵运算不满足的运算规律：</p>
<ul>
<li><p>矩阵乘法不满足交换律，除非以下的特殊情形：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{A}\boldsymbol{E} = \boldsymbol{E}\boldsymbol{A}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A},\boldsymbol{B} \in \mathbb{R}^{n \times n},\; \boldsymbol{A}\boldsymbol{B} = \boldsymbol{E} \Leftrightarrow \boldsymbol{B}\boldsymbol{A} =\boldsymbol{E}\)</span></li>
<li><span class="math inline">\(\boldsymbol{A}\boldsymbol{A}^* = \boldsymbol{A}^*\boldsymbol{A}\)</span></li>
</ul></li>
<li>矩阵乘法不满足左右消去律：<span class="math inline">\(\boldsymbol{AB} = \boldsymbol{AC} \; \text{or} \; \boldsymbol{BA} = \boldsymbol{CA}\not\Rightarrow \boldsymbol{B} = \boldsymbol{C}\)</span>，除非 <strong><em>A</em></strong> 可逆。</li>
<li><p><span class="math inline">\(\boldsymbol{AB} = \boldsymbol{O} \not\Rightarrow \boldsymbol{A} = \boldsymbol{O} \; \text{or}\; \boldsymbol{B} = \boldsymbol{O}\)</span></p></li>
</ul>
<h3 id="矩阵的转置">矩阵的转置</h3>
<p>若矩阵 <span class="math inline">\(\boldsymbol{A} = [a_{ij}]_{m \times n}\)</span>，则 <span class="math inline">\(\boldsymbol{A}\)</span> 的转置为 <span class="math inline">\(\boldsymbol{A}^{\text{T}} = [a_{ji}]_{n \times m}\)</span>，也就是 <span class="math inline">\(\boldsymbol{A}\)</span> 的第 <em>i</em> 行等于 <span class="math inline">\(\boldsymbol{A}^{\text{T}}\)</span> 的第 <em>i</em> 列，<span class="math inline">\(\boldsymbol{A}\)</span> 的第 <em>j</em> 列等于 <span class="math inline">\(\boldsymbol{A}^{\text{T}}\)</span> 的第 <em>j</em> 行。</p>
<p>矩阵的转置满足以下运算规律：</p>
<ul>
<li><span class="math inline">\({\left(\boldsymbol{A}^{\text{T}}\right)}^{\text{T}} =\boldsymbol{A}\)</span></li>
<li><span class="math inline">\((\boldsymbol{A}+\boldsymbol{B})^{\text{T}} = \boldsymbol{A}^{\text{T}} + \boldsymbol{B}^{\text{T}}\)</span></li>
<li><span class="math inline">\((k\boldsymbol{A})^{\text{T}} = k\boldsymbol{A}^{\text{T}}\)</span></li>
<li><span class="math inline">\((\boldsymbol{A}\boldsymbol{B})^{\text{T}} = \boldsymbol{B}^{\text{T}}\boldsymbol{A}^{\text{T}}\)</span>（<strong>穿脱原则</strong>）</li>
<li><span class="math inline">\(\text{det}\left(\boldsymbol{A}^{\text{T}}\right) =\text{det}(\boldsymbol{A})\)</span></li>
</ul>
<h3 id="初等矩阵">初等矩阵</h3>
<p>矩阵有三种初等变换：</p>
<ol type="1">
<li>倍乘：一个非零常数乘矩阵的某一行（或列）。</li>
<li>互换：互换矩阵某两行（或列）的位置。</li>
<li>倍加：将矩阵的某一行（或列）的常数倍加到另一行（或列）。</li>
</ol>
<p>这三种初等变换对应三种初等矩阵：</p>
<ol type="1">
<li><span class="math inline">\(\boldsymbol{E}_i(k)\;(k \neq 0)\)</span> 表示将单位矩阵 <strong><em>E</em></strong> 的第 <em>i</em> 行（或列）乘 <em>k</em> 所得的初等矩阵。</li>
</ol>
<p><span class="math display">\[
\text{e.g.} \; \boldsymbol{E}_2(k) = \left[\begin{matrix}
1 &amp;0 &amp;0 \\
0 &amp;k &amp;0 \\
0 &amp;0 &amp;1
\end{matrix}
\right]
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(\boldsymbol{E}_{ij}\)</span> 表示将单位矩阵 <strong><em>E</em></strong> 第 <em>i</em> 行（或列）和第 <em>j</em> 行（或列）交换所得的初等矩阵。</li>
</ol>
<p><span class="math display">\[
\text{e.g.} \; \boldsymbol{E}_{12} = \left[\begin{matrix}
0 &amp;1 &amp;0 \\
1 &amp;0 &amp;0 \\
0 &amp;0 &amp;1
\end{matrix}
\right]
\]</span></p>
<ol start="3" type="1">
<li><span class="math inline">\(\boldsymbol{E}_{ij}(k)\)</span> 表示将单位矩阵 <strong><em>E</em></strong> 的第 <em>j</em> 行的 <em>k</em> 倍加到第 <em>i</em> 行（或第 <em>i</em> 列的 <em>k</em> 倍加到第 <em>j</em> 列）所得的初等矩阵。</li>
</ol>
<p><span class="math display">\[
\text{e.g.} \; \boldsymbol{E}_{12}(k) = \left[\begin{matrix}
1 &amp;k &amp;0 \\
0 &amp;1 &amp;0 \\
0 &amp;0 &amp;1
\end{matrix}
\right]
\]</span></p>
<p>初等变换的重要结论：</p>
<ul>
<li>初等矩阵一定<a href="#逆矩阵">可逆</a>，故使用 <strong><em>P</em></strong> 来表示初等矩阵。</li>
<li>左行右列定理：矩阵<strong><em>A</em></strong> <strong>左乘</strong>初等矩阵 <strong><em>P</em></strong> 即 <strong><em>PA</em></strong> 相当于对 <strong><em>A</em></strong> 做一次与 <strong><em>P</em></strong> 相同的<strong>初等行变换</strong>，矩阵<strong><em>A</em></strong> <strong>右乘</strong>初等矩阵 <strong><em>P</em></strong> 即 <strong><em>AP</em></strong> 相当于对 <strong><em>A</em></strong> 做一次与 <strong><em>P</em></strong> 相同的<strong>初等列变换</strong>。</li>
<li>对系数矩阵做初等行变换不改变齐次线性方程组的解，对增广矩阵做初等行变换不改变非齐次线性方程组的解。</li>
<li>初等行变换不改变矩阵列向量组的线性相关性。</li>
</ul>
<p>初等矩阵的转置、逆和幂运算：</p>
<p><span class="math display">\[
\begin{array}{ll}
[\boldsymbol{E}_i(k)]^{\text{T}} =\boldsymbol{E}_i(k) &amp;[\boldsymbol{E}_i(k)]^{-1} =\boldsymbol{E}_i(\frac{1}{k}), &amp;[\boldsymbol{E}_i(k)]^n = \boldsymbol{E}_i(nk)\\
{\boldsymbol{E}_{ij}}^{\text{T}} = \boldsymbol{E}_{ij}, &amp;{\boldsymbol{E}_{ij}}^{-1} = \boldsymbol{E}_{ij},&amp; {\boldsymbol{E}_{ij}}^n = \left\{ \begin{array}{ll} \boldsymbol{E}, &amp;n = 2k \\ \boldsymbol{E}_{ij}, &amp;n = 2k+1 \end{array} \right.\\
[\boldsymbol{E}_{ij}(k)]^{\text{T}} =\boldsymbol{E}_{ji}(k) &amp;[\boldsymbol{E}_{ij}(k)]^{-1} =\boldsymbol{E}_{ij}(-k), &amp;[\boldsymbol{E}_{ij}(k)]^n = \boldsymbol{E}_{ij}(nk)
\end{array}
\]</span></p>
<h3 id="逆矩阵">逆矩阵</h3>
<p><span class="math inline">\(\boldsymbol{A},\boldsymbol{B} \in \mathbb{R}^{n \times n}, \; \boldsymbol{AB} = \boldsymbol{E} \Leftrightarrow \boldsymbol{BA} = \boldsymbol{E} \Leftrightarrow \boldsymbol{AB} = \boldsymbol{BA} = \boldsymbol{E} \Leftrightarrow\)</span> <strong><em>A</em></strong> 和 <strong><em>B</em></strong> 互为逆矩阵『<strong>逆矩阵</strong>』，记作 <span class="math inline">\(\boldsymbol{B} = \boldsymbol{A}^{-1},\;\boldsymbol{A} = \boldsymbol{B^{-1}}\)</span>。</p>
<p>逆矩阵满足以下运算规律：</p>
<ul>
<li><span class="math inline">\({\left(\boldsymbol{A}^{-1}\right)}^{-1} = \boldsymbol{A}\)</span></li>
<li><span class="math inline">\({(k\boldsymbol{A})}^{-1} = \frac{1}{k}\boldsymbol{A}^{-1} \;(k \neq 0)\)</span></li>
<li><span class="math inline">\({(\boldsymbol{AB})}^{-1} =\boldsymbol{B}^{-1} \boldsymbol{A}^{-1}\)</span>（<strong>穿脱原则</strong>）</li>
<li><span class="math inline">\(\text{det}\left(\boldsymbol{A}^{-1}\right) = \frac{1}{\text{det}(\boldsymbol{A})}\)</span></li>
</ul>
<p><span class="math inline">\(\boldsymbol{A}_{n \times n}\)</span> 可逆 <span class="math inline">\(\Leftrightarrow r(\boldsymbol{A}_{n \times n}) = n\Leftrightarrow \boldsymbol{A}_{n \times n} \cong \boldsymbol{E}_{n} \Leftrightarrow \text{det}(\boldsymbol{A}) \neq 0\)</span>。</p>
<p><strong><a href="#矩阵的秩">满秩</a>是可逆的充分必要条件，故可逆矩阵<a href="#矩阵的等价和等价标准形">等价</a>于同阶单位矩阵</strong>，即可逆矩阵可以由同阶单位矩阵通过有限次初等变换得到，因为矩阵乘单位矩阵满足交换律，故</p>
<p><span class="math display">\[
\boldsymbol{P} =\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{E}\cdots\boldsymbol{P}_k = \boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k\boldsymbol{E} = \boldsymbol{E}\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k =\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k
\]</span></p>
<p>根据上述可知：</p>
<ul>
<li>可逆矩阵可由同阶单位矩阵通过<strong>有限次初等行变换或有限次初等列变换</strong>得到。</li>
<li><strong>可逆矩阵等价于有限个初等矩阵的乘积。左乘可逆矩阵等价于做有限次初等行变换，右乘可逆矩阵等价于做有限次初等列变换。</strong></li>
<li>可逆矩阵等价于有限个初等矩阵的乘积，故<strong>可逆矩阵乘可逆矩阵仍然是可逆矩阵</strong>。</li>
</ul>
<h3 id="伴随矩阵">伴随矩阵</h3>
<p><span class="math inline">\(\boldsymbol{A}^* = \left[\begin{matrix}A_{11} &amp;A_{21} &amp;\cdots &amp;A_{n1} \\A_{12} &amp;A_{22} &amp;\cdots &amp;A_{n2} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ A_{1n} &amp; A_{2n} &amp;\cdots &amp;A_{nn}\end{matrix} \right]\)</span> 称为 <strong><em>A</em></strong> 的『<strong>伴随矩阵</strong>』，即 <strong><em>A</em></strong> 的伴随矩阵是 <strong><em>A</em></strong> 的代数余子式矩阵的转置。</p>
<p>伴随矩阵的运算规律：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{AA}^* = \boldsymbol{A}^*\boldsymbol{A} = |\boldsymbol{A}|\boldsymbol{E}\)</span></li>
<li>若 <strong><em>A</em></strong> 可逆，则 <span class="math inline">\(\boldsymbol{A}^* = |\boldsymbol{A}|\boldsymbol{A}^{-1}\)</span>。</li>
<li><span class="math inline">\(\boldsymbol{A} \in \mathbb{R}^{n \times n}, \;(k\boldsymbol{A})^* = k^{n-1}\boldsymbol{A}^*\)</span></li>
<li><span class="math inline">\((\boldsymbol{AB})^* = \boldsymbol{B}^*\boldsymbol{A}^*\)</span>（<strong>穿脱原则</strong>）</li>
<li><span class="math inline">\(\boldsymbol{A} \in \mathbb{R}^{n \times n}\)</span>
<ul>
<li><span class="math inline">\(|\boldsymbol{A}^*| = |\boldsymbol{A}|^{n-1}\)</span></li>
<li><span class="math inline">\({\left(\boldsymbol{A}^*\right)}^*= |\boldsymbol{A}|^{n-2}\boldsymbol{A}\)</span></li>
<li><span class="math inline">\(\left|{\left(\boldsymbol{A}^*\right)}^*\right|=|\boldsymbol{A}|^{(n-1)^2}\)</span></li>
</ul></li>
<li><span class="math inline">\(\boldsymbol{A} \in \mathbb{R}^{n \times n}, \; r(\boldsymbol{A}^*) = \left\{\begin{aligned} &amp;n, \quad r(\boldsymbol{A}) = n \\ &amp;1, \quad r(\boldsymbol{A}) = n - 1 \\ &amp;0, \quad r(\boldsymbol{A}) &lt; n-1 \end{aligned}\right.\)</span></li>
</ul>
<p><strong>矩阵的转置、逆和伴随运算两两可交换：</strong></p>
<ul>
<li><span class="math inline">\({\left(\boldsymbol{A}^*\right)}^{-1} = {\left(\boldsymbol{A}^{-1}\right)}^*\)</span></li>
<li><span class="math inline">\(\left(\boldsymbol{A}^*\right)^{\text{T}} = \left(\boldsymbol{A}^{\text{T}}\right)^*\)</span></li>
<li><span class="math inline">\({\left(\boldsymbol{A}^{-1}\right)}^{\text{T}} = { \left(\boldsymbol{A}^{\text{T}}\right)}^{-1}\)</span></li>
</ul>
<h3 id="分块矩阵">分块矩阵</h3>
<ul>
<li>线性运算和乘法：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;k_1\left[\begin{matrix}
\boldsymbol{A}_1 &amp;\boldsymbol{A}_2\\
\boldsymbol{A}_3 &amp;\boldsymbol{A}_4
\end{matrix}\right] +
k_2\left[\begin{matrix}
\boldsymbol{B}_1 &amp;\boldsymbol{B}_2\\
\boldsymbol{B}_3 &amp;\boldsymbol{B}_4
\end{matrix}\right]
=\left[\begin{matrix}
k_1\boldsymbol{A}_1 +k_2\boldsymbol{B}_1 &amp;k_1\boldsymbol{A}_2 +k_2\boldsymbol{B}_2\\
k_1\boldsymbol{A}_3 +k_2\boldsymbol{B}_3&amp;k_1\boldsymbol{A}_4 +k_2\boldsymbol{B}_4
\end{matrix}\right] \\
&amp;\left[\begin{matrix}
\boldsymbol{A} &amp;\boldsymbol{B}\\
\boldsymbol{C} &amp;\boldsymbol{D}
\end{matrix}\right]
\left[\begin{matrix}
\boldsymbol{X} &amp;\boldsymbol{Y}\\
\boldsymbol{Z} &amp;\boldsymbol{W}
\end{matrix}\right] =
\left[\begin{matrix}
\boldsymbol{AX}+\boldsymbol{BZ} &amp;\boldsymbol{AY}+\boldsymbol{BW}\\
\boldsymbol{CX}+\boldsymbol{BZ} &amp;\boldsymbol{CY}+\boldsymbol{DW}
\end{matrix}\right] \\
\end{aligned}
\]</span></p>
<ul>
<li>转置、幂和逆运算：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\left[\begin{matrix}
\boldsymbol{A} &amp;\boldsymbol{B}\\
\boldsymbol{C} &amp;\boldsymbol{D}
\end{matrix}\right]^{\text{T}} =
\left[\begin{matrix}
\boldsymbol{A}^{\text{T}} &amp;\boldsymbol{C}^{\text{T}} \\
\boldsymbol{B}^{\text{T}} &amp;\boldsymbol{D}^{\text{T}}
\end{matrix}\right] \\
&amp;\left[\begin{matrix}
\boldsymbol{B}_{k \times k} &amp;\boldsymbol{O}\\
\boldsymbol{O} &amp;\boldsymbol{C}_{l \times l}
\end{matrix}\right]^n = 
\left[\begin{matrix}
\boldsymbol{B}^n &amp;\boldsymbol{O}\\
\boldsymbol{O} &amp;\boldsymbol{C}^n
\end{matrix}\right] \\
&amp;\left[\begin{matrix}
\boldsymbol{P} &amp;\boldsymbol{O}\\
\boldsymbol{O} &amp;\boldsymbol{Q}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
\boldsymbol{P}^{-1} &amp;\boldsymbol{O}\\
\boldsymbol{O} &amp;\boldsymbol{Q}^{-1}
\end{matrix}\right], \quad
\left[\begin{matrix}
\boldsymbol{O} &amp;\boldsymbol{P}\\
\boldsymbol{Q} &amp;\boldsymbol{O}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
\boldsymbol{O} &amp;\boldsymbol{Q}^{-1}\\
\boldsymbol{P}^{-1} &amp;\boldsymbol{O}
\end{matrix}\right] \\
&amp;\left[\begin{matrix}
\boldsymbol{P} &amp;\boldsymbol{O}\\
\boldsymbol{X} &amp;\boldsymbol{Q}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
\boldsymbol{P}^{-1} &amp;\boldsymbol{O}\\
-\boldsymbol{Q}^{-1}\boldsymbol{XP}^{-1} &amp;\boldsymbol{Q}^{-1}
\end{matrix}\right]\\
&amp;\left[\begin{matrix}
\boldsymbol{P} &amp;\boldsymbol{X}\\
\boldsymbol{O} &amp;\boldsymbol{Q}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
\boldsymbol{P}^{-1} &amp;-\boldsymbol{P}^{-1}\boldsymbol{XQ}^{-1}\\
\boldsymbol{O} &amp;\boldsymbol{Q}^{-1}
\end{matrix}\right]\\
&amp;\left[\begin{matrix}
\boldsymbol{X} &amp;\boldsymbol{P}\\
\boldsymbol{Q} &amp;\boldsymbol{O}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
-\boldsymbol{Q}^{-1}\boldsymbol{XP}^{-1} &amp;\boldsymbol{Q}^{-1}\\
\boldsymbol{P}^{-1} &amp;\boldsymbol{O}
\end{matrix}\right] \\
&amp;\left[\begin{matrix}
\boldsymbol{O} &amp;\boldsymbol{P}\\
\boldsymbol{Q} &amp;\boldsymbol{X}
\end{matrix}\right]^{-1} = 
\left[\begin{matrix}
\boldsymbol{O} &amp;\boldsymbol{Q}^{-1}\\
\boldsymbol{P}^{-1} &amp;-\boldsymbol{P}^{-1}\boldsymbol{XQ}^{-1}
\end{matrix}\right]
\end{aligned}
\]</span></p>
<ul>
<li>主对角线分块矩阵和副对角线分块矩阵：</li>
</ul>
<p><span class="math display">\[
\boldsymbol{A} = \begin{bmatrix} \boldsymbol{A}_1 &amp;\; &amp;\; &amp;\; \\ \; &amp;\boldsymbol{A}_2 &amp;\; &amp;\; \\ \; &amp;\; &amp;\ddots &amp;\; \\ \; &amp;\; &amp;\; &amp;\boldsymbol{A}_s\end{bmatrix},\;
\boldsymbol{B} = \begin{bmatrix} 
\; &amp;\; &amp;\; &amp;\boldsymbol{B}_1 \\ 
\;  &amp;\; &amp;\boldsymbol{B}_2 &amp;\; \\ 
\; &amp;\cdots &amp;\; &amp;\; \\ 
\boldsymbol{B}_s &amp;\; &amp;\; &amp;\;
\end{bmatrix}
\]</span></p>
<p>则</p>
<p><span class="math display">\[
\boldsymbol{A}^{\text{T}} = \begin{bmatrix} {\boldsymbol{A}_1}^{\text{T}} &amp;\; &amp;\; &amp;\; \\ \; &amp;{\boldsymbol{A}_2}^{\text{T}} &amp;\; &amp;\; \\ \; &amp;\; &amp;\ddots &amp;\; \\ \; &amp;\; &amp;\; &amp;{\boldsymbol{A}_s}^{\text{T}} \end{bmatrix} ,\;
\boldsymbol{B}^{\text{T}} = \begin{bmatrix} 
\; &amp;\; &amp;\; &amp;{\boldsymbol{B}_s}^{\text{T}} \\ 
\;  &amp;\; &amp;\cdots &amp;\; \\
\;  &amp;{\boldsymbol{B}_2}^{\text{T}} &amp;\;  &amp;\; \\  
{\boldsymbol{B}_1}^{\text{T}} &amp;\; &amp;\; &amp;\;
\end{bmatrix}
\]</span></p>
<p>若 <span class="math inline">\(\boldsymbol{A}_i,\boldsymbol{B}_i\;(i=1,2,\ldots,s)\)</span> 均可逆，则 <span class="math inline">\(\boldsymbol{A},\boldsymbol{B}\)</span> 可逆：</p>
<p><span class="math display">\[
\boldsymbol{A}^{-1} = \begin{bmatrix} {\boldsymbol{A}_1}^{-1} &amp;\; &amp;\; &amp;\; \\ \; &amp;{\boldsymbol{A}_2}^{-1} &amp;\; &amp;\; \\ \; &amp;\; &amp;\ddots &amp;\; \\ \; &amp;\; &amp;\; &amp;{\boldsymbol{A}_s}^{-1} \end{bmatrix} ,\;
\boldsymbol{B}^{-1} = \begin{bmatrix} 
\; &amp;\; &amp;\; &amp;{\boldsymbol{B}_s}^{-1} \\ 
\;  &amp;\; &amp;\cdots &amp;\; \\ 
\;  &amp;{\boldsymbol{B}_2}^{-1} &amp;\;  &amp;\; \\ 
{\boldsymbol{B}_1}^{-1} &amp;\; &amp;\; &amp;\;
\end{bmatrix}
\]</span></p>
<p>若 <span class="math inline">\(\boldsymbol{A}_i \;(i =1,2,\ldots,s)\)</span> 均为方阵，则</p>
<p><span class="math display">\[
\boldsymbol{A}^{k} = \begin{bmatrix} 
{\boldsymbol{A}_1}^{k} &amp;\; &amp;\; &amp;\; \\ 
\; &amp;{\boldsymbol{A}_2}^{k} &amp;\; &amp;\; \\ 
\; &amp;\; &amp;\ddots &amp;\; \\ 
\; &amp;\; &amp;\; &amp;{\boldsymbol{A}_s}^{k}
\end{bmatrix}
\]</span></p>
<p>若 <span class="math inline">\(\boldsymbol{B}_i \;(i =1,2,\ldots,s)\)</span> 均为同阶方阵，则</p>
<p><span class="math display">\[
\boldsymbol{B}^{2} = \begin{bmatrix} 
\boldsymbol{B}_1\boldsymbol{B}_s &amp;\; &amp;\; &amp;\; \\ 
\; &amp;\boldsymbol{B}_2\boldsymbol{B}_{s-1} &amp;\; &amp;\; \\ 
\; &amp;\; &amp;\ddots &amp;\; \\ 
\; &amp;\; &amp;\; &amp;\boldsymbol{B}_s\boldsymbol{B}_1
\end{bmatrix}
\]</span></p>
<p>注：若 <span class="math inline">\(\boldsymbol{A}_i,\boldsymbol{B}_i\;(i=1,2,\ldots,s)\)</span> 均为常数，则 <span class="math inline">\(\boldsymbol{A},\boldsymbol{B}\)</span> 分别为『对角矩阵』和『反对角矩阵』，以上的性质仍成立。</p>
<h3 id="矩阵的秩">矩阵的秩</h3>
<p>矩阵的秩的定义：<span class="math inline">\(\boldsymbol{A} \in \mathbb{R}^{m \times n}\)</span>，<strong><em>A</em></strong> 中最大的不为零的『子式』的阶数称为 <strong><em>A</em></strong> 的秩，记作 <span class="math inline">\(r(\boldsymbol{A})\)</span>。或者说若 <strong><em>A</em></strong> 存在 <em>k</em> 阶不为零子式，而任意 <span class="math inline">\(k + 1\)</span> 阶子式全为零或不存在，则 <span class="math inline">\(r(\boldsymbol{A}) = k\)</span>。</p>
<ol type="1">
<li>阶梯形矩阵</li>
</ol>
<p>高斯消元法：对矩阵做初等行变换，从上到下依次消元，得到『阶梯形矩阵』。</p>
<p><span class="math display">\[
\text{e.g.} \; 
\left[\begin{matrix}
1 &amp;2 &amp;3 \\
3 &amp;1 &amp;2 \\
2 &amp;3 &amp;1
\end{matrix}
\right] \xrightarrow[-2r_1+r_3]{-3r_1+r_2} 
\left[\begin{matrix}
1 &amp;2 &amp;3 \\
0 &amp;-5 &amp;-7 \\
0 &amp;-1 &amp;-5
\end{matrix}
\right]
\xrightarrow[-r_2,-r_3]{r_2 \leftrightarrow r_3}
\left[\begin{matrix}
1 &amp;2 &amp;3 \\
0 &amp;1 &amp;5 \\
0 &amp;5 &amp;7
\end{matrix}
\right]
\xrightarrow[-r_3]{-5r_2+r_3}
\left[\begin{matrix}
1 &amp;2 &amp;3 \\
0 &amp;1 &amp;5 \\
0 &amp;0 &amp;18
\end{matrix}
\right]
\]</span></p>
<p>将矩阵化为阶梯形矩阵后，每一行从左至右第一个非零元素称为『主元』，主元所在的的列称为矩阵的『主元列』，其他列称为『自由列』。</p>
<p>对阶梯形矩阵进行初等行变换，使每个主元等于 1，且每个主列除了主元为 1 外其他元素都为 0，称这样的矩阵为『行最简形矩阵』。</p>
<p><strong>矩阵 <em>A</em> 的秩等于 <em>A</em> 的阶梯矩阵的『阶梯数』即主元（列）数。自由列数 <span class="math inline">\(s = n - r(\boldsymbol{A})\)</span>。</strong></p>
<ol start="2" type="1">
<li>重要结论：</li>
</ol>
<ul>
<li><span class="math inline">\(0 \leq r(\boldsymbol{A}_{m \times n}) \leq \min(m,n)\)</span></li>
<li><span class="math inline">\(r(\boldsymbol{A}) = r(\boldsymbol{A}^{\text{T}}) = r(\boldsymbol{AA}^{\text{T}}) = r(\boldsymbol{A}^{\text{T}}\boldsymbol{A})\)</span></li>
<li>初等变换不改变矩阵的秩 <span class="math inline">\(\Leftrightarrow r(\boldsymbol{PAQ}) = r(\boldsymbol{A})\)</span>。</li>
<li><span class="math inline">\(r(\boldsymbol{A}) + r(\boldsymbol{B})-n \leq r(\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s}) \leq \min(r(\boldsymbol{A}),r(\boldsymbol{B}))\)</span></li>
<li><span class="math inline">\(\boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \times s} = \boldsymbol{O} \Rightarrow r(\boldsymbol{A})+r(\boldsymbol{B}) \leq n\)</span></li>
<li><span class="math inline">\(r(\boldsymbol{A}+\boldsymbol{B}) \leq r[\boldsymbol{A},\boldsymbol{B}] \leq r(\boldsymbol{A}) + r(\boldsymbol{B})\)</span></li>
<li><span class="math inline">\(r(\boldsymbol{A})+r(\boldsymbol{B}) = r\left(\left[ \begin{matrix} \boldsymbol{A} &amp;\boldsymbol{O}\\ \boldsymbol{O} &amp;\boldsymbol{B}\end{matrix}\right]\right)\)</span></li>
<li><span class="math inline">\(\boldsymbol{A},\boldsymbol{B},\boldsymbol{C} \in \mathbb{R}^{n \times n} \Rightarrow r(\boldsymbol{A})+r(\boldsymbol{B}) \leq r\left(\left[ \begin{matrix} \boldsymbol{A} &amp;\boldsymbol{O}\\ \boldsymbol{C} &amp;\boldsymbol{B}\end{matrix}\right]\right) \leq r(\boldsymbol{A})+r(\boldsymbol{B}) + r(\boldsymbol{C})\)</span></li>
<li><span class="math inline">\(\boldsymbol{A}^2 = \boldsymbol{A} \Rightarrow r(\boldsymbol{A}) + r(\boldsymbol{A}-\boldsymbol{E}) = n\)</span></li>
<li><span class="math inline">\(\boldsymbol{A}^2 = \boldsymbol{E} \Rightarrow r(\boldsymbol{A+\boldsymbol{E}}) + r(\boldsymbol{A}-\boldsymbol{E}) = n\)</span></li>
</ul>
<h3 id="矩阵的等价和等价标准形">矩阵的等价和等价标准形</h3>
<p><span class="math inline">\(\boldsymbol{P},\boldsymbol{Q}\)</span> 为可逆矩阵，若 <span class="math inline">\(\boldsymbol{PAQ} = \boldsymbol{B}\)</span>，则称矩阵 <strong><em>A</em></strong> 『<strong>等价</strong>』于矩阵 <strong><em>B</em></strong>，记作 <span class="math inline">\(\boldsymbol{A} \cong \boldsymbol{B}\)</span>。</p>
<p>推论：</p>
<ul>
<li><span class="math inline">\(\boldsymbol{A} \cong \boldsymbol{B} \Leftrightarrow\)</span> 矩阵 <strong><em>A</em></strong> 可以通过有限次初等变换化为矩阵 <strong><em>B</em></strong>。</li>
<li><span class="math inline">\(\boldsymbol{A} \cong \boldsymbol{B} \Leftrightarrow \boldsymbol{A},\boldsymbol{B} \in \mathbb{R}^{m \times n},\;r(\boldsymbol{A}) = r(\boldsymbol{B})\)</span> 注意 <span class="math inline">\(\boldsymbol{A},\boldsymbol{B}\)</span> 必须<strong>同型</strong>。</li>
</ul>
<p>任何矩阵都可以通过有限次初等变换化为其『等价标准形』：</p>
<p><span class="math display">\[
\boldsymbol{A} \xrightarrow{\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{A}\cdots \boldsymbol{P}_k} \left[
\begin{matrix}
\boldsymbol{E_r} &amp;\boldsymbol{O} \\
\boldsymbol{O} &amp;\boldsymbol{O}
\end{matrix}
\right]
\]</span></p>
<h2 id="计算">计算</h2>
<h3 id="求矩阵的幂">求矩阵的幂</h3>
<h3 id="求逆矩阵">求逆矩阵</h3>
<ol type="1">
<li>具体型</li>
</ol>
<ul>
<li>通过初等变换：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;[\begin{matrix}\boldsymbol{A} &amp;\boldsymbol{E}\end{matrix}] \xrightarrow[\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k\boldsymbol{E}]{\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k \boldsymbol{A}} [\begin{matrix}\boldsymbol{E} &amp;\boldsymbol{A}^{-1}\end{matrix}] ,\;\boldsymbol{A}^{-1} = \boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k \\
&amp;\left[\begin{matrix}\boldsymbol{A} \\ \boldsymbol{E} \end{matrix}\right] \xrightarrow[\boldsymbol{E}\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k]{\boldsymbol{A}\boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k} \left[ \begin{matrix}\boldsymbol{E} \\ \boldsymbol{A}^{-1} \end{matrix}\right], \;\boldsymbol{A}^{-1} = \boldsymbol{P}_1\boldsymbol{P}_2\cdots \boldsymbol{P}_k \\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\boldsymbol{A}^* = |\boldsymbol{A}|\boldsymbol{A}^{-1}\)</span></li>
</ul>
<ol start="2" type="1">
<li>抽象型</li>
</ol>
<ul>
<li>变形得 <span class="math inline">\(\boldsymbol{AB} = \boldsymbol{E} \Rightarrow \boldsymbol{A}^{-1} = \boldsymbol{B}\)</span>。</li>
<li>变形得 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{BC} \Rightarrow \boldsymbol{A}^{-1} = \boldsymbol{C}^{-1}\boldsymbol{B}^{-1}\)</span>。</li>
</ul>
<h3 id="矩阵方程">矩阵方程</h3>
<!--
$$
\text{上岸} = 
\left|\begin{matrix}
\text{稳} &\sqrt{\text{批}}\\
\sqrt{\text{批}} &\text{得}
\end{matrix}\right|
$$
-->
<ul>
<li><p><span class="math inline">\(\boldsymbol{AB} = \boldsymbol{O}\)</span></p></li>
<li><p><span class="math inline">\(\boldsymbol{AB} = \boldsymbol{B}\)</span></p></li>
<li><p><span class="math inline">\(r(\boldsymbol{A}) = 1\)</span></p></li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
</search>
